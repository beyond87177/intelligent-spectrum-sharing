// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: interAI.proto

#ifndef PROTOBUF_interAI_2eproto__INCLUDED
#define PROTOBUF_interAI_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace aiCommunicator {
class FlowPerformance;
class FlowPerformanceDefaultTypeInternal;
extern FlowPerformanceDefaultTypeInternal _FlowPerformance_default_instance_;
class GatewayReport;
class GatewayReportDefaultTypeInternal;
extern GatewayReportDefaultTypeInternal _GatewayReport_default_instance_;
class InternalAI;
class InternalAIDefaultTypeInternal;
extern InternalAIDefaultTypeInternal _InternalAI_default_instance_;
class InternalVoxel;
class InternalVoxelDefaultTypeInternal;
extern InternalVoxelDefaultTypeInternal _InternalVoxel_default_instance_;
class Location;
class LocationDefaultTypeInternal;
extern LocationDefaultTypeInternal _Location_default_instance_;
class NodePerformance;
class NodePerformanceDefaultTypeInternal;
extern NodePerformanceDefaultTypeInternal _NodePerformance_default_instance_;
class TXGainChanged;
class TXGainChangedDefaultTypeInternal;
extern TXGainChangedDefaultTypeInternal _TXGainChanged_default_instance_;
class TXSlotAllocated;
class TXSlotAllocatedDefaultTypeInternal;
extern TXSlotAllocatedDefaultTypeInternal _TXSlotAllocated_default_instance_;
class TXSlotRemoved;
class TXSlotRemovedDefaultTypeInternal;
extern TXSlotRemovedDefaultTypeInternal _TXSlotRemoved_default_instance_;
}  // namespace aiCommunicator

namespace aiCommunicator {

namespace protobuf_interAI_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_interAI_2eproto

enum Query {
  QUERY_UNKNOWN = 0,
  QUERY_WHO_IS_GATEWAY = 257,
  QUERY_I_AM_GATEWAY = 258,
  Query_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Query_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Query_IsValid(int value);
const Query Query_MIN = QUERY_UNKNOWN;
const Query Query_MAX = QUERY_I_AM_GATEWAY;
const int Query_ARRAYSIZE = Query_MAX + 1;

const ::google::protobuf::EnumDescriptor* Query_descriptor();
inline const ::std::string& Query_Name(Query value) {
  return ::google::protobuf::internal::NameOfEnum(
    Query_descriptor(), value);
}
inline bool Query_Parse(
    const ::std::string& name, Query* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Query>(
    Query_descriptor(), name, value);
}
// ===================================================================

class Location : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aiCommunicator.Location) */ {
 public:
  Location();
  virtual ~Location();

  Location(const Location& from);

  inline Location& operator=(const Location& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Location& default_instance();

  static inline const Location* internal_default_instance() {
    return reinterpret_cast<const Location*>(
               &_Location_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Location* other);

  // implements Message ----------------------------------------------

  inline Location* New() const PROTOBUF_FINAL { return New(NULL); }

  Location* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Location& from);
  void MergeFrom(const Location& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Location* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double longitude = 1;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 1;
  double longitude() const;
  void set_longitude(double value);

  // double latitude = 2;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 2;
  double latitude() const;
  void set_latitude(double value);

  // double elevation = 3;
  void clear_elevation();
  static const int kElevationFieldNumber = 3;
  double elevation() const;
  void set_elevation(double value);

  // @@protoc_insertion_point(class_scope:aiCommunicator.Location)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double longitude_;
  double latitude_;
  double elevation_;
  mutable int _cached_size_;
  friend struct protobuf_interAI_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InternalVoxel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aiCommunicator.InternalVoxel) */ {
 public:
  InternalVoxel();
  virtual ~InternalVoxel();

  InternalVoxel(const InternalVoxel& from);

  inline InternalVoxel& operator=(const InternalVoxel& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalVoxel& default_instance();

  static inline const InternalVoxel* internal_default_instance() {
    return reinterpret_cast<const InternalVoxel*>(
               &_InternalVoxel_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(InternalVoxel* other);

  // implements Message ----------------------------------------------

  inline InternalVoxel* New() const PROTOBUF_FINAL { return New(NULL); }

  InternalVoxel* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const InternalVoxel& from);
  void MergeFrom(const InternalVoxel& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(InternalVoxel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 timeslot = 1;
  void clear_timeslot();
  static const int kTimeslotFieldNumber = 1;
  ::google::protobuf::uint32 timeslot() const;
  void set_timeslot(::google::protobuf::uint32 value);

  // uint32 channel = 2;
  void clear_channel();
  static const int kChannelFieldNumber = 2;
  ::google::protobuf::uint32 channel() const;
  void set_channel(::google::protobuf::uint32 value);

  // uint64 dst = 3;
  void clear_dst();
  static const int kDstFieldNumber = 3;
  ::google::protobuf::uint64 dst() const;
  void set_dst(::google::protobuf::uint64 value);

  // uint64 validitystart = 4;
  void clear_validitystart();
  static const int kValiditystartFieldNumber = 4;
  ::google::protobuf::uint64 validitystart() const;
  void set_validitystart(::google::protobuf::uint64 value);

  // uint32 tx_gain = 5;
  void clear_tx_gain();
  static const int kTxGainFieldNumber = 5;
  ::google::protobuf::uint32 tx_gain() const;
  void set_tx_gain(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aiCommunicator.InternalVoxel)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 timeslot_;
  ::google::protobuf::uint32 channel_;
  ::google::protobuf::uint64 dst_;
  ::google::protobuf::uint64 validitystart_;
  ::google::protobuf::uint32 tx_gain_;
  mutable int _cached_size_;
  friend struct protobuf_interAI_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TXSlotAllocated : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aiCommunicator.TXSlotAllocated) */ {
 public:
  TXSlotAllocated();
  virtual ~TXSlotAllocated();

  TXSlotAllocated(const TXSlotAllocated& from);

  inline TXSlotAllocated& operator=(const TXSlotAllocated& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TXSlotAllocated& default_instance();

  static inline const TXSlotAllocated* internal_default_instance() {
    return reinterpret_cast<const TXSlotAllocated*>(
               &_TXSlotAllocated_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(TXSlotAllocated* other);

  // implements Message ----------------------------------------------

  inline TXSlotAllocated* New() const PROTOBUF_FINAL { return New(NULL); }

  TXSlotAllocated* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TXSlotAllocated& from);
  void MergeFrom(const TXSlotAllocated& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TXSlotAllocated* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 dst = 1;
  void clear_dst();
  static const int kDstFieldNumber = 1;
  ::google::protobuf::uint64 dst() const;
  void set_dst(::google::protobuf::uint64 value);

  // uint32 timeslot = 2;
  void clear_timeslot();
  static const int kTimeslotFieldNumber = 2;
  ::google::protobuf::uint32 timeslot() const;
  void set_timeslot(::google::protobuf::uint32 value);

  // uint32 channel = 3;
  void clear_channel();
  static const int kChannelFieldNumber = 3;
  ::google::protobuf::uint32 channel() const;
  void set_channel(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aiCommunicator.TXSlotAllocated)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 dst_;
  ::google::protobuf::uint32 timeslot_;
  ::google::protobuf::uint32 channel_;
  mutable int _cached_size_;
  friend struct protobuf_interAI_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TXSlotRemoved : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aiCommunicator.TXSlotRemoved) */ {
 public:
  TXSlotRemoved();
  virtual ~TXSlotRemoved();

  TXSlotRemoved(const TXSlotRemoved& from);

  inline TXSlotRemoved& operator=(const TXSlotRemoved& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TXSlotRemoved& default_instance();

  static inline const TXSlotRemoved* internal_default_instance() {
    return reinterpret_cast<const TXSlotRemoved*>(
               &_TXSlotRemoved_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(TXSlotRemoved* other);

  // implements Message ----------------------------------------------

  inline TXSlotRemoved* New() const PROTOBUF_FINAL { return New(NULL); }

  TXSlotRemoved* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TXSlotRemoved& from);
  void MergeFrom(const TXSlotRemoved& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TXSlotRemoved* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 timeslot = 1;
  void clear_timeslot();
  static const int kTimeslotFieldNumber = 1;
  ::google::protobuf::uint32 timeslot() const;
  void set_timeslot(::google::protobuf::uint32 value);

  // uint32 channel = 2;
  void clear_channel();
  static const int kChannelFieldNumber = 2;
  ::google::protobuf::uint32 channel() const;
  void set_channel(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aiCommunicator.TXSlotRemoved)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 timeslot_;
  ::google::protobuf::uint32 channel_;
  mutable int _cached_size_;
  friend struct protobuf_interAI_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TXGainChanged : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aiCommunicator.TXGainChanged) */ {
 public:
  TXGainChanged();
  virtual ~TXGainChanged();

  TXGainChanged(const TXGainChanged& from);

  inline TXGainChanged& operator=(const TXGainChanged& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TXGainChanged& default_instance();

  static inline const TXGainChanged* internal_default_instance() {
    return reinterpret_cast<const TXGainChanged*>(
               &_TXGainChanged_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(TXGainChanged* other);

  // implements Message ----------------------------------------------

  inline TXGainChanged* New() const PROTOBUF_FINAL { return New(NULL); }

  TXGainChanged* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TXGainChanged& from);
  void MergeFrom(const TXGainChanged& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TXGainChanged* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 dst = 1;
  void clear_dst();
  static const int kDstFieldNumber = 1;
  ::google::protobuf::uint64 dst() const;
  void set_dst(::google::protobuf::uint64 value);

  // uint32 gain = 2;
  void clear_gain();
  static const int kGainFieldNumber = 2;
  ::google::protobuf::uint32 gain() const;
  void set_gain(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aiCommunicator.TXGainChanged)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 dst_;
  ::google::protobuf::uint32 gain_;
  mutable int _cached_size_;
  friend struct protobuf_interAI_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NodePerformance : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aiCommunicator.NodePerformance) */ {
 public:
  NodePerformance();
  virtual ~NodePerformance();

  NodePerformance(const NodePerformance& from);

  inline NodePerformance& operator=(const NodePerformance& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodePerformance& default_instance();

  static inline const NodePerformance* internal_default_instance() {
    return reinterpret_cast<const NodePerformance*>(
               &_NodePerformance_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(NodePerformance* other);

  // implements Message ----------------------------------------------

  inline NodePerformance* New() const PROTOBUF_FINAL { return New(NULL); }

  NodePerformance* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NodePerformance& from);
  void MergeFrom(const NodePerformance& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NodePerformance* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .aiCommunicator.FlowPerformance flows = 1;
  int flows_size() const;
  void clear_flows();
  static const int kFlowsFieldNumber = 1;
  const ::aiCommunicator::FlowPerformance& flows(int index) const;
  ::aiCommunicator::FlowPerformance* mutable_flows(int index);
  ::aiCommunicator::FlowPerformance* add_flows();
  ::google::protobuf::RepeatedPtrField< ::aiCommunicator::FlowPerformance >*
      mutable_flows();
  const ::google::protobuf::RepeatedPtrField< ::aiCommunicator::FlowPerformance >&
      flows() const;

  // @@protoc_insertion_point(class_scope:aiCommunicator.NodePerformance)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aiCommunicator::FlowPerformance > flows_;
  mutable int _cached_size_;
  friend struct protobuf_interAI_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FlowPerformance : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aiCommunicator.FlowPerformance) */ {
 public:
  FlowPerformance();
  virtual ~FlowPerformance();

  FlowPerformance(const FlowPerformance& from);

  inline FlowPerformance& operator=(const FlowPerformance& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FlowPerformance& default_instance();

  static inline const FlowPerformance* internal_default_instance() {
    return reinterpret_cast<const FlowPerformance*>(
               &_FlowPerformance_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(FlowPerformance* other);

  // implements Message ----------------------------------------------

  inline FlowPerformance* New() const PROTOBUF_FINAL { return New(NULL); }

  FlowPerformance* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FlowPerformance& from);
  void MergeFrom(const FlowPerformance& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FlowPerformance* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 flow_id = 1;
  void clear_flow_id();
  static const int kFlowIdFieldNumber = 1;
  ::google::protobuf::uint32 flow_id() const;
  void set_flow_id(::google::protobuf::uint32 value);

  // uint32 bps = 2;
  void clear_bps();
  static const int kBpsFieldNumber = 2;
  ::google::protobuf::uint32 bps() const;
  void set_bps(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:aiCommunicator.FlowPerformance)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 flow_id_;
  ::google::protobuf::uint32 bps_;
  mutable int _cached_size_;
  friend struct protobuf_interAI_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GatewayReport : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aiCommunicator.GatewayReport) */ {
 public:
  GatewayReport();
  virtual ~GatewayReport();

  GatewayReport(const GatewayReport& from);

  inline GatewayReport& operator=(const GatewayReport& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GatewayReport& default_instance();

  static inline const GatewayReport* internal_default_instance() {
    return reinterpret_cast<const GatewayReport*>(
               &_GatewayReport_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(GatewayReport* other);

  // implements Message ----------------------------------------------

  inline GatewayReport* New() const PROTOBUF_FINAL { return New(NULL); }

  GatewayReport* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GatewayReport& from);
  void MergeFrom(const GatewayReport& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GatewayReport* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .aiCommunicator.InternalVoxel slots = 4;
  int slots_size() const;
  void clear_slots();
  static const int kSlotsFieldNumber = 4;
  const ::aiCommunicator::InternalVoxel& slots(int index) const;
  ::aiCommunicator::InternalVoxel* mutable_slots(int index);
  ::aiCommunicator::InternalVoxel* add_slots();
  ::google::protobuf::RepeatedPtrField< ::aiCommunicator::InternalVoxel >*
      mutable_slots();
  const ::google::protobuf::RepeatedPtrField< ::aiCommunicator::InternalVoxel >&
      slots() const;

  // repeated .aiCommunicator.FlowPerformance flows = 5;
  int flows_size() const;
  void clear_flows();
  static const int kFlowsFieldNumber = 5;
  const ::aiCommunicator::FlowPerformance& flows(int index) const;
  ::aiCommunicator::FlowPerformance* mutable_flows(int index);
  ::aiCommunicator::FlowPerformance* add_flows();
  ::google::protobuf::RepeatedPtrField< ::aiCommunicator::FlowPerformance >*
      mutable_flows();
  const ::google::protobuf::RepeatedPtrField< ::aiCommunicator::FlowPerformance >&
      flows() const;

  // .aiCommunicator.Location location = 3;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 3;
  const ::aiCommunicator::Location& location() const;
  ::aiCommunicator::Location* mutable_location();
  ::aiCommunicator::Location* release_location();
  void set_allocated_location(::aiCommunicator::Location* location);

  // uint64 start_timestamp = 1;
  void clear_start_timestamp();
  static const int kStartTimestampFieldNumber = 1;
  ::google::protobuf::uint64 start_timestamp() const;
  void set_start_timestamp(::google::protobuf::uint64 value);

  // uint64 end_timestamp = 2;
  void clear_end_timestamp();
  static const int kEndTimestampFieldNumber = 2;
  ::google::protobuf::uint64 end_timestamp() const;
  void set_end_timestamp(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:aiCommunicator.GatewayReport)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::aiCommunicator::InternalVoxel > slots_;
  ::google::protobuf::RepeatedPtrField< ::aiCommunicator::FlowPerformance > flows_;
  ::aiCommunicator::Location* location_;
  ::google::protobuf::uint64 start_timestamp_;
  ::google::protobuf::uint64 end_timestamp_;
  mutable int _cached_size_;
  friend struct protobuf_interAI_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InternalAI : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:aiCommunicator.InternalAI) */ {
 public:
  InternalAI();
  virtual ~InternalAI();

  InternalAI(const InternalAI& from);

  inline InternalAI& operator=(const InternalAI& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalAI& default_instance();

  enum PayloadCase {
    kGwReport = 101,
    kSlotAlloc = 102,
    kSlotRemoved = 103,
    kGainChanged = 104,
    kNodeperf = 105,
    kQuery = 202,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const InternalAI* internal_default_instance() {
    return reinterpret_cast<const InternalAI*>(
               &_InternalAI_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(InternalAI* other);

  // implements Message ----------------------------------------------

  inline InternalAI* New() const PROTOBUF_FINAL { return New(NULL); }

  InternalAI* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const InternalAI& from);
  void MergeFrom(const InternalAI& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(InternalAI* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 statementID = 1;
  void clear_statementid();
  static const int kStatementIDFieldNumber = 1;
  ::google::protobuf::uint64 statementid() const;
  void set_statementid(::google::protobuf::uint64 value);

  // uint64 mac_address = 2;
  void clear_mac_address();
  static const int kMacAddressFieldNumber = 2;
  ::google::protobuf::uint64 mac_address() const;
  void set_mac_address(::google::protobuf::uint64 value);

  // int32 nodeIndex = 3;
  void clear_nodeindex();
  static const int kNodeIndexFieldNumber = 3;
  ::google::protobuf::int32 nodeindex() const;
  void set_nodeindex(::google::protobuf::int32 value);

  // .aiCommunicator.GatewayReport gw_report = 101;
  bool has_gw_report() const;
  void clear_gw_report();
  static const int kGwReportFieldNumber = 101;
  const ::aiCommunicator::GatewayReport& gw_report() const;
  ::aiCommunicator::GatewayReport* mutable_gw_report();
  ::aiCommunicator::GatewayReport* release_gw_report();
  void set_allocated_gw_report(::aiCommunicator::GatewayReport* gw_report);

  // .aiCommunicator.TXSlotAllocated slot_alloc = 102;
  bool has_slot_alloc() const;
  void clear_slot_alloc();
  static const int kSlotAllocFieldNumber = 102;
  const ::aiCommunicator::TXSlotAllocated& slot_alloc() const;
  ::aiCommunicator::TXSlotAllocated* mutable_slot_alloc();
  ::aiCommunicator::TXSlotAllocated* release_slot_alloc();
  void set_allocated_slot_alloc(::aiCommunicator::TXSlotAllocated* slot_alloc);

  // .aiCommunicator.TXSlotRemoved slot_removed = 103;
  bool has_slot_removed() const;
  void clear_slot_removed();
  static const int kSlotRemovedFieldNumber = 103;
  const ::aiCommunicator::TXSlotRemoved& slot_removed() const;
  ::aiCommunicator::TXSlotRemoved* mutable_slot_removed();
  ::aiCommunicator::TXSlotRemoved* release_slot_removed();
  void set_allocated_slot_removed(::aiCommunicator::TXSlotRemoved* slot_removed);

  // .aiCommunicator.TXGainChanged gain_changed = 104;
  bool has_gain_changed() const;
  void clear_gain_changed();
  static const int kGainChangedFieldNumber = 104;
  const ::aiCommunicator::TXGainChanged& gain_changed() const;
  ::aiCommunicator::TXGainChanged* mutable_gain_changed();
  ::aiCommunicator::TXGainChanged* release_gain_changed();
  void set_allocated_gain_changed(::aiCommunicator::TXGainChanged* gain_changed);

  // .aiCommunicator.NodePerformance nodeperf = 105;
  bool has_nodeperf() const;
  void clear_nodeperf();
  static const int kNodeperfFieldNumber = 105;
  const ::aiCommunicator::NodePerformance& nodeperf() const;
  ::aiCommunicator::NodePerformance* mutable_nodeperf();
  ::aiCommunicator::NodePerformance* release_nodeperf();
  void set_allocated_nodeperf(::aiCommunicator::NodePerformance* nodeperf);

  // .aiCommunicator.Query query = 202;
  private:
  bool has_query() const;
  public:
  void clear_query();
  static const int kQueryFieldNumber = 202;
  ::aiCommunicator::Query query() const;
  void set_query(::aiCommunicator::Query value);

  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:aiCommunicator.InternalAI)
 private:
  void set_has_gw_report();
  void set_has_slot_alloc();
  void set_has_slot_removed();
  void set_has_gain_changed();
  void set_has_nodeperf();
  void set_has_query();

  inline bool has_payload() const;
  void clear_payload();
  inline void clear_has_payload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 statementid_;
  ::google::protobuf::uint64 mac_address_;
  ::google::protobuf::int32 nodeindex_;
  union PayloadUnion {
    PayloadUnion() {}
    ::aiCommunicator::GatewayReport* gw_report_;
    ::aiCommunicator::TXSlotAllocated* slot_alloc_;
    ::aiCommunicator::TXSlotRemoved* slot_removed_;
    ::aiCommunicator::TXGainChanged* gain_changed_;
    ::aiCommunicator::NodePerformance* nodeperf_;
    int query_;
  } payload_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_interAI_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Location

// double longitude = 1;
inline void Location::clear_longitude() {
  longitude_ = 0;
}
inline double Location::longitude() const {
  // @@protoc_insertion_point(field_get:aiCommunicator.Location.longitude)
  return longitude_;
}
inline void Location::set_longitude(double value) {
  
  longitude_ = value;
  // @@protoc_insertion_point(field_set:aiCommunicator.Location.longitude)
}

// double latitude = 2;
inline void Location::clear_latitude() {
  latitude_ = 0;
}
inline double Location::latitude() const {
  // @@protoc_insertion_point(field_get:aiCommunicator.Location.latitude)
  return latitude_;
}
inline void Location::set_latitude(double value) {
  
  latitude_ = value;
  // @@protoc_insertion_point(field_set:aiCommunicator.Location.latitude)
}

// double elevation = 3;
inline void Location::clear_elevation() {
  elevation_ = 0;
}
inline double Location::elevation() const {
  // @@protoc_insertion_point(field_get:aiCommunicator.Location.elevation)
  return elevation_;
}
inline void Location::set_elevation(double value) {
  
  elevation_ = value;
  // @@protoc_insertion_point(field_set:aiCommunicator.Location.elevation)
}

// -------------------------------------------------------------------

// InternalVoxel

// uint32 timeslot = 1;
inline void InternalVoxel::clear_timeslot() {
  timeslot_ = 0u;
}
inline ::google::protobuf::uint32 InternalVoxel::timeslot() const {
  // @@protoc_insertion_point(field_get:aiCommunicator.InternalVoxel.timeslot)
  return timeslot_;
}
inline void InternalVoxel::set_timeslot(::google::protobuf::uint32 value) {
  
  timeslot_ = value;
  // @@protoc_insertion_point(field_set:aiCommunicator.InternalVoxel.timeslot)
}

// uint32 channel = 2;
inline void InternalVoxel::clear_channel() {
  channel_ = 0u;
}
inline ::google::protobuf::uint32 InternalVoxel::channel() const {
  // @@protoc_insertion_point(field_get:aiCommunicator.InternalVoxel.channel)
  return channel_;
}
inline void InternalVoxel::set_channel(::google::protobuf::uint32 value) {
  
  channel_ = value;
  // @@protoc_insertion_point(field_set:aiCommunicator.InternalVoxel.channel)
}

// uint64 dst = 3;
inline void InternalVoxel::clear_dst() {
  dst_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 InternalVoxel::dst() const {
  // @@protoc_insertion_point(field_get:aiCommunicator.InternalVoxel.dst)
  return dst_;
}
inline void InternalVoxel::set_dst(::google::protobuf::uint64 value) {
  
  dst_ = value;
  // @@protoc_insertion_point(field_set:aiCommunicator.InternalVoxel.dst)
}

// uint64 validitystart = 4;
inline void InternalVoxel::clear_validitystart() {
  validitystart_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 InternalVoxel::validitystart() const {
  // @@protoc_insertion_point(field_get:aiCommunicator.InternalVoxel.validitystart)
  return validitystart_;
}
inline void InternalVoxel::set_validitystart(::google::protobuf::uint64 value) {
  
  validitystart_ = value;
  // @@protoc_insertion_point(field_set:aiCommunicator.InternalVoxel.validitystart)
}

// uint32 tx_gain = 5;
inline void InternalVoxel::clear_tx_gain() {
  tx_gain_ = 0u;
}
inline ::google::protobuf::uint32 InternalVoxel::tx_gain() const {
  // @@protoc_insertion_point(field_get:aiCommunicator.InternalVoxel.tx_gain)
  return tx_gain_;
}
inline void InternalVoxel::set_tx_gain(::google::protobuf::uint32 value) {
  
  tx_gain_ = value;
  // @@protoc_insertion_point(field_set:aiCommunicator.InternalVoxel.tx_gain)
}

// -------------------------------------------------------------------

// TXSlotAllocated

// uint64 dst = 1;
inline void TXSlotAllocated::clear_dst() {
  dst_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 TXSlotAllocated::dst() const {
  // @@protoc_insertion_point(field_get:aiCommunicator.TXSlotAllocated.dst)
  return dst_;
}
inline void TXSlotAllocated::set_dst(::google::protobuf::uint64 value) {
  
  dst_ = value;
  // @@protoc_insertion_point(field_set:aiCommunicator.TXSlotAllocated.dst)
}

// uint32 timeslot = 2;
inline void TXSlotAllocated::clear_timeslot() {
  timeslot_ = 0u;
}
inline ::google::protobuf::uint32 TXSlotAllocated::timeslot() const {
  // @@protoc_insertion_point(field_get:aiCommunicator.TXSlotAllocated.timeslot)
  return timeslot_;
}
inline void TXSlotAllocated::set_timeslot(::google::protobuf::uint32 value) {
  
  timeslot_ = value;
  // @@protoc_insertion_point(field_set:aiCommunicator.TXSlotAllocated.timeslot)
}

// uint32 channel = 3;
inline void TXSlotAllocated::clear_channel() {
  channel_ = 0u;
}
inline ::google::protobuf::uint32 TXSlotAllocated::channel() const {
  // @@protoc_insertion_point(field_get:aiCommunicator.TXSlotAllocated.channel)
  return channel_;
}
inline void TXSlotAllocated::set_channel(::google::protobuf::uint32 value) {
  
  channel_ = value;
  // @@protoc_insertion_point(field_set:aiCommunicator.TXSlotAllocated.channel)
}

// -------------------------------------------------------------------

// TXSlotRemoved

// uint32 timeslot = 1;
inline void TXSlotRemoved::clear_timeslot() {
  timeslot_ = 0u;
}
inline ::google::protobuf::uint32 TXSlotRemoved::timeslot() const {
  // @@protoc_insertion_point(field_get:aiCommunicator.TXSlotRemoved.timeslot)
  return timeslot_;
}
inline void TXSlotRemoved::set_timeslot(::google::protobuf::uint32 value) {
  
  timeslot_ = value;
  // @@protoc_insertion_point(field_set:aiCommunicator.TXSlotRemoved.timeslot)
}

// uint32 channel = 2;
inline void TXSlotRemoved::clear_channel() {
  channel_ = 0u;
}
inline ::google::protobuf::uint32 TXSlotRemoved::channel() const {
  // @@protoc_insertion_point(field_get:aiCommunicator.TXSlotRemoved.channel)
  return channel_;
}
inline void TXSlotRemoved::set_channel(::google::protobuf::uint32 value) {
  
  channel_ = value;
  // @@protoc_insertion_point(field_set:aiCommunicator.TXSlotRemoved.channel)
}

// -------------------------------------------------------------------

// TXGainChanged

// uint64 dst = 1;
inline void TXGainChanged::clear_dst() {
  dst_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 TXGainChanged::dst() const {
  // @@protoc_insertion_point(field_get:aiCommunicator.TXGainChanged.dst)
  return dst_;
}
inline void TXGainChanged::set_dst(::google::protobuf::uint64 value) {
  
  dst_ = value;
  // @@protoc_insertion_point(field_set:aiCommunicator.TXGainChanged.dst)
}

// uint32 gain = 2;
inline void TXGainChanged::clear_gain() {
  gain_ = 0u;
}
inline ::google::protobuf::uint32 TXGainChanged::gain() const {
  // @@protoc_insertion_point(field_get:aiCommunicator.TXGainChanged.gain)
  return gain_;
}
inline void TXGainChanged::set_gain(::google::protobuf::uint32 value) {
  
  gain_ = value;
  // @@protoc_insertion_point(field_set:aiCommunicator.TXGainChanged.gain)
}

// -------------------------------------------------------------------

// NodePerformance

// repeated .aiCommunicator.FlowPerformance flows = 1;
inline int NodePerformance::flows_size() const {
  return flows_.size();
}
inline void NodePerformance::clear_flows() {
  flows_.Clear();
}
inline const ::aiCommunicator::FlowPerformance& NodePerformance::flows(int index) const {
  // @@protoc_insertion_point(field_get:aiCommunicator.NodePerformance.flows)
  return flows_.Get(index);
}
inline ::aiCommunicator::FlowPerformance* NodePerformance::mutable_flows(int index) {
  // @@protoc_insertion_point(field_mutable:aiCommunicator.NodePerformance.flows)
  return flows_.Mutable(index);
}
inline ::aiCommunicator::FlowPerformance* NodePerformance::add_flows() {
  // @@protoc_insertion_point(field_add:aiCommunicator.NodePerformance.flows)
  return flows_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aiCommunicator::FlowPerformance >*
NodePerformance::mutable_flows() {
  // @@protoc_insertion_point(field_mutable_list:aiCommunicator.NodePerformance.flows)
  return &flows_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aiCommunicator::FlowPerformance >&
NodePerformance::flows() const {
  // @@protoc_insertion_point(field_list:aiCommunicator.NodePerformance.flows)
  return flows_;
}

// -------------------------------------------------------------------

// FlowPerformance

// uint32 flow_id = 1;
inline void FlowPerformance::clear_flow_id() {
  flow_id_ = 0u;
}
inline ::google::protobuf::uint32 FlowPerformance::flow_id() const {
  // @@protoc_insertion_point(field_get:aiCommunicator.FlowPerformance.flow_id)
  return flow_id_;
}
inline void FlowPerformance::set_flow_id(::google::protobuf::uint32 value) {
  
  flow_id_ = value;
  // @@protoc_insertion_point(field_set:aiCommunicator.FlowPerformance.flow_id)
}

// uint32 bps = 2;
inline void FlowPerformance::clear_bps() {
  bps_ = 0u;
}
inline ::google::protobuf::uint32 FlowPerformance::bps() const {
  // @@protoc_insertion_point(field_get:aiCommunicator.FlowPerformance.bps)
  return bps_;
}
inline void FlowPerformance::set_bps(::google::protobuf::uint32 value) {
  
  bps_ = value;
  // @@protoc_insertion_point(field_set:aiCommunicator.FlowPerformance.bps)
}

// -------------------------------------------------------------------

// GatewayReport

// uint64 start_timestamp = 1;
inline void GatewayReport::clear_start_timestamp() {
  start_timestamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GatewayReport::start_timestamp() const {
  // @@protoc_insertion_point(field_get:aiCommunicator.GatewayReport.start_timestamp)
  return start_timestamp_;
}
inline void GatewayReport::set_start_timestamp(::google::protobuf::uint64 value) {
  
  start_timestamp_ = value;
  // @@protoc_insertion_point(field_set:aiCommunicator.GatewayReport.start_timestamp)
}

// uint64 end_timestamp = 2;
inline void GatewayReport::clear_end_timestamp() {
  end_timestamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GatewayReport::end_timestamp() const {
  // @@protoc_insertion_point(field_get:aiCommunicator.GatewayReport.end_timestamp)
  return end_timestamp_;
}
inline void GatewayReport::set_end_timestamp(::google::protobuf::uint64 value) {
  
  end_timestamp_ = value;
  // @@protoc_insertion_point(field_set:aiCommunicator.GatewayReport.end_timestamp)
}

// .aiCommunicator.Location location = 3;
inline bool GatewayReport::has_location() const {
  return this != internal_default_instance() && location_ != NULL;
}
inline void GatewayReport::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) delete location_;
  location_ = NULL;
}
inline const ::aiCommunicator::Location& GatewayReport::location() const {
  // @@protoc_insertion_point(field_get:aiCommunicator.GatewayReport.location)
  return location_ != NULL ? *location_
                         : *::aiCommunicator::Location::internal_default_instance();
}
inline ::aiCommunicator::Location* GatewayReport::mutable_location() {
  
  if (location_ == NULL) {
    location_ = new ::aiCommunicator::Location;
  }
  // @@protoc_insertion_point(field_mutable:aiCommunicator.GatewayReport.location)
  return location_;
}
inline ::aiCommunicator::Location* GatewayReport::release_location() {
  // @@protoc_insertion_point(field_release:aiCommunicator.GatewayReport.location)
  
  ::aiCommunicator::Location* temp = location_;
  location_ = NULL;
  return temp;
}
inline void GatewayReport::set_allocated_location(::aiCommunicator::Location* location) {
  delete location_;
  location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:aiCommunicator.GatewayReport.location)
}

// repeated .aiCommunicator.InternalVoxel slots = 4;
inline int GatewayReport::slots_size() const {
  return slots_.size();
}
inline void GatewayReport::clear_slots() {
  slots_.Clear();
}
inline const ::aiCommunicator::InternalVoxel& GatewayReport::slots(int index) const {
  // @@protoc_insertion_point(field_get:aiCommunicator.GatewayReport.slots)
  return slots_.Get(index);
}
inline ::aiCommunicator::InternalVoxel* GatewayReport::mutable_slots(int index) {
  // @@protoc_insertion_point(field_mutable:aiCommunicator.GatewayReport.slots)
  return slots_.Mutable(index);
}
inline ::aiCommunicator::InternalVoxel* GatewayReport::add_slots() {
  // @@protoc_insertion_point(field_add:aiCommunicator.GatewayReport.slots)
  return slots_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aiCommunicator::InternalVoxel >*
GatewayReport::mutable_slots() {
  // @@protoc_insertion_point(field_mutable_list:aiCommunicator.GatewayReport.slots)
  return &slots_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aiCommunicator::InternalVoxel >&
GatewayReport::slots() const {
  // @@protoc_insertion_point(field_list:aiCommunicator.GatewayReport.slots)
  return slots_;
}

// repeated .aiCommunicator.FlowPerformance flows = 5;
inline int GatewayReport::flows_size() const {
  return flows_.size();
}
inline void GatewayReport::clear_flows() {
  flows_.Clear();
}
inline const ::aiCommunicator::FlowPerformance& GatewayReport::flows(int index) const {
  // @@protoc_insertion_point(field_get:aiCommunicator.GatewayReport.flows)
  return flows_.Get(index);
}
inline ::aiCommunicator::FlowPerformance* GatewayReport::mutable_flows(int index) {
  // @@protoc_insertion_point(field_mutable:aiCommunicator.GatewayReport.flows)
  return flows_.Mutable(index);
}
inline ::aiCommunicator::FlowPerformance* GatewayReport::add_flows() {
  // @@protoc_insertion_point(field_add:aiCommunicator.GatewayReport.flows)
  return flows_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::aiCommunicator::FlowPerformance >*
GatewayReport::mutable_flows() {
  // @@protoc_insertion_point(field_mutable_list:aiCommunicator.GatewayReport.flows)
  return &flows_;
}
inline const ::google::protobuf::RepeatedPtrField< ::aiCommunicator::FlowPerformance >&
GatewayReport::flows() const {
  // @@protoc_insertion_point(field_list:aiCommunicator.GatewayReport.flows)
  return flows_;
}

// -------------------------------------------------------------------

// InternalAI

// uint64 statementID = 1;
inline void InternalAI::clear_statementid() {
  statementid_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 InternalAI::statementid() const {
  // @@protoc_insertion_point(field_get:aiCommunicator.InternalAI.statementID)
  return statementid_;
}
inline void InternalAI::set_statementid(::google::protobuf::uint64 value) {
  
  statementid_ = value;
  // @@protoc_insertion_point(field_set:aiCommunicator.InternalAI.statementID)
}

// uint64 mac_address = 2;
inline void InternalAI::clear_mac_address() {
  mac_address_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 InternalAI::mac_address() const {
  // @@protoc_insertion_point(field_get:aiCommunicator.InternalAI.mac_address)
  return mac_address_;
}
inline void InternalAI::set_mac_address(::google::protobuf::uint64 value) {
  
  mac_address_ = value;
  // @@protoc_insertion_point(field_set:aiCommunicator.InternalAI.mac_address)
}

// int32 nodeIndex = 3;
inline void InternalAI::clear_nodeindex() {
  nodeindex_ = 0;
}
inline ::google::protobuf::int32 InternalAI::nodeindex() const {
  // @@protoc_insertion_point(field_get:aiCommunicator.InternalAI.nodeIndex)
  return nodeindex_;
}
inline void InternalAI::set_nodeindex(::google::protobuf::int32 value) {
  
  nodeindex_ = value;
  // @@protoc_insertion_point(field_set:aiCommunicator.InternalAI.nodeIndex)
}

// .aiCommunicator.GatewayReport gw_report = 101;
inline bool InternalAI::has_gw_report() const {
  return payload_case() == kGwReport;
}
inline void InternalAI::set_has_gw_report() {
  _oneof_case_[0] = kGwReport;
}
inline void InternalAI::clear_gw_report() {
  if (has_gw_report()) {
    delete payload_.gw_report_;
    clear_has_payload();
  }
}
inline  const ::aiCommunicator::GatewayReport& InternalAI::gw_report() const {
  // @@protoc_insertion_point(field_get:aiCommunicator.InternalAI.gw_report)
  return has_gw_report()
      ? *payload_.gw_report_
      : ::aiCommunicator::GatewayReport::default_instance();
}
inline ::aiCommunicator::GatewayReport* InternalAI::mutable_gw_report() {
  if (!has_gw_report()) {
    clear_payload();
    set_has_gw_report();
    payload_.gw_report_ = new ::aiCommunicator::GatewayReport;
  }
  // @@protoc_insertion_point(field_mutable:aiCommunicator.InternalAI.gw_report)
  return payload_.gw_report_;
}
inline ::aiCommunicator::GatewayReport* InternalAI::release_gw_report() {
  // @@protoc_insertion_point(field_release:aiCommunicator.InternalAI.gw_report)
  if (has_gw_report()) {
    clear_has_payload();
    ::aiCommunicator::GatewayReport* temp = payload_.gw_report_;
    payload_.gw_report_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalAI::set_allocated_gw_report(::aiCommunicator::GatewayReport* gw_report) {
  clear_payload();
  if (gw_report) {
    set_has_gw_report();
    payload_.gw_report_ = gw_report;
  }
  // @@protoc_insertion_point(field_set_allocated:aiCommunicator.InternalAI.gw_report)
}

// .aiCommunicator.TXSlotAllocated slot_alloc = 102;
inline bool InternalAI::has_slot_alloc() const {
  return payload_case() == kSlotAlloc;
}
inline void InternalAI::set_has_slot_alloc() {
  _oneof_case_[0] = kSlotAlloc;
}
inline void InternalAI::clear_slot_alloc() {
  if (has_slot_alloc()) {
    delete payload_.slot_alloc_;
    clear_has_payload();
  }
}
inline  const ::aiCommunicator::TXSlotAllocated& InternalAI::slot_alloc() const {
  // @@protoc_insertion_point(field_get:aiCommunicator.InternalAI.slot_alloc)
  return has_slot_alloc()
      ? *payload_.slot_alloc_
      : ::aiCommunicator::TXSlotAllocated::default_instance();
}
inline ::aiCommunicator::TXSlotAllocated* InternalAI::mutable_slot_alloc() {
  if (!has_slot_alloc()) {
    clear_payload();
    set_has_slot_alloc();
    payload_.slot_alloc_ = new ::aiCommunicator::TXSlotAllocated;
  }
  // @@protoc_insertion_point(field_mutable:aiCommunicator.InternalAI.slot_alloc)
  return payload_.slot_alloc_;
}
inline ::aiCommunicator::TXSlotAllocated* InternalAI::release_slot_alloc() {
  // @@protoc_insertion_point(field_release:aiCommunicator.InternalAI.slot_alloc)
  if (has_slot_alloc()) {
    clear_has_payload();
    ::aiCommunicator::TXSlotAllocated* temp = payload_.slot_alloc_;
    payload_.slot_alloc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalAI::set_allocated_slot_alloc(::aiCommunicator::TXSlotAllocated* slot_alloc) {
  clear_payload();
  if (slot_alloc) {
    set_has_slot_alloc();
    payload_.slot_alloc_ = slot_alloc;
  }
  // @@protoc_insertion_point(field_set_allocated:aiCommunicator.InternalAI.slot_alloc)
}

// .aiCommunicator.TXSlotRemoved slot_removed = 103;
inline bool InternalAI::has_slot_removed() const {
  return payload_case() == kSlotRemoved;
}
inline void InternalAI::set_has_slot_removed() {
  _oneof_case_[0] = kSlotRemoved;
}
inline void InternalAI::clear_slot_removed() {
  if (has_slot_removed()) {
    delete payload_.slot_removed_;
    clear_has_payload();
  }
}
inline  const ::aiCommunicator::TXSlotRemoved& InternalAI::slot_removed() const {
  // @@protoc_insertion_point(field_get:aiCommunicator.InternalAI.slot_removed)
  return has_slot_removed()
      ? *payload_.slot_removed_
      : ::aiCommunicator::TXSlotRemoved::default_instance();
}
inline ::aiCommunicator::TXSlotRemoved* InternalAI::mutable_slot_removed() {
  if (!has_slot_removed()) {
    clear_payload();
    set_has_slot_removed();
    payload_.slot_removed_ = new ::aiCommunicator::TXSlotRemoved;
  }
  // @@protoc_insertion_point(field_mutable:aiCommunicator.InternalAI.slot_removed)
  return payload_.slot_removed_;
}
inline ::aiCommunicator::TXSlotRemoved* InternalAI::release_slot_removed() {
  // @@protoc_insertion_point(field_release:aiCommunicator.InternalAI.slot_removed)
  if (has_slot_removed()) {
    clear_has_payload();
    ::aiCommunicator::TXSlotRemoved* temp = payload_.slot_removed_;
    payload_.slot_removed_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalAI::set_allocated_slot_removed(::aiCommunicator::TXSlotRemoved* slot_removed) {
  clear_payload();
  if (slot_removed) {
    set_has_slot_removed();
    payload_.slot_removed_ = slot_removed;
  }
  // @@protoc_insertion_point(field_set_allocated:aiCommunicator.InternalAI.slot_removed)
}

// .aiCommunicator.TXGainChanged gain_changed = 104;
inline bool InternalAI::has_gain_changed() const {
  return payload_case() == kGainChanged;
}
inline void InternalAI::set_has_gain_changed() {
  _oneof_case_[0] = kGainChanged;
}
inline void InternalAI::clear_gain_changed() {
  if (has_gain_changed()) {
    delete payload_.gain_changed_;
    clear_has_payload();
  }
}
inline  const ::aiCommunicator::TXGainChanged& InternalAI::gain_changed() const {
  // @@protoc_insertion_point(field_get:aiCommunicator.InternalAI.gain_changed)
  return has_gain_changed()
      ? *payload_.gain_changed_
      : ::aiCommunicator::TXGainChanged::default_instance();
}
inline ::aiCommunicator::TXGainChanged* InternalAI::mutable_gain_changed() {
  if (!has_gain_changed()) {
    clear_payload();
    set_has_gain_changed();
    payload_.gain_changed_ = new ::aiCommunicator::TXGainChanged;
  }
  // @@protoc_insertion_point(field_mutable:aiCommunicator.InternalAI.gain_changed)
  return payload_.gain_changed_;
}
inline ::aiCommunicator::TXGainChanged* InternalAI::release_gain_changed() {
  // @@protoc_insertion_point(field_release:aiCommunicator.InternalAI.gain_changed)
  if (has_gain_changed()) {
    clear_has_payload();
    ::aiCommunicator::TXGainChanged* temp = payload_.gain_changed_;
    payload_.gain_changed_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalAI::set_allocated_gain_changed(::aiCommunicator::TXGainChanged* gain_changed) {
  clear_payload();
  if (gain_changed) {
    set_has_gain_changed();
    payload_.gain_changed_ = gain_changed;
  }
  // @@protoc_insertion_point(field_set_allocated:aiCommunicator.InternalAI.gain_changed)
}

// .aiCommunicator.NodePerformance nodeperf = 105;
inline bool InternalAI::has_nodeperf() const {
  return payload_case() == kNodeperf;
}
inline void InternalAI::set_has_nodeperf() {
  _oneof_case_[0] = kNodeperf;
}
inline void InternalAI::clear_nodeperf() {
  if (has_nodeperf()) {
    delete payload_.nodeperf_;
    clear_has_payload();
  }
}
inline  const ::aiCommunicator::NodePerformance& InternalAI::nodeperf() const {
  // @@protoc_insertion_point(field_get:aiCommunicator.InternalAI.nodeperf)
  return has_nodeperf()
      ? *payload_.nodeperf_
      : ::aiCommunicator::NodePerformance::default_instance();
}
inline ::aiCommunicator::NodePerformance* InternalAI::mutable_nodeperf() {
  if (!has_nodeperf()) {
    clear_payload();
    set_has_nodeperf();
    payload_.nodeperf_ = new ::aiCommunicator::NodePerformance;
  }
  // @@protoc_insertion_point(field_mutable:aiCommunicator.InternalAI.nodeperf)
  return payload_.nodeperf_;
}
inline ::aiCommunicator::NodePerformance* InternalAI::release_nodeperf() {
  // @@protoc_insertion_point(field_release:aiCommunicator.InternalAI.nodeperf)
  if (has_nodeperf()) {
    clear_has_payload();
    ::aiCommunicator::NodePerformance* temp = payload_.nodeperf_;
    payload_.nodeperf_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalAI::set_allocated_nodeperf(::aiCommunicator::NodePerformance* nodeperf) {
  clear_payload();
  if (nodeperf) {
    set_has_nodeperf();
    payload_.nodeperf_ = nodeperf;
  }
  // @@protoc_insertion_point(field_set_allocated:aiCommunicator.InternalAI.nodeperf)
}

// .aiCommunicator.Query query = 202;
inline bool InternalAI::has_query() const {
  return payload_case() == kQuery;
}
inline void InternalAI::set_has_query() {
  _oneof_case_[0] = kQuery;
}
inline void InternalAI::clear_query() {
  if (has_query()) {
    payload_.query_ = 0;
    clear_has_payload();
  }
}
inline ::aiCommunicator::Query InternalAI::query() const {
  // @@protoc_insertion_point(field_get:aiCommunicator.InternalAI.query)
  if (has_query()) {
    return static_cast< ::aiCommunicator::Query >(payload_.query_);
  }
  return static_cast< ::aiCommunicator::Query >(0);
}
inline void InternalAI::set_query(::aiCommunicator::Query value) {
  if (!has_query()) {
    clear_payload();
    set_has_query();
  }
  payload_.query_ = value;
  // @@protoc_insertion_point(field_set:aiCommunicator.InternalAI.query)
}

inline bool InternalAI::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void InternalAI::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline InternalAI::PayloadCase InternalAI::payload_case() const {
  return InternalAI::PayloadCase(_oneof_case_[0]);
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace aiCommunicator

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::aiCommunicator::Query> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::aiCommunicator::Query>() {
  return ::aiCommunicator::Query_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_interAI_2eproto__INCLUDED
