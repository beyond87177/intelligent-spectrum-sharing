// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: interf.proto

#ifndef PROTOBUF_interf_2eproto__INCLUDED
#define PROTOBUF_interf_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "interAI.pb.h"
// @@protoc_insertion_point(includes)
namespace aiCommunicator {
class FlowPerformance;
class FlowPerformanceDefaultTypeInternal;
extern FlowPerformanceDefaultTypeInternal _FlowPerformance_default_instance_;
class GatewayReport;
class GatewayReportDefaultTypeInternal;
extern GatewayReportDefaultTypeInternal _GatewayReport_default_instance_;
class InternalAI;
class InternalAIDefaultTypeInternal;
extern InternalAIDefaultTypeInternal _InternalAI_default_instance_;
class InternalVoxel;
class InternalVoxelDefaultTypeInternal;
extern InternalVoxelDefaultTypeInternal _InternalVoxel_default_instance_;
class Location;
class LocationDefaultTypeInternal;
extern LocationDefaultTypeInternal _Location_default_instance_;
class NodePerformance;
class NodePerformanceDefaultTypeInternal;
extern NodePerformanceDefaultTypeInternal _NodePerformance_default_instance_;
class TXGainChanged;
class TXGainChangedDefaultTypeInternal;
extern TXGainChangedDefaultTypeInternal _TXGainChanged_default_instance_;
class TXSlotAllocated;
class TXSlotAllocatedDefaultTypeInternal;
extern TXSlotAllocatedDefaultTypeInternal _TXSlotAllocated_default_instance_;
class TXSlotRemoved;
class TXSlotRemovedDefaultTypeInternal;
extern TXSlotRemovedDefaultTypeInternal _TXSlotRemoved_default_instance_;
}  // namespace aiCommunicator
namespace communicator {
class Application_data;
class Application_dataDefaultTypeInternal;
extern Application_dataDefaultTypeInternal _Application_data_default_instance_;
class BC_Slots_Announcement;
class BC_Slots_AnnouncementDefaultTypeInternal;
extern BC_Slots_AnnouncementDefaultTypeInternal _BC_Slots_Announcement_default_instance_;
class Basic_ctrl;
class Basic_ctrlDefaultTypeInternal;
extern Basic_ctrlDefaultTypeInternal _Basic_ctrl_default_instance_;
class External_Slot_Allocation;
class External_Slot_AllocationDefaultTypeInternal;
extern External_Slot_AllocationDefaultTypeInternal _External_Slot_Allocation_default_instance_;
class External_Slot_Move;
class External_Slot_MoveDefaultTypeInternal;
extern External_Slot_MoveDefaultTypeInternal _External_Slot_Move_default_instance_;
class External_Slot_Removal;
class External_Slot_RemovalDefaultTypeInternal;
extern External_Slot_RemovalDefaultTypeInternal _External_Slot_Removal_default_instance_;
class Get;
class GetDefaultTypeInternal;
extern GetDefaultTypeInternal _Get_default_instance_;
class Get_r;
class Get_rDefaultTypeInternal;
extern Get_rDefaultTypeInternal _Get_r_default_instance_;
class Internal;
class InternalDefaultTypeInternal;
extern InternalDefaultTypeInternal _Internal_default_instance_;
class Link_MCS_TxGain_BW;
class Link_MCS_TxGain_BWDefaultTypeInternal;
extern Link_MCS_TxGain_BWDefaultTypeInternal _Link_MCS_TxGain_BW_default_instance_;
class MFTDMA_Slot;
class MFTDMA_SlotDefaultTypeInternal;
extern MFTDMA_SlotDefaultTypeInternal _MFTDMA_Slot_default_instance_;
class Mac_ack_stat;
class Mac_ack_statDefaultTypeInternal;
extern Mac_ack_statDefaultTypeInternal _Mac_ack_stat_default_instance_;
class Mac_queue_stat;
class Mac_queue_statDefaultTypeInternal;
extern Mac_queue_statDefaultTypeInternal _Mac_queue_stat_default_instance_;
class Mac_queue_stat_QueueInfEntry;
class Mac_queue_stat_QueueInfEntryDefaultTypeInternal;
extern Mac_queue_stat_QueueInfEntryDefaultTypeInternal _Mac_queue_stat_QueueInfEntry_default_instance_;
class Mac_rx_stat;
class Mac_rx_statDefaultTypeInternal;
extern Mac_rx_statDefaultTypeInternal _Mac_rx_stat_default_instance_;
class Mac_stat;
class Mac_statDefaultTypeInternal;
extern Mac_statDefaultTypeInternal _Mac_stat_default_instance_;
class Mac_stat_Cell_information;
class Mac_stat_Cell_informationDefaultTypeInternal;
extern Mac_stat_Cell_informationDefaultTypeInternal _Mac_stat_Cell_information_default_instance_;
class Mac_stat_Mac_send_stat;
class Mac_stat_Mac_send_statDefaultTypeInternal;
extern Mac_stat_Mac_send_statDefaultTypeInternal _Mac_stat_Mac_send_stat_default_instance_;
class Mac_tx_stat;
class Mac_tx_statDefaultTypeInternal;
extern Mac_tx_statDefaultTypeInternal _Mac_tx_stat_default_instance_;
class Phy_rx_stat;
class Phy_rx_statDefaultTypeInternal;
extern Phy_rx_statDefaultTypeInternal _Phy_rx_stat_default_instance_;
class Phy_sensing_stat;
class Phy_sensing_statDefaultTypeInternal;
extern Phy_sensing_statDefaultTypeInternal _Phy_sensing_stat_default_instance_;
class Phy_stat;
class Phy_statDefaultTypeInternal;
extern Phy_statDefaultTypeInternal _Phy_stat_default_instance_;
class Phy_tx_stat;
class Phy_tx_statDefaultTypeInternal;
extern Phy_tx_statDefaultTypeInternal _Phy_tx_stat_default_instance_;
class Proposed_Move_Slots;
class Proposed_Move_SlotsDefaultTypeInternal;
extern Proposed_Move_SlotsDefaultTypeInternal _Proposed_Move_Slots_default_instance_;
class Proposed_Slots;
class Proposed_SlotsDefaultTypeInternal;
extern Proposed_SlotsDefaultTypeInternal _Proposed_Slots_default_instance_;
class Proposed_Slots_Request;
class Proposed_Slots_RequestDefaultTypeInternal;
extern Proposed_Slots_RequestDefaultTypeInternal _Proposed_Slots_Request_default_instance_;
class RF_stat;
class RF_statDefaultTypeInternal;
extern RF_statDefaultTypeInternal _RF_stat_default_instance_;
class RF_timeslot_stat;
class RF_timeslot_statDefaultTypeInternal;
extern RF_timeslot_statDefaultTypeInternal _RF_timeslot_stat_default_instance_;
class Receive;
class ReceiveDefaultTypeInternal;
extern ReceiveDefaultTypeInternal _Receive_default_instance_;
class Receive_r;
class Receive_rDefaultTypeInternal;
extern Receive_rDefaultTypeInternal _Receive_r_default_instance_;
class Selected_Move_Slot;
class Selected_Move_SlotDefaultTypeInternal;
extern Selected_Move_SlotDefaultTypeInternal _Selected_Move_Slot_default_instance_;
class Selected_Slot;
class Selected_SlotDefaultTypeInternal;
extern Selected_SlotDefaultTypeInternal _Selected_Slot_default_instance_;
class Send;
class SendDefaultTypeInternal;
extern SendDefaultTypeInternal _Send_default_instance_;
class Send_r;
class Send_rDefaultTypeInternal;
extern Send_rDefaultTypeInternal _Send_r_default_instance_;
class Set;
class SetDefaultTypeInternal;
extern SetDefaultTypeInternal _Set_default_instance_;
class Set_r;
class Set_rDefaultTypeInternal;
extern Set_rDefaultTypeInternal _Set_r_default_instance_;
class Slot_Allocation;
class Slot_AllocationDefaultTypeInternal;
extern Slot_AllocationDefaultTypeInternal _Slot_Allocation_default_instance_;
class Slot_Move;
class Slot_MoveDefaultTypeInternal;
extern Slot_MoveDefaultTypeInternal _Slot_Move_default_instance_;
class Slot_Removal;
class Slot_RemovalDefaultTypeInternal;
extern Slot_RemovalDefaultTypeInternal _Slot_Removal_default_instance_;
class Stats;
class StatsDefaultTypeInternal;
extern StatsDefaultTypeInternal _Stats_default_instance_;
}  // namespace communicator

namespace communicator {

namespace protobuf_interf_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_interf_2eproto

enum Basic_ctrl_TRX {
  Basic_ctrl_TRX_TRX_UNKNOWN = 0,
  Basic_ctrl_TRX_RX = 1,
  Basic_ctrl_TRX_TX = 2,
  Basic_ctrl_TRX_Basic_ctrl_TRX_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Basic_ctrl_TRX_Basic_ctrl_TRX_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Basic_ctrl_TRX_IsValid(int value);
const Basic_ctrl_TRX Basic_ctrl_TRX_TRX_MIN = Basic_ctrl_TRX_TRX_UNKNOWN;
const Basic_ctrl_TRX Basic_ctrl_TRX_TRX_MAX = Basic_ctrl_TRX_TX;
const int Basic_ctrl_TRX_TRX_ARRAYSIZE = Basic_ctrl_TRX_TRX_MAX + 1;

const ::google::protobuf::EnumDescriptor* Basic_ctrl_TRX_descriptor();
inline const ::std::string& Basic_ctrl_TRX_Name(Basic_ctrl_TRX value) {
  return ::google::protobuf::internal::NameOfEnum(
    Basic_ctrl_TRX_descriptor(), value);
}
inline bool Basic_ctrl_TRX_Parse(
    const ::std::string& name, Basic_ctrl_TRX* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Basic_ctrl_TRX>(
    Basic_ctrl_TRX_descriptor(), name, value);
}
enum Mac_ack_stat_AckStatus {
  Mac_ack_stat_AckStatus_ACKSTATUS_UNKNOWN = 0,
  Mac_ack_stat_AckStatus_ACKSTATUS_SUCCESS = 1,
  Mac_ack_stat_AckStatus_ACKSTATUS_FAILED = 2,
  Mac_ack_stat_AckStatus_Mac_ack_stat_AckStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Mac_ack_stat_AckStatus_Mac_ack_stat_AckStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Mac_ack_stat_AckStatus_IsValid(int value);
const Mac_ack_stat_AckStatus Mac_ack_stat_AckStatus_AckStatus_MIN = Mac_ack_stat_AckStatus_ACKSTATUS_UNKNOWN;
const Mac_ack_stat_AckStatus Mac_ack_stat_AckStatus_AckStatus_MAX = Mac_ack_stat_AckStatus_ACKSTATUS_FAILED;
const int Mac_ack_stat_AckStatus_AckStatus_ARRAYSIZE = Mac_ack_stat_AckStatus_AckStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* Mac_ack_stat_AckStatus_descriptor();
inline const ::std::string& Mac_ack_stat_AckStatus_Name(Mac_ack_stat_AckStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    Mac_ack_stat_AckStatus_descriptor(), value);
}
inline bool Mac_ack_stat_AckStatus_Parse(
    const ::std::string& name, Mac_ack_stat_AckStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Mac_ack_stat_AckStatus>(
    Mac_ack_stat_AckStatus_descriptor(), name, value);
}
enum Application_data_PACKET_TYPE {
  Application_data_PACKET_TYPE_PACKET_TYPE_UNKNOWN = 0,
  Application_data_PACKET_TYPE_IPv4 = 2048,
  Application_data_PACKET_TYPE_ARP = 2054,
  Application_data_PACKET_TYPE_Application_data_PACKET_TYPE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Application_data_PACKET_TYPE_Application_data_PACKET_TYPE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Application_data_PACKET_TYPE_IsValid(int value);
const Application_data_PACKET_TYPE Application_data_PACKET_TYPE_PACKET_TYPE_MIN = Application_data_PACKET_TYPE_PACKET_TYPE_UNKNOWN;
const Application_data_PACKET_TYPE Application_data_PACKET_TYPE_PACKET_TYPE_MAX = Application_data_PACKET_TYPE_ARP;
const int Application_data_PACKET_TYPE_PACKET_TYPE_ARRAYSIZE = Application_data_PACKET_TYPE_PACKET_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* Application_data_PACKET_TYPE_descriptor();
inline const ::std::string& Application_data_PACKET_TYPE_Name(Application_data_PACKET_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    Application_data_PACKET_TYPE_descriptor(), value);
}
inline bool Application_data_PACKET_TYPE_Parse(
    const ::std::string& name, Application_data_PACKET_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Application_data_PACKET_TYPE>(
    Application_data_PACKET_TYPE_descriptor(), name, value);
}
enum Application_data_TRAFFIC_CLASS {
  Application_data_TRAFFIC_CLASS_TRAFFIC_CLASS_UNKOWN = 0,
  Application_data_TRAFFIC_CLASS_VoIP = 1,
  Application_data_TRAFFIC_CLASS_FTP = 2,
  Application_data_TRAFFIC_CLASS_HTTP = 3,
  Application_data_TRAFFIC_CLASS_AI = 14,
  Application_data_TRAFFIC_CLASS_CONTROL = 15,
  Application_data_TRAFFIC_CLASS_Application_data_TRAFFIC_CLASS_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Application_data_TRAFFIC_CLASS_Application_data_TRAFFIC_CLASS_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Application_data_TRAFFIC_CLASS_IsValid(int value);
const Application_data_TRAFFIC_CLASS Application_data_TRAFFIC_CLASS_TRAFFIC_CLASS_MIN = Application_data_TRAFFIC_CLASS_TRAFFIC_CLASS_UNKOWN;
const Application_data_TRAFFIC_CLASS Application_data_TRAFFIC_CLASS_TRAFFIC_CLASS_MAX = Application_data_TRAFFIC_CLASS_CONTROL;
const int Application_data_TRAFFIC_CLASS_TRAFFIC_CLASS_ARRAYSIZE = Application_data_TRAFFIC_CLASS_TRAFFIC_CLASS_MAX + 1;

const ::google::protobuf::EnumDescriptor* Application_data_TRAFFIC_CLASS_descriptor();
inline const ::std::string& Application_data_TRAFFIC_CLASS_Name(Application_data_TRAFFIC_CLASS value) {
  return ::google::protobuf::internal::NameOfEnum(
    Application_data_TRAFFIC_CLASS_descriptor(), value);
}
inline bool Application_data_TRAFFIC_CLASS_Parse(
    const ::std::string& name, Application_data_TRAFFIC_CLASS* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Application_data_TRAFFIC_CLASS>(
    Application_data_TRAFFIC_CLASS_descriptor(), name, value);
}
enum Get_GET_ATTRIBUTE {
  Get_GET_ATTRIBUTE_ATTRIBUTE_UNKNOWN = 0,
  Get_GET_ATTRIBUTE_PHY_BASIC_CONTROL = 257,
  Get_GET_ATTRIBUTE_MAC_STATS = 513,
  Get_GET_ATTRIBUTE_PROPOSED_SLOTS = 769,
  Get_GET_ATTRIBUTE_SELECTED_SLOT = 770,
  Get_GET_ATTRIBUTE_SELECTED_MOVE_SLOT = 771,
  Get_GET_ATTRIBUTE_Get_GET_ATTRIBUTE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Get_GET_ATTRIBUTE_Get_GET_ATTRIBUTE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Get_GET_ATTRIBUTE_IsValid(int value);
const Get_GET_ATTRIBUTE Get_GET_ATTRIBUTE_GET_ATTRIBUTE_MIN = Get_GET_ATTRIBUTE_ATTRIBUTE_UNKNOWN;
const Get_GET_ATTRIBUTE Get_GET_ATTRIBUTE_GET_ATTRIBUTE_MAX = Get_GET_ATTRIBUTE_SELECTED_MOVE_SLOT;
const int Get_GET_ATTRIBUTE_GET_ATTRIBUTE_ARRAYSIZE = Get_GET_ATTRIBUTE_GET_ATTRIBUTE_MAX + 1;

const ::google::protobuf::EnumDescriptor* Get_GET_ATTRIBUTE_descriptor();
inline const ::std::string& Get_GET_ATTRIBUTE_Name(Get_GET_ATTRIBUTE value) {
  return ::google::protobuf::internal::NameOfEnum(
    Get_GET_ATTRIBUTE_descriptor(), value);
}
inline bool Get_GET_ATTRIBUTE_Parse(
    const ::std::string& name, Get_GET_ATTRIBUTE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Get_GET_ATTRIBUTE>(
    Get_GET_ATTRIBUTE_descriptor(), name, value);
}
enum MODULE {
  MODULE_UNKNOWN = 0,
  MODULE_PHY = 1,
  MODULE_MAC = 2,
  MODULE_AI = 3,
  MODULE_RF_MON = 4,
  MODULE_APP = 5,
  MODULE_PHY_DEBUG_1 = 6,
  MODULE_PHY_DEBUG_2 = 7,
  MODULE_MAC_DEBUG_1 = 8,
  MODULE_MAC_DEBUG_2 = 9,
  MODULE_RADIO_API = 10,
  MODULE_NODE_COMM = 11,
  MODULE_GATEWAY_COMM = 12,
  MODULE_COLLAB_CLIENT = 13,
  MODULE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MODULE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MODULE_IsValid(int value);
const MODULE MODULE_MIN = MODULE_UNKNOWN;
const MODULE MODULE_MAX = MODULE_COLLAB_CLIENT;
const int MODULE_ARRAYSIZE = MODULE_MAX + 1;

const ::google::protobuf::EnumDescriptor* MODULE_descriptor();
inline const ::std::string& MODULE_Name(MODULE value) {
  return ::google::protobuf::internal::NameOfEnum(
    MODULE_descriptor(), value);
}
inline bool MODULE_Parse(
    const ::std::string& name, MODULE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MODULE>(
    MODULE_descriptor(), name, value);
}
enum TRANSACTION_RESULT {
  TRANSACTION_RESULT_UNKNOWN = 0,
  OK = 100,
  NOK = 101,
  TIMEOUT = 102,
  LBT_TIMEOUT = 103,
  TRANSACTION_RESULT_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TRANSACTION_RESULT_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TRANSACTION_RESULT_IsValid(int value);
const TRANSACTION_RESULT TRANSACTION_RESULT_MIN = TRANSACTION_RESULT_UNKNOWN;
const TRANSACTION_RESULT TRANSACTION_RESULT_MAX = LBT_TIMEOUT;
const int TRANSACTION_RESULT_ARRAYSIZE = TRANSACTION_RESULT_MAX + 1;

const ::google::protobuf::EnumDescriptor* TRANSACTION_RESULT_descriptor();
inline const ::std::string& TRANSACTION_RESULT_Name(TRANSACTION_RESULT value) {
  return ::google::protobuf::internal::NameOfEnum(
    TRANSACTION_RESULT_descriptor(), value);
}
inline bool TRANSACTION_RESULT_Parse(
    const ::std::string& name, TRANSACTION_RESULT* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TRANSACTION_RESULT>(
    TRANSACTION_RESULT_descriptor(), name, value);
}
enum BW_INDEX {
  BW_INDEX_UNKNOWN = 0,
  OneDotFour = 1,
  Three = 2,
  Five = 3,
  Ten = 4,
  Fifteen = 5,
  Twenty = 6,
  BW_INDEX_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  BW_INDEX_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool BW_INDEX_IsValid(int value);
const BW_INDEX BW_INDEX_MIN = BW_INDEX_UNKNOWN;
const BW_INDEX BW_INDEX_MAX = Twenty;
const int BW_INDEX_ARRAYSIZE = BW_INDEX_MAX + 1;

const ::google::protobuf::EnumDescriptor* BW_INDEX_descriptor();
inline const ::std::string& BW_INDEX_Name(BW_INDEX value) {
  return ::google::protobuf::internal::NameOfEnum(
    BW_INDEX_descriptor(), value);
}
inline bool BW_INDEX_Parse(
    const ::std::string& name, BW_INDEX* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BW_INDEX>(
    BW_INDEX_descriptor(), name, value);
}
enum SLOT_MODE {
  SLOT_MODE_UNKNOWN = 0,
  RX = 1,
  TX = 2,
  SLOT_MODE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SLOT_MODE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SLOT_MODE_IsValid(int value);
const SLOT_MODE SLOT_MODE_MIN = SLOT_MODE_UNKNOWN;
const SLOT_MODE SLOT_MODE_MAX = TX;
const int SLOT_MODE_ARRAYSIZE = SLOT_MODE_MAX + 1;

const ::google::protobuf::EnumDescriptor* SLOT_MODE_descriptor();
inline const ::std::string& SLOT_MODE_Name(SLOT_MODE value) {
  return ::google::protobuf::internal::NameOfEnum(
    SLOT_MODE_descriptor(), value);
}
inline bool SLOT_MODE_Parse(
    const ::std::string& name, SLOT_MODE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SLOT_MODE>(
    SLOT_MODE_descriptor(), name, value);
}
// ===================================================================

class Basic_ctrl : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:communicator.Basic_ctrl) */ {
 public:
  Basic_ctrl();
  virtual ~Basic_ctrl();

  Basic_ctrl(const Basic_ctrl& from);

  inline Basic_ctrl& operator=(const Basic_ctrl& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Basic_ctrl& default_instance();

  static inline const Basic_ctrl* internal_default_instance() {
    return reinterpret_cast<const Basic_ctrl*>(
               &_Basic_ctrl_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Basic_ctrl* other);

  // implements Message ----------------------------------------------

  inline Basic_ctrl* New() const PROTOBUF_FINAL { return New(NULL); }

  Basic_ctrl* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Basic_ctrl& from);
  void MergeFrom(const Basic_ctrl& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Basic_ctrl* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Basic_ctrl_TRX TRX;
  static const TRX TRX_UNKNOWN =
    Basic_ctrl_TRX_TRX_UNKNOWN;
  static const TRX RX =
    Basic_ctrl_TRX_RX;
  static const TRX TX =
    Basic_ctrl_TRX_TX;
  static inline bool TRX_IsValid(int value) {
    return Basic_ctrl_TRX_IsValid(value);
  }
  static const TRX TRX_MIN =
    Basic_ctrl_TRX_TRX_MIN;
  static const TRX TRX_MAX =
    Basic_ctrl_TRX_TRX_MAX;
  static const int TRX_ARRAYSIZE =
    Basic_ctrl_TRX_TRX_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TRX_descriptor() {
    return Basic_ctrl_TRX_descriptor();
  }
  static inline const ::std::string& TRX_Name(TRX value) {
    return Basic_ctrl_TRX_Name(value);
  }
  static inline bool TRX_Parse(const ::std::string& name,
      TRX* value) {
    return Basic_ctrl_TRX_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .communicator.Basic_ctrl.TRX trx_flag = 1;
  void clear_trx_flag();
  static const int kTrxFlagFieldNumber = 1;
  ::communicator::Basic_ctrl_TRX trx_flag() const;
  void set_trx_flag(::communicator::Basic_ctrl_TRX value);

  // uint32 send_to = 2;
  void clear_send_to();
  static const int kSendToFieldNumber = 2;
  ::google::protobuf::uint32 send_to() const;
  void set_send_to(::google::protobuf::uint32 value);

  // .communicator.BW_INDEX bw_index = 3;
  void clear_bw_index();
  static const int kBwIndexFieldNumber = 3;
  ::communicator::BW_INDEX bw_index() const;
  void set_bw_index(::communicator::BW_INDEX value);

  // uint32 ch = 4;
  void clear_ch();
  static const int kChFieldNumber = 4;
  ::google::protobuf::uint32 ch() const;
  void set_ch(::google::protobuf::uint32 value);

  // uint32 frame = 5;
  void clear_frame();
  static const int kFrameFieldNumber = 5;
  ::google::protobuf::uint32 frame() const;
  void set_frame(::google::protobuf::uint32 value);

  // uint32 slot = 6;
  void clear_slot();
  static const int kSlotFieldNumber = 6;
  ::google::protobuf::uint32 slot() const;
  void set_slot(::google::protobuf::uint32 value);

  // uint64 timestamp = 7;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 7;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // uint32 mcs = 8;
  void clear_mcs();
  static const int kMcsFieldNumber = 8;
  ::google::protobuf::uint32 mcs() const;
  void set_mcs(::google::protobuf::uint32 value);

  // int32 gain = 9;
  void clear_gain();
  static const int kGainFieldNumber = 9;
  ::google::protobuf::int32 gain() const;
  void set_gain(::google::protobuf::int32 value);

  // float rf_boost = 10;
  void clear_rf_boost();
  static const int kRfBoostFieldNumber = 10;
  float rf_boost() const;
  void set_rf_boost(float value);

  // uint32 length = 11;
  void clear_length();
  static const int kLengthFieldNumber = 11;
  ::google::protobuf::uint32 length() const;
  void set_length(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:communicator.Basic_ctrl)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int trx_flag_;
  ::google::protobuf::uint32 send_to_;
  int bw_index_;
  ::google::protobuf::uint32 ch_;
  ::google::protobuf::uint32 frame_;
  ::google::protobuf::uint32 slot_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::uint32 mcs_;
  ::google::protobuf::int32 gain_;
  float rf_boost_;
  ::google::protobuf::uint32 length_;
  mutable int _cached_size_;
  friend struct protobuf_interf_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Phy_tx_stat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:communicator.Phy_tx_stat) */ {
 public:
  Phy_tx_stat();
  virtual ~Phy_tx_stat();

  Phy_tx_stat(const Phy_tx_stat& from);

  inline Phy_tx_stat& operator=(const Phy_tx_stat& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Phy_tx_stat& default_instance();

  static inline const Phy_tx_stat* internal_default_instance() {
    return reinterpret_cast<const Phy_tx_stat*>(
               &_Phy_tx_stat_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Phy_tx_stat* other);

  // implements Message ----------------------------------------------

  inline Phy_tx_stat* New() const PROTOBUF_FINAL { return New(NULL); }

  Phy_tx_stat* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Phy_tx_stat& from);
  void MergeFrom(const Phy_tx_stat& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Phy_tx_stat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 channel_free_cnt = 2;
  void clear_channel_free_cnt();
  static const int kChannelFreeCntFieldNumber = 2;
  ::google::protobuf::uint64 channel_free_cnt() const;
  void set_channel_free_cnt(::google::protobuf::uint64 value);

  // int32 power = 1;
  void clear_power();
  static const int kPowerFieldNumber = 1;
  ::google::protobuf::int32 power() const;
  void set_power(::google::protobuf::int32 value);

  // float free_energy = 4;
  void clear_free_energy();
  static const int kFreeEnergyFieldNumber = 4;
  float free_energy() const;
  void set_free_energy(float value);

  // uint64 channel_busy_cnt = 3;
  void clear_channel_busy_cnt();
  static const int kChannelBusyCntFieldNumber = 3;
  ::google::protobuf::uint64 channel_busy_cnt() const;
  void set_channel_busy_cnt(::google::protobuf::uint64 value);

  // uint64 total_dropped_slots = 6;
  void clear_total_dropped_slots();
  static const int kTotalDroppedSlotsFieldNumber = 6;
  ::google::protobuf::uint64 total_dropped_slots() const;
  void set_total_dropped_slots(::google::protobuf::uint64 value);

  // float busy_energy = 5;
  void clear_busy_energy();
  static const int kBusyEnergyFieldNumber = 5;
  float busy_energy() const;
  void set_busy_energy(float value);

  // float coding_time = 7;
  void clear_coding_time();
  static const int kCodingTimeFieldNumber = 7;
  float coding_time() const;
  void set_coding_time(float value);

  // float rf_boost = 8;
  void clear_rf_boost();
  static const int kRfBoostFieldNumber = 8;
  float rf_boost() const;
  void set_rf_boost(float value);

  // @@protoc_insertion_point(class_scope:communicator.Phy_tx_stat)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 channel_free_cnt_;
  ::google::protobuf::int32 power_;
  float free_energy_;
  ::google::protobuf::uint64 channel_busy_cnt_;
  ::google::protobuf::uint64 total_dropped_slots_;
  float busy_energy_;
  float coding_time_;
  float rf_boost_;
  mutable int _cached_size_;
  friend struct protobuf_interf_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Phy_rx_stat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:communicator.Phy_rx_stat) */ {
 public:
  Phy_rx_stat();
  virtual ~Phy_rx_stat();

  Phy_rx_stat(const Phy_rx_stat& from);

  inline Phy_rx_stat& operator=(const Phy_rx_stat& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Phy_rx_stat& default_instance();

  static inline const Phy_rx_stat* internal_default_instance() {
    return reinterpret_cast<const Phy_rx_stat*>(
               &_Phy_rx_stat_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Phy_rx_stat* other);

  // implements Message ----------------------------------------------

  inline Phy_rx_stat* New() const PROTOBUF_FINAL { return New(NULL); }

  Phy_rx_stat* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Phy_rx_stat& from);
  void MergeFrom(const Phy_rx_stat& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Phy_rx_stat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 gain = 1;
  void clear_gain();
  static const int kGainFieldNumber = 1;
  ::google::protobuf::int32 gain() const;
  void set_gain(::google::protobuf::int32 value);

  // uint32 cqi = 2;
  void clear_cqi();
  static const int kCqiFieldNumber = 2;
  ::google::protobuf::uint32 cqi() const;
  void set_cqi(::google::protobuf::uint32 value);

  // float rssi = 3;
  void clear_rssi();
  static const int kRssiFieldNumber = 3;
  float rssi() const;
  void set_rssi(float value);

  // float rsrp = 4;
  void clear_rsrp();
  static const int kRsrpFieldNumber = 4;
  float rsrp() const;
  void set_rsrp(float value);

  // float rsrq = 5;
  void clear_rsrq();
  static const int kRsrqFieldNumber = 5;
  float rsrq() const;
  void set_rsrq(float value);

  // float sinr = 6;
  void clear_sinr();
  static const int kSinrFieldNumber = 6;
  float sinr() const;
  void set_sinr(float value);

  // uint64 detection_errors = 7;
  void clear_detection_errors();
  static const int kDetectionErrorsFieldNumber = 7;
  ::google::protobuf::uint64 detection_errors() const;
  void set_detection_errors(::google::protobuf::uint64 value);

  // uint64 decoding_errors = 8;
  void clear_decoding_errors();
  static const int kDecodingErrorsFieldNumber = 8;
  ::google::protobuf::uint64 decoding_errors() const;
  void set_decoding_errors(::google::protobuf::uint64 value);

  // uint64 filler_bits_error = 9;
  void clear_filler_bits_error();
  static const int kFillerBitsErrorFieldNumber = 9;
  ::google::protobuf::uint64 filler_bits_error() const;
  void set_filler_bits_error(::google::protobuf::uint64 value);

  // uint64 nof_cbs_exceeds_softbuffer_size_error = 10;
  void clear_nof_cbs_exceeds_softbuffer_size_error();
  static const int kNofCbsExceedsSoftbufferSizeErrorFieldNumber = 10;
  ::google::protobuf::uint64 nof_cbs_exceeds_softbuffer_size_error() const;
  void set_nof_cbs_exceeds_softbuffer_size_error(::google::protobuf::uint64 value);

  // uint64 rate_matching_error = 11;
  void clear_rate_matching_error();
  static const int kRateMatchingErrorFieldNumber = 11;
  ::google::protobuf::uint64 rate_matching_error() const;
  void set_rate_matching_error(::google::protobuf::uint64 value);

  // uint64 cb_crc_error = 12;
  void clear_cb_crc_error();
  static const int kCbCrcErrorFieldNumber = 12;
  ::google::protobuf::uint64 cb_crc_error() const;
  void set_cb_crc_error(::google::protobuf::uint64 value);

  // uint64 tb_crc_error = 13;
  void clear_tb_crc_error();
  static const int kTbCrcErrorFieldNumber = 13;
  ::google::protobuf::uint64 tb_crc_error() const;
  void set_tb_crc_error(::google::protobuf::uint64 value);

  // float peak_value = 14;
  void clear_peak_value();
  static const int kPeakValueFieldNumber = 14;
  float peak_value() const;
  void set_peak_value(float value);

  // float noise = 15;
  void clear_noise();
  static const int kNoiseFieldNumber = 15;
  float noise() const;
  void set_noise(float value);

  // uint32 decoded_cfi = 16;
  void clear_decoded_cfi();
  static const int kDecodedCfiFieldNumber = 16;
  ::google::protobuf::uint32 decoded_cfi() const;
  void set_decoded_cfi(::google::protobuf::uint32 value);

  // bool found_dci = 17;
  void clear_found_dci();
  static const int kFoundDciFieldNumber = 17;
  bool found_dci() const;
  void set_found_dci(bool value);

  // uint64 total_packets_synchronized = 19;
  void clear_total_packets_synchronized();
  static const int kTotalPacketsSynchronizedFieldNumber = 19;
  ::google::protobuf::uint64 total_packets_synchronized() const;
  void set_total_packets_synchronized(::google::protobuf::uint64 value);

  // uint32 last_noi = 18;
  void clear_last_noi();
  static const int kLastNoiFieldNumber = 18;
  ::google::protobuf::uint32 last_noi() const;
  void set_last_noi(::google::protobuf::uint32 value);

  // int32 length = 20;
  void clear_length();
  static const int kLengthFieldNumber = 20;
  ::google::protobuf::int32 length() const;
  void set_length(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:communicator.Phy_rx_stat)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 gain_;
  ::google::protobuf::uint32 cqi_;
  float rssi_;
  float rsrp_;
  float rsrq_;
  float sinr_;
  ::google::protobuf::uint64 detection_errors_;
  ::google::protobuf::uint64 decoding_errors_;
  ::google::protobuf::uint64 filler_bits_error_;
  ::google::protobuf::uint64 nof_cbs_exceeds_softbuffer_size_error_;
  ::google::protobuf::uint64 rate_matching_error_;
  ::google::protobuf::uint64 cb_crc_error_;
  ::google::protobuf::uint64 tb_crc_error_;
  float peak_value_;
  float noise_;
  ::google::protobuf::uint32 decoded_cfi_;
  bool found_dci_;
  ::google::protobuf::uint64 total_packets_synchronized_;
  ::google::protobuf::uint32 last_noi_;
  ::google::protobuf::int32 length_;
  mutable int _cached_size_;
  friend struct protobuf_interf_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Phy_sensing_stat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:communicator.Phy_sensing_stat) */ {
 public:
  Phy_sensing_stat();
  virtual ~Phy_sensing_stat();

  Phy_sensing_stat(const Phy_sensing_stat& from);

  inline Phy_sensing_stat& operator=(const Phy_sensing_stat& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Phy_sensing_stat& default_instance();

  static inline const Phy_sensing_stat* internal_default_instance() {
    return reinterpret_cast<const Phy_sensing_stat*>(
               &_Phy_sensing_stat_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Phy_sensing_stat* other);

  // implements Message ----------------------------------------------

  inline Phy_sensing_stat* New() const PROTOBUF_FINAL { return New(NULL); }

  Phy_sensing_stat* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Phy_sensing_stat& from);
  void MergeFrom(const Phy_sensing_stat& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Phy_sensing_stat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float frequency = 1;
  void clear_frequency();
  static const int kFrequencyFieldNumber = 1;
  float frequency() const;
  void set_frequency(float value);

  // float sample_rate = 2;
  void clear_sample_rate();
  static const int kSampleRateFieldNumber = 2;
  float sample_rate() const;
  void set_sample_rate(float value);

  // float gain = 3;
  void clear_gain();
  static const int kGainFieldNumber = 3;
  float gain() const;
  void set_gain(float value);

  // float rssi = 4;
  void clear_rssi();
  static const int kRssiFieldNumber = 4;
  float rssi() const;
  void set_rssi(float value);

  // int32 length = 5;
  void clear_length();
  static const int kLengthFieldNumber = 5;
  ::google::protobuf::int32 length() const;
  void set_length(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:communicator.Phy_sensing_stat)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float frequency_;
  float sample_rate_;
  float gain_;
  float rssi_;
  ::google::protobuf::int32 length_;
  mutable int _cached_size_;
  friend struct protobuf_interf_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Phy_stat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:communicator.Phy_stat) */ {
 public:
  Phy_stat();
  virtual ~Phy_stat();

  Phy_stat(const Phy_stat& from);

  inline Phy_stat& operator=(const Phy_stat& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Phy_stat& default_instance();

  enum StatCase {
    kTxStat = 10,
    kRxStat = 11,
    kSensingStat = 12,
    STAT_NOT_SET = 0,
  };

  static inline const Phy_stat* internal_default_instance() {
    return reinterpret_cast<const Phy_stat*>(
               &_Phy_stat_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Phy_stat* other);

  // implements Message ----------------------------------------------

  inline Phy_stat* New() const PROTOBUF_FINAL { return New(NULL); }

  Phy_stat* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Phy_stat& from);
  void MergeFrom(const Phy_stat& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Phy_stat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 host_timestamp = 1;
  void clear_host_timestamp();
  static const int kHostTimestampFieldNumber = 1;
  ::google::protobuf::uint64 host_timestamp() const;
  void set_host_timestamp(::google::protobuf::uint64 value);

  // uint64 fpga_timestamp = 2;
  void clear_fpga_timestamp();
  static const int kFpgaTimestampFieldNumber = 2;
  ::google::protobuf::uint64 fpga_timestamp() const;
  void set_fpga_timestamp(::google::protobuf::uint64 value);

  // uint32 frame = 3;
  void clear_frame();
  static const int kFrameFieldNumber = 3;
  ::google::protobuf::uint32 frame() const;
  void set_frame(::google::protobuf::uint32 value);

  // uint32 slot = 4;
  void clear_slot();
  static const int kSlotFieldNumber = 4;
  ::google::protobuf::uint32 slot() const;
  void set_slot(::google::protobuf::uint32 value);

  // uint32 ch = 5;
  void clear_ch();
  static const int kChFieldNumber = 5;
  ::google::protobuf::uint32 ch() const;
  void set_ch(::google::protobuf::uint32 value);

  // uint32 mcs = 6;
  void clear_mcs();
  static const int kMcsFieldNumber = 6;
  ::google::protobuf::uint32 mcs() const;
  void set_mcs(::google::protobuf::uint32 value);

  // uint32 num_cb_total = 7;
  void clear_num_cb_total();
  static const int kNumCbTotalFieldNumber = 7;
  ::google::protobuf::uint32 num_cb_total() const;
  void set_num_cb_total(::google::protobuf::uint32 value);

  // uint32 num_cb_err = 8;
  void clear_num_cb_err();
  static const int kNumCbErrFieldNumber = 8;
  ::google::protobuf::uint32 num_cb_err() const;
  void set_num_cb_err(::google::protobuf::uint32 value);

  // uint32 wrong_decoding_counter = 9;
  void clear_wrong_decoding_counter();
  static const int kWrongDecodingCounterFieldNumber = 9;
  ::google::protobuf::uint32 wrong_decoding_counter() const;
  void set_wrong_decoding_counter(::google::protobuf::uint32 value);

  // .communicator.Phy_tx_stat tx_stat = 10;
  bool has_tx_stat() const;
  void clear_tx_stat();
  static const int kTxStatFieldNumber = 10;
  const ::communicator::Phy_tx_stat& tx_stat() const;
  ::communicator::Phy_tx_stat* mutable_tx_stat();
  ::communicator::Phy_tx_stat* release_tx_stat();
  void set_allocated_tx_stat(::communicator::Phy_tx_stat* tx_stat);

  // .communicator.Phy_rx_stat rx_stat = 11;
  bool has_rx_stat() const;
  void clear_rx_stat();
  static const int kRxStatFieldNumber = 11;
  const ::communicator::Phy_rx_stat& rx_stat() const;
  ::communicator::Phy_rx_stat* mutable_rx_stat();
  ::communicator::Phy_rx_stat* release_rx_stat();
  void set_allocated_rx_stat(::communicator::Phy_rx_stat* rx_stat);

  // .communicator.Phy_sensing_stat sensing_stat = 12;
  bool has_sensing_stat() const;
  void clear_sensing_stat();
  static const int kSensingStatFieldNumber = 12;
  const ::communicator::Phy_sensing_stat& sensing_stat() const;
  ::communicator::Phy_sensing_stat* mutable_sensing_stat();
  ::communicator::Phy_sensing_stat* release_sensing_stat();
  void set_allocated_sensing_stat(::communicator::Phy_sensing_stat* sensing_stat);

  StatCase stat_case() const;
  // @@protoc_insertion_point(class_scope:communicator.Phy_stat)
 private:
  void set_has_tx_stat();
  void set_has_rx_stat();
  void set_has_sensing_stat();

  inline bool has_stat() const;
  void clear_stat();
  inline void clear_has_stat();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 host_timestamp_;
  ::google::protobuf::uint64 fpga_timestamp_;
  ::google::protobuf::uint32 frame_;
  ::google::protobuf::uint32 slot_;
  ::google::protobuf::uint32 ch_;
  ::google::protobuf::uint32 mcs_;
  ::google::protobuf::uint32 num_cb_total_;
  ::google::protobuf::uint32 num_cb_err_;
  ::google::protobuf::uint32 wrong_decoding_counter_;
  union StatUnion {
    StatUnion() {}
    ::communicator::Phy_tx_stat* tx_stat_;
    ::communicator::Phy_rx_stat* rx_stat_;
    ::communicator::Phy_sensing_stat* sensing_stat_;
  } stat_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_interf_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Mac_ack_stat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:communicator.Mac_ack_stat) */ {
 public:
  Mac_ack_stat();
  virtual ~Mac_ack_stat();

  Mac_ack_stat(const Mac_ack_stat& from);

  inline Mac_ack_stat& operator=(const Mac_ack_stat& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Mac_ack_stat& default_instance();

  static inline const Mac_ack_stat* internal_default_instance() {
    return reinterpret_cast<const Mac_ack_stat*>(
               &_Mac_ack_stat_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Mac_ack_stat* other);

  // implements Message ----------------------------------------------

  inline Mac_ack_stat* New() const PROTOBUF_FINAL { return New(NULL); }

  Mac_ack_stat* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Mac_ack_stat& from);
  void MergeFrom(const Mac_ack_stat& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Mac_ack_stat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Mac_ack_stat_AckStatus AckStatus;
  static const AckStatus ACKSTATUS_UNKNOWN =
    Mac_ack_stat_AckStatus_ACKSTATUS_UNKNOWN;
  static const AckStatus ACKSTATUS_SUCCESS =
    Mac_ack_stat_AckStatus_ACKSTATUS_SUCCESS;
  static const AckStatus ACKSTATUS_FAILED =
    Mac_ack_stat_AckStatus_ACKSTATUS_FAILED;
  static inline bool AckStatus_IsValid(int value) {
    return Mac_ack_stat_AckStatus_IsValid(value);
  }
  static const AckStatus AckStatus_MIN =
    Mac_ack_stat_AckStatus_AckStatus_MIN;
  static const AckStatus AckStatus_MAX =
    Mac_ack_stat_AckStatus_AckStatus_MAX;
  static const int AckStatus_ARRAYSIZE =
    Mac_ack_stat_AckStatus_AckStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  AckStatus_descriptor() {
    return Mac_ack_stat_AckStatus_descriptor();
  }
  static inline const ::std::string& AckStatus_Name(AckStatus value) {
    return Mac_ack_stat_AckStatus_Name(value);
  }
  static inline bool AckStatus_Parse(const ::std::string& name,
      AckStatus* value) {
    return Mac_ack_stat_AckStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .communicator.Phy_rx_stat receiver_stats = 12;
  bool has_receiver_stats() const;
  void clear_receiver_stats();
  static const int kReceiverStatsFieldNumber = 12;
  const ::communicator::Phy_rx_stat& receiver_stats() const;
  ::communicator::Phy_rx_stat* mutable_receiver_stats();
  ::communicator::Phy_rx_stat* release_receiver_stats();
  void set_allocated_receiver_stats(::communicator::Phy_rx_stat* receiver_stats);

  // uint64 destination_address = 1;
  void clear_destination_address();
  static const int kDestinationAddressFieldNumber = 1;
  ::google::protobuf::uint64 destination_address() const;
  void set_destination_address(::google::protobuf::uint64 value);

  // .communicator.Mac_ack_stat.AckStatus status = 2;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  ::communicator::Mac_ack_stat_AckStatus status() const;
  void set_status(::communicator::Mac_ack_stat_AckStatus value);

  // uint32 mcs = 3;
  void clear_mcs();
  static const int kMcsFieldNumber = 3;
  ::google::protobuf::uint32 mcs() const;
  void set_mcs(::google::protobuf::uint32 value);

  // uint32 tx_gain = 4;
  void clear_tx_gain();
  static const int kTxGainFieldNumber = 4;
  ::google::protobuf::uint32 tx_gain() const;
  void set_tx_gain(::google::protobuf::uint32 value);

  // uint32 port = 5;
  void clear_port();
  static const int kPortFieldNumber = 5;
  ::google::protobuf::uint32 port() const;
  void set_port(::google::protobuf::uint32 value);

  // uint32 payload_size = 6;
  void clear_payload_size();
  static const int kPayloadSizeFieldNumber = 6;
  ::google::protobuf::uint32 payload_size() const;
  void set_payload_size(::google::protobuf::uint32 value);

  // uint32 tx_channel = 7;
  void clear_tx_channel();
  static const int kTxChannelFieldNumber = 7;
  ::google::protobuf::uint32 tx_channel() const;
  void set_tx_channel(::google::protobuf::uint32 value);

  // uint32 slot_index = 8;
  void clear_slot_index();
  static const int kSlotIndexFieldNumber = 8;
  ::google::protobuf::uint32 slot_index() const;
  void set_slot_index(::google::protobuf::uint32 value);

  // uint32 max_retries = 9;
  void clear_max_retries();
  static const int kMaxRetriesFieldNumber = 9;
  ::google::protobuf::uint32 max_retries() const;
  void set_max_retries(::google::protobuf::uint32 value);

  // uint64 bytes_transmitted = 11;
  void clear_bytes_transmitted();
  static const int kBytesTransmittedFieldNumber = 11;
  ::google::protobuf::uint64 bytes_transmitted() const;
  void set_bytes_transmitted(::google::protobuf::uint64 value);

  // uint32 num_retries = 10;
  void clear_num_retries();
  static const int kNumRetriesFieldNumber = 10;
  ::google::protobuf::uint32 num_retries() const;
  void set_num_retries(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:communicator.Mac_ack_stat)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::communicator::Phy_rx_stat* receiver_stats_;
  ::google::protobuf::uint64 destination_address_;
  int status_;
  ::google::protobuf::uint32 mcs_;
  ::google::protobuf::uint32 tx_gain_;
  ::google::protobuf::uint32 port_;
  ::google::protobuf::uint32 payload_size_;
  ::google::protobuf::uint32 tx_channel_;
  ::google::protobuf::uint32 slot_index_;
  ::google::protobuf::uint32 max_retries_;
  ::google::protobuf::uint64 bytes_transmitted_;
  ::google::protobuf::uint32 num_retries_;
  mutable int _cached_size_;
  friend struct protobuf_interf_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Mac_tx_stat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:communicator.Mac_tx_stat) */ {
 public:
  Mac_tx_stat();
  virtual ~Mac_tx_stat();

  Mac_tx_stat(const Mac_tx_stat& from);

  inline Mac_tx_stat& operator=(const Mac_tx_stat& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Mac_tx_stat& default_instance();

  static inline const Mac_tx_stat* internal_default_instance() {
    return reinterpret_cast<const Mac_tx_stat*>(
               &_Mac_tx_stat_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Mac_tx_stat* other);

  // implements Message ----------------------------------------------

  inline Mac_tx_stat* New() const PROTOBUF_FINAL { return New(NULL); }

  Mac_tx_stat* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Mac_tx_stat& from);
  void MergeFrom(const Mac_tx_stat& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Mac_tx_stat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .communicator.Mac_ack_stat ack_stat = 1;
  int ack_stat_size() const;
  void clear_ack_stat();
  static const int kAckStatFieldNumber = 1;
  const ::communicator::Mac_ack_stat& ack_stat(int index) const;
  ::communicator::Mac_ack_stat* mutable_ack_stat(int index);
  ::communicator::Mac_ack_stat* add_ack_stat();
  ::google::protobuf::RepeatedPtrField< ::communicator::Mac_ack_stat >*
      mutable_ack_stat();
  const ::google::protobuf::RepeatedPtrField< ::communicator::Mac_ack_stat >&
      ack_stat() const;

  // @@protoc_insertion_point(class_scope:communicator.Mac_tx_stat)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::communicator::Mac_ack_stat > ack_stat_;
  mutable int _cached_size_;
  friend struct protobuf_interf_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Mac_rx_stat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:communicator.Mac_rx_stat) */ {
 public:
  Mac_rx_stat();
  virtual ~Mac_rx_stat();

  Mac_rx_stat(const Mac_rx_stat& from);

  inline Mac_rx_stat& operator=(const Mac_rx_stat& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Mac_rx_stat& default_instance();

  static inline const Mac_rx_stat* internal_default_instance() {
    return reinterpret_cast<const Mac_rx_stat*>(
               &_Mac_rx_stat_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Mac_rx_stat* other);

  // implements Message ----------------------------------------------

  inline Mac_rx_stat* New() const PROTOBUF_FINAL { return New(NULL); }

  Mac_rx_stat* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Mac_rx_stat& from);
  void MergeFrom(const Mac_rx_stat& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Mac_rx_stat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 num_byte_overflow_drop = 1;
  void clear_num_byte_overflow_drop();
  static const int kNumByteOverflowDropFieldNumber = 1;
  ::google::protobuf::uint32 num_byte_overflow_drop() const;
  void set_num_byte_overflow_drop(::google::protobuf::uint32 value);

  // bool crc = 2;
  void clear_crc();
  static const int kCrcFieldNumber = 2;
  bool crc() const;
  void set_crc(bool value);

  // uint32 tx_channel = 3;
  void clear_tx_channel();
  static const int kTxChannelFieldNumber = 3;
  ::google::protobuf::uint32 tx_channel() const;
  void set_tx_channel(::google::protobuf::uint32 value);

  // uint32 slot_index = 4;
  void clear_slot_index();
  static const int kSlotIndexFieldNumber = 4;
  ::google::protobuf::uint32 slot_index() const;
  void set_slot_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:communicator.Mac_rx_stat)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 num_byte_overflow_drop_;
  bool crc_;
  ::google::protobuf::uint32 tx_channel_;
  ::google::protobuf::uint32 slot_index_;
  mutable int _cached_size_;
  friend struct protobuf_interf_2eproto::TableStruct;
};
// -------------------------------------------------------------------


// -------------------------------------------------------------------

class Mac_queue_stat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:communicator.Mac_queue_stat) */ {
 public:
  Mac_queue_stat();
  virtual ~Mac_queue_stat();

  Mac_queue_stat(const Mac_queue_stat& from);

  inline Mac_queue_stat& operator=(const Mac_queue_stat& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Mac_queue_stat& default_instance();

  static inline const Mac_queue_stat* internal_default_instance() {
    return reinterpret_cast<const Mac_queue_stat*>(
               &_Mac_queue_stat_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(Mac_queue_stat* other);

  // implements Message ----------------------------------------------

  inline Mac_queue_stat* New() const PROTOBUF_FINAL { return New(NULL); }

  Mac_queue_stat* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Mac_queue_stat& from);
  void MergeFrom(const Mac_queue_stat& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Mac_queue_stat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<uint64, uint32> queue_inf = 9;
  int queue_inf_size() const;
  void clear_queue_inf();
  static const int kQueueInfFieldNumber = 9;
  const ::google::protobuf::Map< ::google::protobuf::uint64, ::google::protobuf::uint32 >&
      queue_inf() const;
  ::google::protobuf::Map< ::google::protobuf::uint64, ::google::protobuf::uint32 >*
      mutable_queue_inf();

  // uint32 high_queue_size = 1;
  void clear_high_queue_size();
  static const int kHighQueueSizeFieldNumber = 1;
  ::google::protobuf::uint32 high_queue_size() const;
  void set_high_queue_size(::google::protobuf::uint32 value);

  // uint32 high_messages_in_queue = 2;
  void clear_high_messages_in_queue();
  static const int kHighMessagesInQueueFieldNumber = 2;
  ::google::protobuf::uint32 high_messages_in_queue() const;
  void set_high_messages_in_queue(::google::protobuf::uint32 value);

  // uint32 high_pkts_lost_overflow = 3;
  void clear_high_pkts_lost_overflow();
  static const int kHighPktsLostOverflowFieldNumber = 3;
  ::google::protobuf::uint32 high_pkts_lost_overflow() const;
  void set_high_pkts_lost_overflow(::google::protobuf::uint32 value);

  // uint32 high_average_queue_delay = 4;
  void clear_high_average_queue_delay();
  static const int kHighAverageQueueDelayFieldNumber = 4;
  ::google::protobuf::uint32 high_average_queue_delay() const;
  void set_high_average_queue_delay(::google::protobuf::uint32 value);

  // uint32 low_queue_size = 5;
  void clear_low_queue_size();
  static const int kLowQueueSizeFieldNumber = 5;
  ::google::protobuf::uint32 low_queue_size() const;
  void set_low_queue_size(::google::protobuf::uint32 value);

  // uint32 low_messages_in_queue = 6;
  void clear_low_messages_in_queue();
  static const int kLowMessagesInQueueFieldNumber = 6;
  ::google::protobuf::uint32 low_messages_in_queue() const;
  void set_low_messages_in_queue(::google::protobuf::uint32 value);

  // uint32 low_pkts_lost_overflow = 7;
  void clear_low_pkts_lost_overflow();
  static const int kLowPktsLostOverflowFieldNumber = 7;
  ::google::protobuf::uint32 low_pkts_lost_overflow() const;
  void set_low_pkts_lost_overflow(::google::protobuf::uint32 value);

  // uint32 low_average_queue_delay = 8;
  void clear_low_average_queue_delay();
  static const int kLowAverageQueueDelayFieldNumber = 8;
  ::google::protobuf::uint32 low_average_queue_delay() const;
  void set_low_average_queue_delay(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:communicator.Mac_queue_stat)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  public:
  class Mac_queue_stat_QueueInfEntry : public ::google::protobuf::internal::MapEntry<Mac_queue_stat_QueueInfEntry, 
      ::google::protobuf::uint64, ::google::protobuf::uint32,
      ::google::protobuf::internal::WireFormatLite::TYPE_UINT64,
      ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
      0 > {
  public:
    typedef ::google::protobuf::internal::MapEntry<Mac_queue_stat_QueueInfEntry, 
      ::google::protobuf::uint64, ::google::protobuf::uint32,
      ::google::protobuf::internal::WireFormatLite::TYPE_UINT64,
      ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
      0 > SuperType;
    Mac_queue_stat_QueueInfEntry();
    Mac_queue_stat_QueueInfEntry(::google::protobuf::Arena* arena);
    void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
    void MergeFrom(const Mac_queue_stat_QueueInfEntry& other);
    static const Message* internal_default_instance() { return reinterpret_cast<const Message*>(&_Mac_queue_stat_QueueInfEntry_default_instance_); }
    ::google::protobuf::Metadata GetMetadata() const;
  };
  ::google::protobuf::internal::MapField<
      Mac_queue_stat_QueueInfEntry,
      ::google::protobuf::uint64, ::google::protobuf::uint32,
      ::google::protobuf::internal::WireFormatLite::TYPE_UINT64,
      ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
      0 > queue_inf_;
  private:
  ::google::protobuf::uint32 high_queue_size_;
  ::google::protobuf::uint32 high_messages_in_queue_;
  ::google::protobuf::uint32 high_pkts_lost_overflow_;
  ::google::protobuf::uint32 high_average_queue_delay_;
  ::google::protobuf::uint32 low_queue_size_;
  ::google::protobuf::uint32 low_messages_in_queue_;
  ::google::protobuf::uint32 low_pkts_lost_overflow_;
  ::google::protobuf::uint32 low_average_queue_delay_;
  mutable int _cached_size_;
  friend struct protobuf_interf_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Mac_stat_Cell_information : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:communicator.Mac_stat.Cell_information) */ {
 public:
  Mac_stat_Cell_information();
  virtual ~Mac_stat_Cell_information();

  Mac_stat_Cell_information(const Mac_stat_Cell_information& from);

  inline Mac_stat_Cell_information& operator=(const Mac_stat_Cell_information& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Mac_stat_Cell_information& default_instance();

  enum RxTxStatCase {
    kTxStat = 5,
    kRxStat = 6,
    RX_TX_STAT_NOT_SET = 0,
  };

  static inline const Mac_stat_Cell_information* internal_default_instance() {
    return reinterpret_cast<const Mac_stat_Cell_information*>(
               &_Mac_stat_Cell_information_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(Mac_stat_Cell_information* other);

  // implements Message ----------------------------------------------

  inline Mac_stat_Cell_information* New() const PROTOBUF_FINAL { return New(NULL); }

  Mac_stat_Cell_information* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Mac_stat_Cell_information& from);
  void MergeFrom(const Mac_stat_Cell_information& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Mac_stat_Cell_information* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 ch = 1;
  void clear_ch();
  static const int kChFieldNumber = 1;
  ::google::protobuf::uint32 ch() const;
  void set_ch(::google::protobuf::uint32 value);

  // uint32 slot = 2;
  void clear_slot();
  static const int kSlotFieldNumber = 2;
  ::google::protobuf::uint32 slot() const;
  void set_slot(::google::protobuf::uint32 value);

  // uint32 num_byte_total = 3;
  void clear_num_byte_total();
  static const int kNumByteTotalFieldNumber = 3;
  ::google::protobuf::uint32 num_byte_total() const;
  void set_num_byte_total(::google::protobuf::uint32 value);

  // uint32 num_byte_crc_drop = 4;
  void clear_num_byte_crc_drop();
  static const int kNumByteCrcDropFieldNumber = 4;
  ::google::protobuf::uint32 num_byte_crc_drop() const;
  void set_num_byte_crc_drop(::google::protobuf::uint32 value);

  // .communicator.Mac_tx_stat tx_stat = 5;
  bool has_tx_stat() const;
  void clear_tx_stat();
  static const int kTxStatFieldNumber = 5;
  const ::communicator::Mac_tx_stat& tx_stat() const;
  ::communicator::Mac_tx_stat* mutable_tx_stat();
  ::communicator::Mac_tx_stat* release_tx_stat();
  void set_allocated_tx_stat(::communicator::Mac_tx_stat* tx_stat);

  // .communicator.Mac_rx_stat rx_stat = 6;
  bool has_rx_stat() const;
  void clear_rx_stat();
  static const int kRxStatFieldNumber = 6;
  const ::communicator::Mac_rx_stat& rx_stat() const;
  ::communicator::Mac_rx_stat* mutable_rx_stat();
  ::communicator::Mac_rx_stat* release_rx_stat();
  void set_allocated_rx_stat(::communicator::Mac_rx_stat* rx_stat);

  RxTxStatCase rx_tx_stat_case() const;
  // @@protoc_insertion_point(class_scope:communicator.Mac_stat.Cell_information)
 private:
  void set_has_tx_stat();
  void set_has_rx_stat();

  inline bool has_rx_tx_stat() const;
  void clear_rx_tx_stat();
  inline void clear_has_rx_tx_stat();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 ch_;
  ::google::protobuf::uint32 slot_;
  ::google::protobuf::uint32 num_byte_total_;
  ::google::protobuf::uint32 num_byte_crc_drop_;
  union RxTxStatUnion {
    RxTxStatUnion() {}
    ::communicator::Mac_tx_stat* tx_stat_;
    ::communicator::Mac_rx_stat* rx_stat_;
  } rx_tx_stat_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_interf_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Mac_stat_Mac_send_stat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:communicator.Mac_stat.Mac_send_stat) */ {
 public:
  Mac_stat_Mac_send_stat();
  virtual ~Mac_stat_Mac_send_stat();

  Mac_stat_Mac_send_stat(const Mac_stat_Mac_send_stat& from);

  inline Mac_stat_Mac_send_stat& operator=(const Mac_stat_Mac_send_stat& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Mac_stat_Mac_send_stat& default_instance();

  static inline const Mac_stat_Mac_send_stat* internal_default_instance() {
    return reinterpret_cast<const Mac_stat_Mac_send_stat*>(
               &_Mac_stat_Mac_send_stat_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(Mac_stat_Mac_send_stat* other);

  // implements Message ----------------------------------------------

  inline Mac_stat_Mac_send_stat* New() const PROTOBUF_FINAL { return New(NULL); }

  Mac_stat_Mac_send_stat* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Mac_stat_Mac_send_stat& from);
  void MergeFrom(const Mac_stat_Mac_send_stat& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Mac_stat_Mac_send_stat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 start_timestamp = 1;
  void clear_start_timestamp();
  static const int kStartTimestampFieldNumber = 1;
  ::google::protobuf::uint64 start_timestamp() const;
  void set_start_timestamp(::google::protobuf::uint64 value);

  // uint32 packet_count = 2;
  void clear_packet_count();
  static const int kPacketCountFieldNumber = 2;
  ::google::protobuf::uint32 packet_count() const;
  void set_packet_count(::google::protobuf::uint32 value);

  // uint32 ch = 3;
  void clear_ch();
  static const int kChFieldNumber = 3;
  ::google::protobuf::uint32 ch() const;
  void set_ch(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:communicator.Mac_stat.Mac_send_stat)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 start_timestamp_;
  ::google::protobuf::uint32 packet_count_;
  ::google::protobuf::uint32 ch_;
  mutable int _cached_size_;
  friend struct protobuf_interf_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Mac_stat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:communicator.Mac_stat) */ {
 public:
  Mac_stat();
  virtual ~Mac_stat();

  Mac_stat(const Mac_stat& from);

  inline Mac_stat& operator=(const Mac_stat& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Mac_stat& default_instance();

  enum StatCase {
    kRxTxStat = 6,
    kQueueStat = 7,
    kSendStat = 8,
    STAT_NOT_SET = 0,
  };

  static inline const Mac_stat* internal_default_instance() {
    return reinterpret_cast<const Mac_stat*>(
               &_Mac_stat_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(Mac_stat* other);

  // implements Message ----------------------------------------------

  inline Mac_stat* New() const PROTOBUF_FINAL { return New(NULL); }

  Mac_stat* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Mac_stat& from);
  void MergeFrom(const Mac_stat& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Mac_stat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Mac_stat_Cell_information Cell_information;
  typedef Mac_stat_Mac_send_stat Mac_send_stat;

  // accessors -------------------------------------------------------

  // uint32 average_mac_delay = 1;
  void clear_average_mac_delay();
  static const int kAverageMacDelayFieldNumber = 1;
  ::google::protobuf::uint32 average_mac_delay() const;
  void set_average_mac_delay(::google::protobuf::uint32 value);

  // uint32 pkts_lost_mac = 2;
  void clear_pkts_lost_mac();
  static const int kPktsLostMacFieldNumber = 2;
  ::google::protobuf::uint32 pkts_lost_mac() const;
  void set_pkts_lost_mac(::google::protobuf::uint32 value);

  // uint64 host_timestamp = 3;
  void clear_host_timestamp();
  static const int kHostTimestampFieldNumber = 3;
  ::google::protobuf::uint64 host_timestamp() const;
  void set_host_timestamp(::google::protobuf::uint64 value);

  // uint64 fpga_timestamp = 4;
  void clear_fpga_timestamp();
  static const int kFpgaTimestampFieldNumber = 4;
  ::google::protobuf::uint64 fpga_timestamp() const;
  void set_fpga_timestamp(::google::protobuf::uint64 value);

  // uint64 frame = 5;
  void clear_frame();
  static const int kFrameFieldNumber = 5;
  ::google::protobuf::uint64 frame() const;
  void set_frame(::google::protobuf::uint64 value);

  // .communicator.Mac_stat.Cell_information rx_tx_stat = 6;
  bool has_rx_tx_stat() const;
  void clear_rx_tx_stat();
  static const int kRxTxStatFieldNumber = 6;
  const ::communicator::Mac_stat_Cell_information& rx_tx_stat() const;
  ::communicator::Mac_stat_Cell_information* mutable_rx_tx_stat();
  ::communicator::Mac_stat_Cell_information* release_rx_tx_stat();
  void set_allocated_rx_tx_stat(::communicator::Mac_stat_Cell_information* rx_tx_stat);

  // .communicator.Mac_queue_stat queue_stat = 7;
  bool has_queue_stat() const;
  void clear_queue_stat();
  static const int kQueueStatFieldNumber = 7;
  const ::communicator::Mac_queue_stat& queue_stat() const;
  ::communicator::Mac_queue_stat* mutable_queue_stat();
  ::communicator::Mac_queue_stat* release_queue_stat();
  void set_allocated_queue_stat(::communicator::Mac_queue_stat* queue_stat);

  // .communicator.Mac_stat.Mac_send_stat send_stat = 8;
  bool has_send_stat() const;
  void clear_send_stat();
  static const int kSendStatFieldNumber = 8;
  const ::communicator::Mac_stat_Mac_send_stat& send_stat() const;
  ::communicator::Mac_stat_Mac_send_stat* mutable_send_stat();
  ::communicator::Mac_stat_Mac_send_stat* release_send_stat();
  void set_allocated_send_stat(::communicator::Mac_stat_Mac_send_stat* send_stat);

  StatCase stat_case() const;
  // @@protoc_insertion_point(class_scope:communicator.Mac_stat)
 private:
  void set_has_rx_tx_stat();
  void set_has_queue_stat();
  void set_has_send_stat();

  inline bool has_stat() const;
  void clear_stat();
  inline void clear_has_stat();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 average_mac_delay_;
  ::google::protobuf::uint32 pkts_lost_mac_;
  ::google::protobuf::uint64 host_timestamp_;
  ::google::protobuf::uint64 fpga_timestamp_;
  ::google::protobuf::uint64 frame_;
  union StatUnion {
    StatUnion() {}
    ::communicator::Mac_stat_Cell_information* rx_tx_stat_;
    ::communicator::Mac_queue_stat* queue_stat_;
    ::communicator::Mac_stat_Mac_send_stat* send_stat_;
  } stat_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_interf_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RF_timeslot_stat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:communicator.RF_timeslot_stat) */ {
 public:
  RF_timeslot_stat();
  virtual ~RF_timeslot_stat();

  RF_timeslot_stat(const RF_timeslot_stat& from);

  inline RF_timeslot_stat& operator=(const RF_timeslot_stat& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RF_timeslot_stat& default_instance();

  static inline const RF_timeslot_stat* internal_default_instance() {
    return reinterpret_cast<const RF_timeslot_stat*>(
               &_RF_timeslot_stat_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(RF_timeslot_stat* other);

  // implements Message ----------------------------------------------

  inline RF_timeslot_stat* New() const PROTOBUF_FINAL { return New(NULL); }

  RF_timeslot_stat* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RF_timeslot_stat& from);
  void MergeFrom(const RF_timeslot_stat& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RF_timeslot_stat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double rssi = 5;
  int rssi_size() const;
  void clear_rssi();
  static const int kRssiFieldNumber = 5;
  double rssi(int index) const;
  void set_rssi(int index, double value);
  void add_rssi(double value);
  const ::google::protobuf::RepeatedField< double >&
      rssi() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_rssi();

  // uint64 host_timestamp = 1;
  void clear_host_timestamp();
  static const int kHostTimestampFieldNumber = 1;
  ::google::protobuf::uint64 host_timestamp() const;
  void set_host_timestamp(::google::protobuf::uint64 value);

  // uint64 fpga_timestamp = 2;
  void clear_fpga_timestamp();
  static const int kFpgaTimestampFieldNumber = 2;
  ::google::protobuf::uint64 fpga_timestamp() const;
  void set_fpga_timestamp(::google::protobuf::uint64 value);

  // uint64 frame = 3;
  void clear_frame();
  static const int kFrameFieldNumber = 3;
  ::google::protobuf::uint64 frame() const;
  void set_frame(::google::protobuf::uint64 value);

  // uint32 slot = 4;
  void clear_slot();
  static const int kSlotFieldNumber = 4;
  ::google::protobuf::uint32 slot() const;
  void set_slot(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:communicator.RF_timeslot_stat)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< double > rssi_;
  mutable int _rssi_cached_byte_size_;
  ::google::protobuf::uint64 host_timestamp_;
  ::google::protobuf::uint64 fpga_timestamp_;
  ::google::protobuf::uint64 frame_;
  ::google::protobuf::uint32 slot_;
  mutable int _cached_size_;
  friend struct protobuf_interf_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RF_stat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:communicator.RF_stat) */ {
 public:
  RF_stat();
  virtual ~RF_stat();

  RF_stat(const RF_stat& from);

  inline RF_stat& operator=(const RF_stat& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RF_stat& default_instance();

  static inline const RF_stat* internal_default_instance() {
    return reinterpret_cast<const RF_stat*>(
               &_RF_stat_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(RF_stat* other);

  // implements Message ----------------------------------------------

  inline RF_stat* New() const PROTOBUF_FINAL { return New(NULL); }

  RF_stat* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RF_stat& from);
  void MergeFrom(const RF_stat& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RF_stat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .communicator.RF_timeslot_stat stats = 1;
  int stats_size() const;
  void clear_stats();
  static const int kStatsFieldNumber = 1;
  const ::communicator::RF_timeslot_stat& stats(int index) const;
  ::communicator::RF_timeslot_stat* mutable_stats(int index);
  ::communicator::RF_timeslot_stat* add_stats();
  ::google::protobuf::RepeatedPtrField< ::communicator::RF_timeslot_stat >*
      mutable_stats();
  const ::google::protobuf::RepeatedPtrField< ::communicator::RF_timeslot_stat >&
      stats() const;

  // @@protoc_insertion_point(class_scope:communicator.RF_stat)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::communicator::RF_timeslot_stat > stats_;
  mutable int _cached_size_;
  friend struct protobuf_interf_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Application_data : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:communicator.Application_data) */ {
 public:
  Application_data();
  virtual ~Application_data();

  Application_data(const Application_data& from);

  inline Application_data& operator=(const Application_data& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Application_data& default_instance();

  static inline const Application_data* internal_default_instance() {
    return reinterpret_cast<const Application_data*>(
               &_Application_data_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(Application_data* other);

  // implements Message ----------------------------------------------

  inline Application_data* New() const PROTOBUF_FINAL { return New(NULL); }

  Application_data* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Application_data& from);
  void MergeFrom(const Application_data& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Application_data* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Application_data_PACKET_TYPE PACKET_TYPE;
  static const PACKET_TYPE PACKET_TYPE_UNKNOWN =
    Application_data_PACKET_TYPE_PACKET_TYPE_UNKNOWN;
  static const PACKET_TYPE IPv4 =
    Application_data_PACKET_TYPE_IPv4;
  static const PACKET_TYPE ARP =
    Application_data_PACKET_TYPE_ARP;
  static inline bool PACKET_TYPE_IsValid(int value) {
    return Application_data_PACKET_TYPE_IsValid(value);
  }
  static const PACKET_TYPE PACKET_TYPE_MIN =
    Application_data_PACKET_TYPE_PACKET_TYPE_MIN;
  static const PACKET_TYPE PACKET_TYPE_MAX =
    Application_data_PACKET_TYPE_PACKET_TYPE_MAX;
  static const int PACKET_TYPE_ARRAYSIZE =
    Application_data_PACKET_TYPE_PACKET_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PACKET_TYPE_descriptor() {
    return Application_data_PACKET_TYPE_descriptor();
  }
  static inline const ::std::string& PACKET_TYPE_Name(PACKET_TYPE value) {
    return Application_data_PACKET_TYPE_Name(value);
  }
  static inline bool PACKET_TYPE_Parse(const ::std::string& name,
      PACKET_TYPE* value) {
    return Application_data_PACKET_TYPE_Parse(name, value);
  }

  typedef Application_data_TRAFFIC_CLASS TRAFFIC_CLASS;
  static const TRAFFIC_CLASS TRAFFIC_CLASS_UNKOWN =
    Application_data_TRAFFIC_CLASS_TRAFFIC_CLASS_UNKOWN;
  static const TRAFFIC_CLASS VoIP =
    Application_data_TRAFFIC_CLASS_VoIP;
  static const TRAFFIC_CLASS FTP =
    Application_data_TRAFFIC_CLASS_FTP;
  static const TRAFFIC_CLASS HTTP =
    Application_data_TRAFFIC_CLASS_HTTP;
  static const TRAFFIC_CLASS AI =
    Application_data_TRAFFIC_CLASS_AI;
  static const TRAFFIC_CLASS CONTROL =
    Application_data_TRAFFIC_CLASS_CONTROL;
  static inline bool TRAFFIC_CLASS_IsValid(int value) {
    return Application_data_TRAFFIC_CLASS_IsValid(value);
  }
  static const TRAFFIC_CLASS TRAFFIC_CLASS_MIN =
    Application_data_TRAFFIC_CLASS_TRAFFIC_CLASS_MIN;
  static const TRAFFIC_CLASS TRAFFIC_CLASS_MAX =
    Application_data_TRAFFIC_CLASS_TRAFFIC_CLASS_MAX;
  static const int TRAFFIC_CLASS_ARRAYSIZE =
    Application_data_TRAFFIC_CLASS_TRAFFIC_CLASS_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TRAFFIC_CLASS_descriptor() {
    return Application_data_TRAFFIC_CLASS_descriptor();
  }
  static inline const ::std::string& TRAFFIC_CLASS_Name(TRAFFIC_CLASS value) {
    return Application_data_TRAFFIC_CLASS_Name(value);
  }
  static inline bool TRAFFIC_CLASS_Parse(const ::std::string& name,
      TRAFFIC_CLASS* value) {
    return Application_data_TRAFFIC_CLASS_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // bytes data = 6;
  void clear_data();
  static const int kDataFieldNumber = 6;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // uint64 next_mac = 1;
  void clear_next_mac();
  static const int kNextMacFieldNumber = 1;
  ::google::protobuf::uint64 next_mac() const;
  void set_next_mac(::google::protobuf::uint64 value);

  // fixed32 destination_ip = 2;
  void clear_destination_ip();
  static const int kDestinationIpFieldNumber = 2;
  ::google::protobuf::uint32 destination_ip() const;
  void set_destination_ip(::google::protobuf::uint32 value);

  // .communicator.Application_data.PACKET_TYPE packet_type = 3;
  void clear_packet_type();
  static const int kPacketTypeFieldNumber = 3;
  ::communicator::Application_data_PACKET_TYPE packet_type() const;
  void set_packet_type(::communicator::Application_data_PACKET_TYPE value);

  // .communicator.Application_data.TRAFFIC_CLASS traffic_class = 4;
  void clear_traffic_class();
  static const int kTrafficClassFieldNumber = 4;
  ::communicator::Application_data_TRAFFIC_CLASS traffic_class() const;
  void set_traffic_class(::communicator::Application_data_TRAFFIC_CLASS value);

  // uint32 priority = 5;
  void clear_priority();
  static const int kPriorityFieldNumber = 5;
  ::google::protobuf::uint32 priority() const;
  void set_priority(::google::protobuf::uint32 value);

  // uint64 timestamp = 7;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 7;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:communicator.Application_data)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::uint64 next_mac_;
  ::google::protobuf::uint32 destination_ip_;
  int packet_type_;
  int traffic_class_;
  ::google::protobuf::uint32 priority_;
  ::google::protobuf::uint64 timestamp_;
  mutable int _cached_size_;
  friend struct protobuf_interf_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Link_MCS_TxGain_BW : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:communicator.Link_MCS_TxGain_BW) */ {
 public:
  Link_MCS_TxGain_BW();
  virtual ~Link_MCS_TxGain_BW();

  Link_MCS_TxGain_BW(const Link_MCS_TxGain_BW& from);

  inline Link_MCS_TxGain_BW& operator=(const Link_MCS_TxGain_BW& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Link_MCS_TxGain_BW& default_instance();

  static inline const Link_MCS_TxGain_BW* internal_default_instance() {
    return reinterpret_cast<const Link_MCS_TxGain_BW*>(
               &_Link_MCS_TxGain_BW_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(Link_MCS_TxGain_BW* other);

  // implements Message ----------------------------------------------

  inline Link_MCS_TxGain_BW* New() const PROTOBUF_FINAL { return New(NULL); }

  Link_MCS_TxGain_BW* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Link_MCS_TxGain_BW& from);
  void MergeFrom(const Link_MCS_TxGain_BW& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Link_MCS_TxGain_BW* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 destination_mac = 1;
  void clear_destination_mac();
  static const int kDestinationMacFieldNumber = 1;
  ::google::protobuf::uint64 destination_mac() const;
  void set_destination_mac(::google::protobuf::uint64 value);

  // uint32 mcs = 2;
  void clear_mcs();
  static const int kMcsFieldNumber = 2;
  ::google::protobuf::uint32 mcs() const;
  void set_mcs(::google::protobuf::uint32 value);

  // uint32 tx_gain = 3;
  void clear_tx_gain();
  static const int kTxGainFieldNumber = 3;
  ::google::protobuf::uint32 tx_gain() const;
  void set_tx_gain(::google::protobuf::uint32 value);

  // .communicator.BW_INDEX bw_index = 4;
  void clear_bw_index();
  static const int kBwIndexFieldNumber = 4;
  ::communicator::BW_INDEX bw_index() const;
  void set_bw_index(::communicator::BW_INDEX value);

  // @@protoc_insertion_point(class_scope:communicator.Link_MCS_TxGain_BW)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 destination_mac_;
  ::google::protobuf::uint32 mcs_;
  ::google::protobuf::uint32 tx_gain_;
  int bw_index_;
  mutable int _cached_size_;
  friend struct protobuf_interf_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MFTDMA_Slot : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:communicator.MFTDMA_Slot) */ {
 public:
  MFTDMA_Slot();
  virtual ~MFTDMA_Slot();

  MFTDMA_Slot(const MFTDMA_Slot& from);

  inline MFTDMA_Slot& operator=(const MFTDMA_Slot& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MFTDMA_Slot& default_instance();

  static inline const MFTDMA_Slot* internal_default_instance() {
    return reinterpret_cast<const MFTDMA_Slot*>(
               &_MFTDMA_Slot_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(MFTDMA_Slot* other);

  // implements Message ----------------------------------------------

  inline MFTDMA_Slot* New() const PROTOBUF_FINAL { return New(NULL); }

  MFTDMA_Slot* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MFTDMA_Slot& from);
  void MergeFrom(const MFTDMA_Slot& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MFTDMA_Slot* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 frequency_num = 1;
  void clear_frequency_num();
  static const int kFrequencyNumFieldNumber = 1;
  ::google::protobuf::uint32 frequency_num() const;
  void set_frequency_num(::google::protobuf::uint32 value);

  // uint32 timeslot_num = 2;
  void clear_timeslot_num();
  static const int kTimeslotNumFieldNumber = 2;
  ::google::protobuf::uint32 timeslot_num() const;
  void set_timeslot_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:communicator.MFTDMA_Slot)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 frequency_num_;
  ::google::protobuf::uint32 timeslot_num_;
  mutable int _cached_size_;
  friend struct protobuf_interf_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Proposed_Slots_Request : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:communicator.Proposed_Slots_Request) */ {
 public:
  Proposed_Slots_Request();
  virtual ~Proposed_Slots_Request();

  Proposed_Slots_Request(const Proposed_Slots_Request& from);

  inline Proposed_Slots_Request& operator=(const Proposed_Slots_Request& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Proposed_Slots_Request& default_instance();

  static inline const Proposed_Slots_Request* internal_default_instance() {
    return reinterpret_cast<const Proposed_Slots_Request*>(
               &_Proposed_Slots_Request_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(Proposed_Slots_Request* other);

  // implements Message ----------------------------------------------

  inline Proposed_Slots_Request* New() const PROTOBUF_FINAL { return New(NULL); }

  Proposed_Slots_Request* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Proposed_Slots_Request& from);
  void MergeFrom(const Proposed_Slots_Request& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Proposed_Slots_Request* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 mac = 1;
  void clear_mac();
  static const int kMacFieldNumber = 1;
  ::google::protobuf::uint64 mac() const;
  void set_mac(::google::protobuf::uint64 value);

  // uint32 num_slots = 2;
  void clear_num_slots();
  static const int kNumSlotsFieldNumber = 2;
  ::google::protobuf::uint32 num_slots() const;
  void set_num_slots(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:communicator.Proposed_Slots_Request)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 mac_;
  ::google::protobuf::uint32 num_slots_;
  mutable int _cached_size_;
  friend struct protobuf_interf_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Proposed_Slots : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:communicator.Proposed_Slots) */ {
 public:
  Proposed_Slots();
  virtual ~Proposed_Slots();

  Proposed_Slots(const Proposed_Slots& from);

  inline Proposed_Slots& operator=(const Proposed_Slots& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Proposed_Slots& default_instance();

  static inline const Proposed_Slots* internal_default_instance() {
    return reinterpret_cast<const Proposed_Slots*>(
               &_Proposed_Slots_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(Proposed_Slots* other);

  // implements Message ----------------------------------------------

  inline Proposed_Slots* New() const PROTOBUF_FINAL { return New(NULL); }

  Proposed_Slots* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Proposed_Slots& from);
  void MergeFrom(const Proposed_Slots& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Proposed_Slots* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .communicator.MFTDMA_Slot slots = 2;
  int slots_size() const;
  void clear_slots();
  static const int kSlotsFieldNumber = 2;
  const ::communicator::MFTDMA_Slot& slots(int index) const;
  ::communicator::MFTDMA_Slot* mutable_slots(int index);
  ::communicator::MFTDMA_Slot* add_slots();
  ::google::protobuf::RepeatedPtrField< ::communicator::MFTDMA_Slot >*
      mutable_slots();
  const ::google::protobuf::RepeatedPtrField< ::communicator::MFTDMA_Slot >&
      slots() const;

  // uint64 mac = 1;
  void clear_mac();
  static const int kMacFieldNumber = 1;
  ::google::protobuf::uint64 mac() const;
  void set_mac(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:communicator.Proposed_Slots)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::communicator::MFTDMA_Slot > slots_;
  ::google::protobuf::uint64 mac_;
  mutable int _cached_size_;
  friend struct protobuf_interf_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Proposed_Move_Slots : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:communicator.Proposed_Move_Slots) */ {
 public:
  Proposed_Move_Slots();
  virtual ~Proposed_Move_Slots();

  Proposed_Move_Slots(const Proposed_Move_Slots& from);

  inline Proposed_Move_Slots& operator=(const Proposed_Move_Slots& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Proposed_Move_Slots& default_instance();

  static inline const Proposed_Move_Slots* internal_default_instance() {
    return reinterpret_cast<const Proposed_Move_Slots*>(
               &_Proposed_Move_Slots_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(Proposed_Move_Slots* other);

  // implements Message ----------------------------------------------

  inline Proposed_Move_Slots* New() const PROTOBUF_FINAL { return New(NULL); }

  Proposed_Move_Slots* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Proposed_Move_Slots& from);
  void MergeFrom(const Proposed_Move_Slots& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Proposed_Move_Slots* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .communicator.MFTDMA_Slot slots = 3;
  int slots_size() const;
  void clear_slots();
  static const int kSlotsFieldNumber = 3;
  const ::communicator::MFTDMA_Slot& slots(int index) const;
  ::communicator::MFTDMA_Slot* mutable_slots(int index);
  ::communicator::MFTDMA_Slot* add_slots();
  ::google::protobuf::RepeatedPtrField< ::communicator::MFTDMA_Slot >*
      mutable_slots();
  const ::google::protobuf::RepeatedPtrField< ::communicator::MFTDMA_Slot >&
      slots() const;

  // .communicator.MFTDMA_Slot old_slot = 2;
  bool has_old_slot() const;
  void clear_old_slot();
  static const int kOldSlotFieldNumber = 2;
  const ::communicator::MFTDMA_Slot& old_slot() const;
  ::communicator::MFTDMA_Slot* mutable_old_slot();
  ::communicator::MFTDMA_Slot* release_old_slot();
  void set_allocated_old_slot(::communicator::MFTDMA_Slot* old_slot);

  // uint64 mac = 1;
  void clear_mac();
  static const int kMacFieldNumber = 1;
  ::google::protobuf::uint64 mac() const;
  void set_mac(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:communicator.Proposed_Move_Slots)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::communicator::MFTDMA_Slot > slots_;
  ::communicator::MFTDMA_Slot* old_slot_;
  ::google::protobuf::uint64 mac_;
  mutable int _cached_size_;
  friend struct protobuf_interf_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Selected_Slot : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:communicator.Selected_Slot) */ {
 public:
  Selected_Slot();
  virtual ~Selected_Slot();

  Selected_Slot(const Selected_Slot& from);

  inline Selected_Slot& operator=(const Selected_Slot& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Selected_Slot& default_instance();

  static inline const Selected_Slot* internal_default_instance() {
    return reinterpret_cast<const Selected_Slot*>(
               &_Selected_Slot_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(Selected_Slot* other);

  // implements Message ----------------------------------------------

  inline Selected_Slot* New() const PROTOBUF_FINAL { return New(NULL); }

  Selected_Slot* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Selected_Slot& from);
  void MergeFrom(const Selected_Slot& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Selected_Slot* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .communicator.MFTDMA_Slot slot = 2;
  bool has_slot() const;
  void clear_slot();
  static const int kSlotFieldNumber = 2;
  const ::communicator::MFTDMA_Slot& slot() const;
  ::communicator::MFTDMA_Slot* mutable_slot();
  ::communicator::MFTDMA_Slot* release_slot();
  void set_allocated_slot(::communicator::MFTDMA_Slot* slot);

  // uint64 mac = 1;
  void clear_mac();
  static const int kMacFieldNumber = 1;
  ::google::protobuf::uint64 mac() const;
  void set_mac(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:communicator.Selected_Slot)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::communicator::MFTDMA_Slot* slot_;
  ::google::protobuf::uint64 mac_;
  mutable int _cached_size_;
  friend struct protobuf_interf_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Selected_Move_Slot : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:communicator.Selected_Move_Slot) */ {
 public:
  Selected_Move_Slot();
  virtual ~Selected_Move_Slot();

  Selected_Move_Slot(const Selected_Move_Slot& from);

  inline Selected_Move_Slot& operator=(const Selected_Move_Slot& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Selected_Move_Slot& default_instance();

  static inline const Selected_Move_Slot* internal_default_instance() {
    return reinterpret_cast<const Selected_Move_Slot*>(
               &_Selected_Move_Slot_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(Selected_Move_Slot* other);

  // implements Message ----------------------------------------------

  inline Selected_Move_Slot* New() const PROTOBUF_FINAL { return New(NULL); }

  Selected_Move_Slot* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Selected_Move_Slot& from);
  void MergeFrom(const Selected_Move_Slot& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Selected_Move_Slot* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .communicator.MFTDMA_Slot old_slot = 2;
  bool has_old_slot() const;
  void clear_old_slot();
  static const int kOldSlotFieldNumber = 2;
  const ::communicator::MFTDMA_Slot& old_slot() const;
  ::communicator::MFTDMA_Slot* mutable_old_slot();
  ::communicator::MFTDMA_Slot* release_old_slot();
  void set_allocated_old_slot(::communicator::MFTDMA_Slot* old_slot);

  // .communicator.MFTDMA_Slot new_slot = 3;
  bool has_new_slot() const;
  void clear_new_slot();
  static const int kNewSlotFieldNumber = 3;
  const ::communicator::MFTDMA_Slot& new_slot() const;
  ::communicator::MFTDMA_Slot* mutable_new_slot();
  ::communicator::MFTDMA_Slot* release_new_slot();
  void set_allocated_new_slot(::communicator::MFTDMA_Slot* new_slot);

  // uint64 mac = 1;
  void clear_mac();
  static const int kMacFieldNumber = 1;
  ::google::protobuf::uint64 mac() const;
  void set_mac(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:communicator.Selected_Move_Slot)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::communicator::MFTDMA_Slot* old_slot_;
  ::communicator::MFTDMA_Slot* new_slot_;
  ::google::protobuf::uint64 mac_;
  mutable int _cached_size_;
  friend struct protobuf_interf_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class External_Slot_Allocation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:communicator.External_Slot_Allocation) */ {
 public:
  External_Slot_Allocation();
  virtual ~External_Slot_Allocation();

  External_Slot_Allocation(const External_Slot_Allocation& from);

  inline External_Slot_Allocation& operator=(const External_Slot_Allocation& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const External_Slot_Allocation& default_instance();

  static inline const External_Slot_Allocation* internal_default_instance() {
    return reinterpret_cast<const External_Slot_Allocation*>(
               &_External_Slot_Allocation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(External_Slot_Allocation* other);

  // implements Message ----------------------------------------------

  inline External_Slot_Allocation* New() const PROTOBUF_FINAL { return New(NULL); }

  External_Slot_Allocation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const External_Slot_Allocation& from);
  void MergeFrom(const External_Slot_Allocation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(External_Slot_Allocation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .communicator.MFTDMA_Slot slot = 3;
  bool has_slot() const;
  void clear_slot();
  static const int kSlotFieldNumber = 3;
  const ::communicator::MFTDMA_Slot& slot() const;
  ::communicator::MFTDMA_Slot* mutable_slot();
  ::communicator::MFTDMA_Slot* release_slot();
  void set_allocated_slot(::communicator::MFTDMA_Slot* slot);

  // uint64 src_mac = 1;
  void clear_src_mac();
  static const int kSrcMacFieldNumber = 1;
  ::google::protobuf::uint64 src_mac() const;
  void set_src_mac(::google::protobuf::uint64 value);

  // uint64 dst_mac = 2;
  void clear_dst_mac();
  static const int kDstMacFieldNumber = 2;
  ::google::protobuf::uint64 dst_mac() const;
  void set_dst_mac(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:communicator.External_Slot_Allocation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::communicator::MFTDMA_Slot* slot_;
  ::google::protobuf::uint64 src_mac_;
  ::google::protobuf::uint64 dst_mac_;
  mutable int _cached_size_;
  friend struct protobuf_interf_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class External_Slot_Removal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:communicator.External_Slot_Removal) */ {
 public:
  External_Slot_Removal();
  virtual ~External_Slot_Removal();

  External_Slot_Removal(const External_Slot_Removal& from);

  inline External_Slot_Removal& operator=(const External_Slot_Removal& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const External_Slot_Removal& default_instance();

  static inline const External_Slot_Removal* internal_default_instance() {
    return reinterpret_cast<const External_Slot_Removal*>(
               &_External_Slot_Removal_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(External_Slot_Removal* other);

  // implements Message ----------------------------------------------

  inline External_Slot_Removal* New() const PROTOBUF_FINAL { return New(NULL); }

  External_Slot_Removal* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const External_Slot_Removal& from);
  void MergeFrom(const External_Slot_Removal& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(External_Slot_Removal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .communicator.MFTDMA_Slot slot = 3;
  bool has_slot() const;
  void clear_slot();
  static const int kSlotFieldNumber = 3;
  const ::communicator::MFTDMA_Slot& slot() const;
  ::communicator::MFTDMA_Slot* mutable_slot();
  ::communicator::MFTDMA_Slot* release_slot();
  void set_allocated_slot(::communicator::MFTDMA_Slot* slot);

  // uint64 src_mac = 1;
  void clear_src_mac();
  static const int kSrcMacFieldNumber = 1;
  ::google::protobuf::uint64 src_mac() const;
  void set_src_mac(::google::protobuf::uint64 value);

  // uint64 dst_mac = 2;
  void clear_dst_mac();
  static const int kDstMacFieldNumber = 2;
  ::google::protobuf::uint64 dst_mac() const;
  void set_dst_mac(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:communicator.External_Slot_Removal)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::communicator::MFTDMA_Slot* slot_;
  ::google::protobuf::uint64 src_mac_;
  ::google::protobuf::uint64 dst_mac_;
  mutable int _cached_size_;
  friend struct protobuf_interf_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BC_Slots_Announcement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:communicator.BC_Slots_Announcement) */ {
 public:
  BC_Slots_Announcement();
  virtual ~BC_Slots_Announcement();

  BC_Slots_Announcement(const BC_Slots_Announcement& from);

  inline BC_Slots_Announcement& operator=(const BC_Slots_Announcement& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BC_Slots_Announcement& default_instance();

  static inline const BC_Slots_Announcement* internal_default_instance() {
    return reinterpret_cast<const BC_Slots_Announcement*>(
               &_BC_Slots_Announcement_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(BC_Slots_Announcement* other);

  // implements Message ----------------------------------------------

  inline BC_Slots_Announcement* New() const PROTOBUF_FINAL { return New(NULL); }

  BC_Slots_Announcement* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BC_Slots_Announcement& from);
  void MergeFrom(const BC_Slots_Announcement& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BC_Slots_Announcement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .communicator.MFTDMA_Slot slots = 1;
  int slots_size() const;
  void clear_slots();
  static const int kSlotsFieldNumber = 1;
  const ::communicator::MFTDMA_Slot& slots(int index) const;
  ::communicator::MFTDMA_Slot* mutable_slots(int index);
  ::communicator::MFTDMA_Slot* add_slots();
  ::google::protobuf::RepeatedPtrField< ::communicator::MFTDMA_Slot >*
      mutable_slots();
  const ::google::protobuf::RepeatedPtrField< ::communicator::MFTDMA_Slot >&
      slots() const;

  // @@protoc_insertion_point(class_scope:communicator.BC_Slots_Announcement)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::communicator::MFTDMA_Slot > slots_;
  mutable int _cached_size_;
  friend struct protobuf_interf_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Slot_Allocation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:communicator.Slot_Allocation) */ {
 public:
  Slot_Allocation();
  virtual ~Slot_Allocation();

  Slot_Allocation(const Slot_Allocation& from);

  inline Slot_Allocation& operator=(const Slot_Allocation& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Slot_Allocation& default_instance();

  static inline const Slot_Allocation* internal_default_instance() {
    return reinterpret_cast<const Slot_Allocation*>(
               &_Slot_Allocation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(Slot_Allocation* other);

  // implements Message ----------------------------------------------

  inline Slot_Allocation* New() const PROTOBUF_FINAL { return New(NULL); }

  Slot_Allocation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Slot_Allocation& from);
  void MergeFrom(const Slot_Allocation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Slot_Allocation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .communicator.MFTDMA_Slot slot = 2;
  bool has_slot() const;
  void clear_slot();
  static const int kSlotFieldNumber = 2;
  const ::communicator::MFTDMA_Slot& slot() const;
  ::communicator::MFTDMA_Slot* mutable_slot();
  ::communicator::MFTDMA_Slot* release_slot();
  void set_allocated_slot(::communicator::MFTDMA_Slot* slot);

  // uint64 mac = 1;
  void clear_mac();
  static const int kMacFieldNumber = 1;
  ::google::protobuf::uint64 mac() const;
  void set_mac(::google::protobuf::uint64 value);

  // .communicator.SLOT_MODE mode = 3;
  void clear_mode();
  static const int kModeFieldNumber = 3;
  ::communicator::SLOT_MODE mode() const;
  void set_mode(::communicator::SLOT_MODE value);

  // @@protoc_insertion_point(class_scope:communicator.Slot_Allocation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::communicator::MFTDMA_Slot* slot_;
  ::google::protobuf::uint64 mac_;
  int mode_;
  mutable int _cached_size_;
  friend struct protobuf_interf_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Slot_Removal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:communicator.Slot_Removal) */ {
 public:
  Slot_Removal();
  virtual ~Slot_Removal();

  Slot_Removal(const Slot_Removal& from);

  inline Slot_Removal& operator=(const Slot_Removal& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Slot_Removal& default_instance();

  static inline const Slot_Removal* internal_default_instance() {
    return reinterpret_cast<const Slot_Removal*>(
               &_Slot_Removal_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void Swap(Slot_Removal* other);

  // implements Message ----------------------------------------------

  inline Slot_Removal* New() const PROTOBUF_FINAL { return New(NULL); }

  Slot_Removal* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Slot_Removal& from);
  void MergeFrom(const Slot_Removal& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Slot_Removal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .communicator.MFTDMA_Slot slot = 2;
  bool has_slot() const;
  void clear_slot();
  static const int kSlotFieldNumber = 2;
  const ::communicator::MFTDMA_Slot& slot() const;
  ::communicator::MFTDMA_Slot* mutable_slot();
  ::communicator::MFTDMA_Slot* release_slot();
  void set_allocated_slot(::communicator::MFTDMA_Slot* slot);

  // uint64 mac = 1;
  void clear_mac();
  static const int kMacFieldNumber = 1;
  ::google::protobuf::uint64 mac() const;
  void set_mac(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:communicator.Slot_Removal)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::communicator::MFTDMA_Slot* slot_;
  ::google::protobuf::uint64 mac_;
  mutable int _cached_size_;
  friend struct protobuf_interf_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Slot_Move : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:communicator.Slot_Move) */ {
 public:
  Slot_Move();
  virtual ~Slot_Move();

  Slot_Move(const Slot_Move& from);

  inline Slot_Move& operator=(const Slot_Move& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Slot_Move& default_instance();

  static inline const Slot_Move* internal_default_instance() {
    return reinterpret_cast<const Slot_Move*>(
               &_Slot_Move_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void Swap(Slot_Move* other);

  // implements Message ----------------------------------------------

  inline Slot_Move* New() const PROTOBUF_FINAL { return New(NULL); }

  Slot_Move* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Slot_Move& from);
  void MergeFrom(const Slot_Move& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Slot_Move* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .communicator.MFTDMA_Slot old_slot = 2;
  bool has_old_slot() const;
  void clear_old_slot();
  static const int kOldSlotFieldNumber = 2;
  const ::communicator::MFTDMA_Slot& old_slot() const;
  ::communicator::MFTDMA_Slot* mutable_old_slot();
  ::communicator::MFTDMA_Slot* release_old_slot();
  void set_allocated_old_slot(::communicator::MFTDMA_Slot* old_slot);

  // .communicator.MFTDMA_Slot new_slot = 3;
  bool has_new_slot() const;
  void clear_new_slot();
  static const int kNewSlotFieldNumber = 3;
  const ::communicator::MFTDMA_Slot& new_slot() const;
  ::communicator::MFTDMA_Slot* mutable_new_slot();
  ::communicator::MFTDMA_Slot* release_new_slot();
  void set_allocated_new_slot(::communicator::MFTDMA_Slot* new_slot);

  // uint64 mac = 1;
  void clear_mac();
  static const int kMacFieldNumber = 1;
  ::google::protobuf::uint64 mac() const;
  void set_mac(::google::protobuf::uint64 value);

  // .communicator.SLOT_MODE mode = 4;
  void clear_mode();
  static const int kModeFieldNumber = 4;
  ::communicator::SLOT_MODE mode() const;
  void set_mode(::communicator::SLOT_MODE value);

  // @@protoc_insertion_point(class_scope:communicator.Slot_Move)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::communicator::MFTDMA_Slot* old_slot_;
  ::communicator::MFTDMA_Slot* new_slot_;
  ::google::protobuf::uint64 mac_;
  int mode_;
  mutable int _cached_size_;
  friend struct protobuf_interf_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class External_Slot_Move : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:communicator.External_Slot_Move) */ {
 public:
  External_Slot_Move();
  virtual ~External_Slot_Move();

  External_Slot_Move(const External_Slot_Move& from);

  inline External_Slot_Move& operator=(const External_Slot_Move& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const External_Slot_Move& default_instance();

  static inline const External_Slot_Move* internal_default_instance() {
    return reinterpret_cast<const External_Slot_Move*>(
               &_External_Slot_Move_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    29;

  void Swap(External_Slot_Move* other);

  // implements Message ----------------------------------------------

  inline External_Slot_Move* New() const PROTOBUF_FINAL { return New(NULL); }

  External_Slot_Move* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const External_Slot_Move& from);
  void MergeFrom(const External_Slot_Move& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(External_Slot_Move* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .communicator.MFTDMA_Slot old_slot = 3;
  bool has_old_slot() const;
  void clear_old_slot();
  static const int kOldSlotFieldNumber = 3;
  const ::communicator::MFTDMA_Slot& old_slot() const;
  ::communicator::MFTDMA_Slot* mutable_old_slot();
  ::communicator::MFTDMA_Slot* release_old_slot();
  void set_allocated_old_slot(::communicator::MFTDMA_Slot* old_slot);

  // .communicator.MFTDMA_Slot new_slot = 4;
  bool has_new_slot() const;
  void clear_new_slot();
  static const int kNewSlotFieldNumber = 4;
  const ::communicator::MFTDMA_Slot& new_slot() const;
  ::communicator::MFTDMA_Slot* mutable_new_slot();
  ::communicator::MFTDMA_Slot* release_new_slot();
  void set_allocated_new_slot(::communicator::MFTDMA_Slot* new_slot);

  // uint64 src_mac = 1;
  void clear_src_mac();
  static const int kSrcMacFieldNumber = 1;
  ::google::protobuf::uint64 src_mac() const;
  void set_src_mac(::google::protobuf::uint64 value);

  // uint64 dst_mac = 2;
  void clear_dst_mac();
  static const int kDstMacFieldNumber = 2;
  ::google::protobuf::uint64 dst_mac() const;
  void set_dst_mac(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:communicator.External_Slot_Move)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::communicator::MFTDMA_Slot* old_slot_;
  ::communicator::MFTDMA_Slot* new_slot_;
  ::google::protobuf::uint64 src_mac_;
  ::google::protobuf::uint64 dst_mac_;
  mutable int _cached_size_;
  friend struct protobuf_interf_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Get : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:communicator.Get) */ {
 public:
  Get();
  virtual ~Get();

  Get(const Get& from);

  inline Get& operator=(const Get& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Get& default_instance();

  enum PayloadCase {
    kSlotRequest = 2,
    kProposedSlots = 3,
    kProposedMoveSlots = 4,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const Get* internal_default_instance() {
    return reinterpret_cast<const Get*>(
               &_Get_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    30;

  void Swap(Get* other);

  // implements Message ----------------------------------------------

  inline Get* New() const PROTOBUF_FINAL { return New(NULL); }

  Get* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Get& from);
  void MergeFrom(const Get& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Get* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Get_GET_ATTRIBUTE GET_ATTRIBUTE;
  static const GET_ATTRIBUTE ATTRIBUTE_UNKNOWN =
    Get_GET_ATTRIBUTE_ATTRIBUTE_UNKNOWN;
  static const GET_ATTRIBUTE PHY_BASIC_CONTROL =
    Get_GET_ATTRIBUTE_PHY_BASIC_CONTROL;
  static const GET_ATTRIBUTE MAC_STATS =
    Get_GET_ATTRIBUTE_MAC_STATS;
  static const GET_ATTRIBUTE PROPOSED_SLOTS =
    Get_GET_ATTRIBUTE_PROPOSED_SLOTS;
  static const GET_ATTRIBUTE SELECTED_SLOT =
    Get_GET_ATTRIBUTE_SELECTED_SLOT;
  static const GET_ATTRIBUTE SELECTED_MOVE_SLOT =
    Get_GET_ATTRIBUTE_SELECTED_MOVE_SLOT;
  static inline bool GET_ATTRIBUTE_IsValid(int value) {
    return Get_GET_ATTRIBUTE_IsValid(value);
  }
  static const GET_ATTRIBUTE GET_ATTRIBUTE_MIN =
    Get_GET_ATTRIBUTE_GET_ATTRIBUTE_MIN;
  static const GET_ATTRIBUTE GET_ATTRIBUTE_MAX =
    Get_GET_ATTRIBUTE_GET_ATTRIBUTE_MAX;
  static const int GET_ATTRIBUTE_ARRAYSIZE =
    Get_GET_ATTRIBUTE_GET_ATTRIBUTE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GET_ATTRIBUTE_descriptor() {
    return Get_GET_ATTRIBUTE_descriptor();
  }
  static inline const ::std::string& GET_ATTRIBUTE_Name(GET_ATTRIBUTE value) {
    return Get_GET_ATTRIBUTE_Name(value);
  }
  static inline bool GET_ATTRIBUTE_Parse(const ::std::string& name,
      GET_ATTRIBUTE* value) {
    return Get_GET_ATTRIBUTE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .communicator.Get.GET_ATTRIBUTE attribute = 1;
  void clear_attribute();
  static const int kAttributeFieldNumber = 1;
  ::communicator::Get_GET_ATTRIBUTE attribute() const;
  void set_attribute(::communicator::Get_GET_ATTRIBUTE value);

  // .communicator.Proposed_Slots_Request slot_request = 2;
  bool has_slot_request() const;
  void clear_slot_request();
  static const int kSlotRequestFieldNumber = 2;
  const ::communicator::Proposed_Slots_Request& slot_request() const;
  ::communicator::Proposed_Slots_Request* mutable_slot_request();
  ::communicator::Proposed_Slots_Request* release_slot_request();
  void set_allocated_slot_request(::communicator::Proposed_Slots_Request* slot_request);

  // .communicator.Proposed_Slots proposed_slots = 3;
  bool has_proposed_slots() const;
  void clear_proposed_slots();
  static const int kProposedSlotsFieldNumber = 3;
  const ::communicator::Proposed_Slots& proposed_slots() const;
  ::communicator::Proposed_Slots* mutable_proposed_slots();
  ::communicator::Proposed_Slots* release_proposed_slots();
  void set_allocated_proposed_slots(::communicator::Proposed_Slots* proposed_slots);

  // .communicator.Proposed_Move_Slots proposed_move_slots = 4;
  bool has_proposed_move_slots() const;
  void clear_proposed_move_slots();
  static const int kProposedMoveSlotsFieldNumber = 4;
  const ::communicator::Proposed_Move_Slots& proposed_move_slots() const;
  ::communicator::Proposed_Move_Slots* mutable_proposed_move_slots();
  ::communicator::Proposed_Move_Slots* release_proposed_move_slots();
  void set_allocated_proposed_move_slots(::communicator::Proposed_Move_Slots* proposed_move_slots);

  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:communicator.Get)
 private:
  void set_has_slot_request();
  void set_has_proposed_slots();
  void set_has_proposed_move_slots();

  inline bool has_payload() const;
  void clear_payload();
  inline void clear_has_payload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int attribute_;
  union PayloadUnion {
    PayloadUnion() {}
    ::communicator::Proposed_Slots_Request* slot_request_;
    ::communicator::Proposed_Slots* proposed_slots_;
    ::communicator::Proposed_Move_Slots* proposed_move_slots_;
  } payload_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_interf_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Get_r : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:communicator.Get_r) */ {
 public:
  Get_r();
  virtual ~Get_r();

  Get_r(const Get_r& from);

  inline Get_r& operator=(const Get_r& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Get_r& default_instance();

  enum PayloadCase {
    kMacStat = 1,
    kBasicCtrl = 2,
    kProposedSlots = 3,
    kSelectedSlot = 4,
    kSelectedMoveSlot = 5,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const Get_r* internal_default_instance() {
    return reinterpret_cast<const Get_r*>(
               &_Get_r_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    31;

  void Swap(Get_r* other);

  // implements Message ----------------------------------------------

  inline Get_r* New() const PROTOBUF_FINAL { return New(NULL); }

  Get_r* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Get_r& from);
  void MergeFrom(const Get_r& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Get_r* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .communicator.Mac_stat mac_stat = 1;
  bool has_mac_stat() const;
  void clear_mac_stat();
  static const int kMacStatFieldNumber = 1;
  const ::communicator::Mac_stat& mac_stat() const;
  ::communicator::Mac_stat* mutable_mac_stat();
  ::communicator::Mac_stat* release_mac_stat();
  void set_allocated_mac_stat(::communicator::Mac_stat* mac_stat);

  // .communicator.Basic_ctrl basic_ctrl = 2;
  bool has_basic_ctrl() const;
  void clear_basic_ctrl();
  static const int kBasicCtrlFieldNumber = 2;
  const ::communicator::Basic_ctrl& basic_ctrl() const;
  ::communicator::Basic_ctrl* mutable_basic_ctrl();
  ::communicator::Basic_ctrl* release_basic_ctrl();
  void set_allocated_basic_ctrl(::communicator::Basic_ctrl* basic_ctrl);

  // .communicator.Proposed_Slots proposed_slots = 3;
  bool has_proposed_slots() const;
  void clear_proposed_slots();
  static const int kProposedSlotsFieldNumber = 3;
  const ::communicator::Proposed_Slots& proposed_slots() const;
  ::communicator::Proposed_Slots* mutable_proposed_slots();
  ::communicator::Proposed_Slots* release_proposed_slots();
  void set_allocated_proposed_slots(::communicator::Proposed_Slots* proposed_slots);

  // .communicator.Selected_Slot selected_slot = 4;
  bool has_selected_slot() const;
  void clear_selected_slot();
  static const int kSelectedSlotFieldNumber = 4;
  const ::communicator::Selected_Slot& selected_slot() const;
  ::communicator::Selected_Slot* mutable_selected_slot();
  ::communicator::Selected_Slot* release_selected_slot();
  void set_allocated_selected_slot(::communicator::Selected_Slot* selected_slot);

  // .communicator.Selected_Move_Slot selected_move_slot = 5;
  bool has_selected_move_slot() const;
  void clear_selected_move_slot();
  static const int kSelectedMoveSlotFieldNumber = 5;
  const ::communicator::Selected_Move_Slot& selected_move_slot() const;
  ::communicator::Selected_Move_Slot* mutable_selected_move_slot();
  ::communicator::Selected_Move_Slot* release_selected_move_slot();
  void set_allocated_selected_move_slot(::communicator::Selected_Move_Slot* selected_move_slot);

  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:communicator.Get_r)
 private:
  void set_has_mac_stat();
  void set_has_basic_ctrl();
  void set_has_proposed_slots();
  void set_has_selected_slot();
  void set_has_selected_move_slot();

  inline bool has_payload() const;
  void clear_payload();
  inline void clear_has_payload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union PayloadUnion {
    PayloadUnion() {}
    ::communicator::Mac_stat* mac_stat_;
    ::communicator::Basic_ctrl* basic_ctrl_;
    ::communicator::Proposed_Slots* proposed_slots_;
    ::communicator::Selected_Slot* selected_slot_;
    ::communicator::Selected_Move_Slot* selected_move_slot_;
  } payload_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_interf_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Set : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:communicator.Set) */ {
 public:
  Set();
  virtual ~Set();

  Set(const Set& from);

  inline Set& operator=(const Set& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Set& default_instance();

  enum PayloadCase {
    kMcsTxgainBw = 1,
    kCh = 2,
    kExternalSlotAllocation = 3,
    kExternalSlotRemoval = 4,
    kSlotAllocation = 5,
    kSlotRemoval = 6,
    kBcSlotsAnnouncement = 7,
    kOutcomesUpdated = 8,
    kExternalSlotMove = 9,
    kProposedMoveSlots = 10,
    kSlotMove = 11,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const Set* internal_default_instance() {
    return reinterpret_cast<const Set*>(
               &_Set_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    32;

  void Swap(Set* other);

  // implements Message ----------------------------------------------

  inline Set* New() const PROTOBUF_FINAL { return New(NULL); }

  Set* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Set& from);
  void MergeFrom(const Set& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Set* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .communicator.Link_MCS_TxGain_BW mcs_txgain_bw = 1;
  bool has_mcs_txgain_bw() const;
  void clear_mcs_txgain_bw();
  static const int kMcsTxgainBwFieldNumber = 1;
  const ::communicator::Link_MCS_TxGain_BW& mcs_txgain_bw() const;
  ::communicator::Link_MCS_TxGain_BW* mutable_mcs_txgain_bw();
  ::communicator::Link_MCS_TxGain_BW* release_mcs_txgain_bw();
  void set_allocated_mcs_txgain_bw(::communicator::Link_MCS_TxGain_BW* mcs_txgain_bw);

  // uint32 ch = 2;
  private:
  bool has_ch() const;
  public:
  void clear_ch();
  static const int kChFieldNumber = 2;
  ::google::protobuf::uint32 ch() const;
  void set_ch(::google::protobuf::uint32 value);

  // .communicator.External_Slot_Allocation external_slot_allocation = 3;
  bool has_external_slot_allocation() const;
  void clear_external_slot_allocation();
  static const int kExternalSlotAllocationFieldNumber = 3;
  const ::communicator::External_Slot_Allocation& external_slot_allocation() const;
  ::communicator::External_Slot_Allocation* mutable_external_slot_allocation();
  ::communicator::External_Slot_Allocation* release_external_slot_allocation();
  void set_allocated_external_slot_allocation(::communicator::External_Slot_Allocation* external_slot_allocation);

  // .communicator.External_Slot_Removal external_slot_removal = 4;
  bool has_external_slot_removal() const;
  void clear_external_slot_removal();
  static const int kExternalSlotRemovalFieldNumber = 4;
  const ::communicator::External_Slot_Removal& external_slot_removal() const;
  ::communicator::External_Slot_Removal* mutable_external_slot_removal();
  ::communicator::External_Slot_Removal* release_external_slot_removal();
  void set_allocated_external_slot_removal(::communicator::External_Slot_Removal* external_slot_removal);

  // .communicator.Slot_Allocation slot_allocation = 5;
  bool has_slot_allocation() const;
  void clear_slot_allocation();
  static const int kSlotAllocationFieldNumber = 5;
  const ::communicator::Slot_Allocation& slot_allocation() const;
  ::communicator::Slot_Allocation* mutable_slot_allocation();
  ::communicator::Slot_Allocation* release_slot_allocation();
  void set_allocated_slot_allocation(::communicator::Slot_Allocation* slot_allocation);

  // .communicator.Slot_Removal slot_removal = 6;
  bool has_slot_removal() const;
  void clear_slot_removal();
  static const int kSlotRemovalFieldNumber = 6;
  const ::communicator::Slot_Removal& slot_removal() const;
  ::communicator::Slot_Removal* mutable_slot_removal();
  ::communicator::Slot_Removal* release_slot_removal();
  void set_allocated_slot_removal(::communicator::Slot_Removal* slot_removal);

  // .communicator.BC_Slots_Announcement bc_slots_announcement = 7;
  bool has_bc_slots_announcement() const;
  void clear_bc_slots_announcement();
  static const int kBcSlotsAnnouncementFieldNumber = 7;
  const ::communicator::BC_Slots_Announcement& bc_slots_announcement() const;
  ::communicator::BC_Slots_Announcement* mutable_bc_slots_announcement();
  ::communicator::BC_Slots_Announcement* release_bc_slots_announcement();
  void set_allocated_bc_slots_announcement(::communicator::BC_Slots_Announcement* bc_slots_announcement);

  // bool outcomes_updated = 8;
  private:
  bool has_outcomes_updated() const;
  public:
  void clear_outcomes_updated();
  static const int kOutcomesUpdatedFieldNumber = 8;
  bool outcomes_updated() const;
  void set_outcomes_updated(bool value);

  // .communicator.External_Slot_Move external_slot_move = 9;
  bool has_external_slot_move() const;
  void clear_external_slot_move();
  static const int kExternalSlotMoveFieldNumber = 9;
  const ::communicator::External_Slot_Move& external_slot_move() const;
  ::communicator::External_Slot_Move* mutable_external_slot_move();
  ::communicator::External_Slot_Move* release_external_slot_move();
  void set_allocated_external_slot_move(::communicator::External_Slot_Move* external_slot_move);

  // .communicator.Proposed_Move_Slots proposed_move_slots = 10;
  bool has_proposed_move_slots() const;
  void clear_proposed_move_slots();
  static const int kProposedMoveSlotsFieldNumber = 10;
  const ::communicator::Proposed_Move_Slots& proposed_move_slots() const;
  ::communicator::Proposed_Move_Slots* mutable_proposed_move_slots();
  ::communicator::Proposed_Move_Slots* release_proposed_move_slots();
  void set_allocated_proposed_move_slots(::communicator::Proposed_Move_Slots* proposed_move_slots);

  // .communicator.Slot_Move slot_move = 11;
  bool has_slot_move() const;
  void clear_slot_move();
  static const int kSlotMoveFieldNumber = 11;
  const ::communicator::Slot_Move& slot_move() const;
  ::communicator::Slot_Move* mutable_slot_move();
  ::communicator::Slot_Move* release_slot_move();
  void set_allocated_slot_move(::communicator::Slot_Move* slot_move);

  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:communicator.Set)
 private:
  void set_has_mcs_txgain_bw();
  void set_has_ch();
  void set_has_external_slot_allocation();
  void set_has_external_slot_removal();
  void set_has_slot_allocation();
  void set_has_slot_removal();
  void set_has_bc_slots_announcement();
  void set_has_outcomes_updated();
  void set_has_external_slot_move();
  void set_has_proposed_move_slots();
  void set_has_slot_move();

  inline bool has_payload() const;
  void clear_payload();
  inline void clear_has_payload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union PayloadUnion {
    PayloadUnion() {}
    ::communicator::Link_MCS_TxGain_BW* mcs_txgain_bw_;
    ::google::protobuf::uint32 ch_;
    ::communicator::External_Slot_Allocation* external_slot_allocation_;
    ::communicator::External_Slot_Removal* external_slot_removal_;
    ::communicator::Slot_Allocation* slot_allocation_;
    ::communicator::Slot_Removal* slot_removal_;
    ::communicator::BC_Slots_Announcement* bc_slots_announcement_;
    bool outcomes_updated_;
    ::communicator::External_Slot_Move* external_slot_move_;
    ::communicator::Proposed_Move_Slots* proposed_move_slots_;
    ::communicator::Slot_Move* slot_move_;
  } payload_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_interf_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Set_r : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:communicator.Set_r) */ {
 public:
  Set_r();
  virtual ~Set_r();

  Set_r(const Set_r& from);

  inline Set_r& operator=(const Set_r& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Set_r& default_instance();

  static inline const Set_r* internal_default_instance() {
    return reinterpret_cast<const Set_r*>(
               &_Set_r_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    33;

  void Swap(Set_r* other);

  // implements Message ----------------------------------------------

  inline Set_r* New() const PROTOBUF_FINAL { return New(NULL); }

  Set_r* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Set_r& from);
  void MergeFrom(const Set_r& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Set_r* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .communicator.TRANSACTION_RESULT result = 1;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::communicator::TRANSACTION_RESULT result() const;
  void set_result(::communicator::TRANSACTION_RESULT value);

  // @@protoc_insertion_point(class_scope:communicator.Set_r)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int result_;
  mutable int _cached_size_;
  friend struct protobuf_interf_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Send : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:communicator.Send) */ {
 public:
  Send();
  virtual ~Send();

  Send(const Send& from);

  inline Send& operator=(const Send& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Send& default_instance();

  static inline const Send* internal_default_instance() {
    return reinterpret_cast<const Send*>(
               &_Send_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    34;

  void Swap(Send* other);

  // implements Message ----------------------------------------------

  inline Send* New() const PROTOBUF_FINAL { return New(NULL); }

  Send* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Send& from);
  void MergeFrom(const Send& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Send* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .communicator.Application_data app_data = 1;
  bool has_app_data() const;
  void clear_app_data();
  static const int kAppDataFieldNumber = 1;
  const ::communicator::Application_data& app_data() const;
  ::communicator::Application_data* mutable_app_data();
  ::communicator::Application_data* release_app_data();
  void set_allocated_app_data(::communicator::Application_data* app_data);

  // .communicator.Basic_ctrl basic_ctrl = 2;
  bool has_basic_ctrl() const;
  void clear_basic_ctrl();
  static const int kBasicCtrlFieldNumber = 2;
  const ::communicator::Basic_ctrl& basic_ctrl() const;
  ::communicator::Basic_ctrl* mutable_basic_ctrl();
  ::communicator::Basic_ctrl* release_basic_ctrl();
  void set_allocated_basic_ctrl(::communicator::Basic_ctrl* basic_ctrl);

  // @@protoc_insertion_point(class_scope:communicator.Send)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::communicator::Application_data* app_data_;
  ::communicator::Basic_ctrl* basic_ctrl_;
  mutable int _cached_size_;
  friend struct protobuf_interf_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Send_r : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:communicator.Send_r) */ {
 public:
  Send_r();
  virtual ~Send_r();

  Send_r(const Send_r& from);

  inline Send_r& operator=(const Send_r& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Send_r& default_instance();

  enum PayloadCase {
    kPhyStat = 2,
    kMacResult = 3,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const Send_r* internal_default_instance() {
    return reinterpret_cast<const Send_r*>(
               &_Send_r_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    35;

  void Swap(Send_r* other);

  // implements Message ----------------------------------------------

  inline Send_r* New() const PROTOBUF_FINAL { return New(NULL); }

  Send_r* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Send_r& from);
  void MergeFrom(const Send_r& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Send_r* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .communicator.TRANSACTION_RESULT result = 1;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::communicator::TRANSACTION_RESULT result() const;
  void set_result(::communicator::TRANSACTION_RESULT value);

  // .communicator.Phy_stat phy_stat = 2;
  bool has_phy_stat() const;
  void clear_phy_stat();
  static const int kPhyStatFieldNumber = 2;
  const ::communicator::Phy_stat& phy_stat() const;
  ::communicator::Phy_stat* mutable_phy_stat();
  ::communicator::Phy_stat* release_phy_stat();
  void set_allocated_phy_stat(::communicator::Phy_stat* phy_stat);

  // .communicator.Mac_stat mac_result = 3;
  bool has_mac_result() const;
  void clear_mac_result();
  static const int kMacResultFieldNumber = 3;
  const ::communicator::Mac_stat& mac_result() const;
  ::communicator::Mac_stat* mutable_mac_result();
  ::communicator::Mac_stat* release_mac_result();
  void set_allocated_mac_result(::communicator::Mac_stat* mac_result);

  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:communicator.Send_r)
 private:
  void set_has_phy_stat();
  void set_has_mac_result();

  inline bool has_payload() const;
  void clear_payload();
  inline void clear_has_payload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int result_;
  union PayloadUnion {
    PayloadUnion() {}
    ::communicator::Phy_stat* phy_stat_;
    ::communicator::Mac_stat* mac_result_;
  } payload_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_interf_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Receive : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:communicator.Receive) */ {
 public:
  Receive();
  virtual ~Receive();

  Receive(const Receive& from);

  inline Receive& operator=(const Receive& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Receive& default_instance();

  enum PayloadCase {
    kBasicCtrl = 1,
    kData = 2,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const Receive* internal_default_instance() {
    return reinterpret_cast<const Receive*>(
               &_Receive_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    36;

  void Swap(Receive* other);

  // implements Message ----------------------------------------------

  inline Receive* New() const PROTOBUF_FINAL { return New(NULL); }

  Receive* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Receive& from);
  void MergeFrom(const Receive& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Receive* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .communicator.Basic_ctrl basic_ctrl = 1;
  bool has_basic_ctrl() const;
  void clear_basic_ctrl();
  static const int kBasicCtrlFieldNumber = 1;
  const ::communicator::Basic_ctrl& basic_ctrl() const;
  ::communicator::Basic_ctrl* mutable_basic_ctrl();
  ::communicator::Basic_ctrl* release_basic_ctrl();
  void set_allocated_basic_ctrl(::communicator::Basic_ctrl* basic_ctrl);

  // bytes data = 2;
  private:
  bool has_data() const;
  public:
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:communicator.Receive)
 private:
  void set_has_basic_ctrl();
  void set_has_data();

  inline bool has_payload() const;
  void clear_payload();
  inline void clear_has_payload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union PayloadUnion {
    PayloadUnion() {}
    ::communicator::Basic_ctrl* basic_ctrl_;
    ::google::protobuf::internal::ArenaStringPtr data_;
  } payload_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_interf_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Receive_r : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:communicator.Receive_r) */ {
 public:
  Receive_r();
  virtual ~Receive_r();

  Receive_r(const Receive_r& from);

  inline Receive_r& operator=(const Receive_r& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Receive_r& default_instance();

  static inline const Receive_r* internal_default_instance() {
    return reinterpret_cast<const Receive_r*>(
               &_Receive_r_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    37;

  void Swap(Receive_r* other);

  // implements Message ----------------------------------------------

  inline Receive_r* New() const PROTOBUF_FINAL { return New(NULL); }

  Receive_r* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Receive_r& from);
  void MergeFrom(const Receive_r& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Receive_r* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes data = 2;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // .communicator.Phy_stat stat = 3;
  bool has_stat() const;
  void clear_stat();
  static const int kStatFieldNumber = 3;
  const ::communicator::Phy_stat& stat() const;
  ::communicator::Phy_stat* mutable_stat();
  ::communicator::Phy_stat* release_stat();
  void set_allocated_stat(::communicator::Phy_stat* stat);

  // .communicator.TRANSACTION_RESULT result = 1;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::communicator::TRANSACTION_RESULT result() const;
  void set_result(::communicator::TRANSACTION_RESULT value);

  // @@protoc_insertion_point(class_scope:communicator.Receive_r)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::communicator::Phy_stat* stat_;
  int result_;
  mutable int _cached_size_;
  friend struct protobuf_interf_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Stats : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:communicator.Stats) */ {
 public:
  Stats();
  virtual ~Stats();

  Stats(const Stats& from);

  inline Stats& operator=(const Stats& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Stats& default_instance();

  static inline const Stats* internal_default_instance() {
    return reinterpret_cast<const Stats*>(
               &_Stats_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    38;

  void Swap(Stats* other);

  // implements Message ----------------------------------------------

  inline Stats* New() const PROTOBUF_FINAL { return New(NULL); }

  Stats* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Stats& from);
  void MergeFrom(const Stats& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Stats* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .communicator.Phy_stat phy_stat = 2;
  bool has_phy_stat() const;
  void clear_phy_stat();
  static const int kPhyStatFieldNumber = 2;
  const ::communicator::Phy_stat& phy_stat() const;
  ::communicator::Phy_stat* mutable_phy_stat();
  ::communicator::Phy_stat* release_phy_stat();
  void set_allocated_phy_stat(::communicator::Phy_stat* phy_stat);

  // .communicator.Mac_stat mac_stat = 3;
  bool has_mac_stat() const;
  void clear_mac_stat();
  static const int kMacStatFieldNumber = 3;
  const ::communicator::Mac_stat& mac_stat() const;
  ::communicator::Mac_stat* mutable_mac_stat();
  ::communicator::Mac_stat* release_mac_stat();
  void set_allocated_mac_stat(::communicator::Mac_stat* mac_stat);

  // uint64 mac_address = 1;
  void clear_mac_address();
  static const int kMacAddressFieldNumber = 1;
  ::google::protobuf::uint64 mac_address() const;
  void set_mac_address(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:communicator.Stats)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::communicator::Phy_stat* phy_stat_;
  ::communicator::Mac_stat* mac_stat_;
  ::google::protobuf::uint64 mac_address_;
  mutable int _cached_size_;
  friend struct protobuf_interf_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Internal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:communicator.Internal) */ {
 public:
  Internal();
  virtual ~Internal();

  Internal(const Internal& from);

  inline Internal& operator=(const Internal& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Internal& default_instance();

  enum PayloadCase {
    kGet = 3,
    kGetr = 4,
    kSet = 5,
    kSetr = 6,
    kSend = 7,
    kSendr = 8,
    kReceive = 9,
    kReceiver = 10,
    kStats = 11,
    kExternalAImessage = 12,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const Internal* internal_default_instance() {
    return reinterpret_cast<const Internal*>(
               &_Internal_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    39;

  void Swap(Internal* other);

  // implements Message ----------------------------------------------

  inline Internal* New() const PROTOBUF_FINAL { return New(NULL); }

  Internal* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Internal& from);
  void MergeFrom(const Internal& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Internal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 transaction_index = 1;
  void clear_transaction_index();
  static const int kTransactionIndexFieldNumber = 1;
  ::google::protobuf::uint64 transaction_index() const;
  void set_transaction_index(::google::protobuf::uint64 value);

  // .communicator.MODULE owner_module = 2;
  void clear_owner_module();
  static const int kOwnerModuleFieldNumber = 2;
  ::communicator::MODULE owner_module() const;
  void set_owner_module(::communicator::MODULE value);

  // .communicator.Get get = 3;
  bool has_get() const;
  void clear_get();
  static const int kGetFieldNumber = 3;
  const ::communicator::Get& get() const;
  ::communicator::Get* mutable_get();
  ::communicator::Get* release_get();
  void set_allocated_get(::communicator::Get* get);

  // .communicator.Get_r getr = 4;
  bool has_getr() const;
  void clear_getr();
  static const int kGetrFieldNumber = 4;
  const ::communicator::Get_r& getr() const;
  ::communicator::Get_r* mutable_getr();
  ::communicator::Get_r* release_getr();
  void set_allocated_getr(::communicator::Get_r* getr);

  // .communicator.Set set = 5;
  bool has_set() const;
  void clear_set();
  static const int kSetFieldNumber = 5;
  const ::communicator::Set& set() const;
  ::communicator::Set* mutable_set();
  ::communicator::Set* release_set();
  void set_allocated_set(::communicator::Set* set);

  // .communicator.Set_r setr = 6;
  bool has_setr() const;
  void clear_setr();
  static const int kSetrFieldNumber = 6;
  const ::communicator::Set_r& setr() const;
  ::communicator::Set_r* mutable_setr();
  ::communicator::Set_r* release_setr();
  void set_allocated_setr(::communicator::Set_r* setr);

  // .communicator.Send send = 7;
  bool has_send() const;
  void clear_send();
  static const int kSendFieldNumber = 7;
  const ::communicator::Send& send() const;
  ::communicator::Send* mutable_send();
  ::communicator::Send* release_send();
  void set_allocated_send(::communicator::Send* send);

  // .communicator.Send_r sendr = 8;
  bool has_sendr() const;
  void clear_sendr();
  static const int kSendrFieldNumber = 8;
  const ::communicator::Send_r& sendr() const;
  ::communicator::Send_r* mutable_sendr();
  ::communicator::Send_r* release_sendr();
  void set_allocated_sendr(::communicator::Send_r* sendr);

  // .communicator.Receive receive = 9;
  bool has_receive() const;
  void clear_receive();
  static const int kReceiveFieldNumber = 9;
  const ::communicator::Receive& receive() const;
  ::communicator::Receive* mutable_receive();
  ::communicator::Receive* release_receive();
  void set_allocated_receive(::communicator::Receive* receive);

  // .communicator.Receive_r receiver = 10;
  bool has_receiver() const;
  void clear_receiver();
  static const int kReceiverFieldNumber = 10;
  const ::communicator::Receive_r& receiver() const;
  ::communicator::Receive_r* mutable_receiver();
  ::communicator::Receive_r* release_receiver();
  void set_allocated_receiver(::communicator::Receive_r* receiver);

  // .communicator.Stats stats = 11;
  bool has_stats() const;
  void clear_stats();
  static const int kStatsFieldNumber = 11;
  const ::communicator::Stats& stats() const;
  ::communicator::Stats* mutable_stats();
  ::communicator::Stats* release_stats();
  void set_allocated_stats(::communicator::Stats* stats);

  // .aiCommunicator.InternalAI externalAImessage = 12;
  bool has_externalaimessage() const;
  void clear_externalaimessage();
  static const int kExternalAImessageFieldNumber = 12;
  const ::aiCommunicator::InternalAI& externalaimessage() const;
  ::aiCommunicator::InternalAI* mutable_externalaimessage();
  ::aiCommunicator::InternalAI* release_externalaimessage();
  void set_allocated_externalaimessage(::aiCommunicator::InternalAI* externalaimessage);

  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:communicator.Internal)
 private:
  void set_has_get();
  void set_has_getr();
  void set_has_set();
  void set_has_setr();
  void set_has_send();
  void set_has_sendr();
  void set_has_receive();
  void set_has_receiver();
  void set_has_stats();
  void set_has_externalaimessage();

  inline bool has_payload() const;
  void clear_payload();
  inline void clear_has_payload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 transaction_index_;
  int owner_module_;
  union PayloadUnion {
    PayloadUnion() {}
    ::communicator::Get* get_;
    ::communicator::Get_r* getr_;
    ::communicator::Set* set_;
    ::communicator::Set_r* setr_;
    ::communicator::Send* send_;
    ::communicator::Send_r* sendr_;
    ::communicator::Receive* receive_;
    ::communicator::Receive_r* receiver_;
    ::communicator::Stats* stats_;
    ::aiCommunicator::InternalAI* externalaimessage_;
  } payload_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_interf_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Basic_ctrl

// .communicator.Basic_ctrl.TRX trx_flag = 1;
inline void Basic_ctrl::clear_trx_flag() {
  trx_flag_ = 0;
}
inline ::communicator::Basic_ctrl_TRX Basic_ctrl::trx_flag() const {
  // @@protoc_insertion_point(field_get:communicator.Basic_ctrl.trx_flag)
  return static_cast< ::communicator::Basic_ctrl_TRX >(trx_flag_);
}
inline void Basic_ctrl::set_trx_flag(::communicator::Basic_ctrl_TRX value) {
  
  trx_flag_ = value;
  // @@protoc_insertion_point(field_set:communicator.Basic_ctrl.trx_flag)
}

// uint32 send_to = 2;
inline void Basic_ctrl::clear_send_to() {
  send_to_ = 0u;
}
inline ::google::protobuf::uint32 Basic_ctrl::send_to() const {
  // @@protoc_insertion_point(field_get:communicator.Basic_ctrl.send_to)
  return send_to_;
}
inline void Basic_ctrl::set_send_to(::google::protobuf::uint32 value) {
  
  send_to_ = value;
  // @@protoc_insertion_point(field_set:communicator.Basic_ctrl.send_to)
}

// .communicator.BW_INDEX bw_index = 3;
inline void Basic_ctrl::clear_bw_index() {
  bw_index_ = 0;
}
inline ::communicator::BW_INDEX Basic_ctrl::bw_index() const {
  // @@protoc_insertion_point(field_get:communicator.Basic_ctrl.bw_index)
  return static_cast< ::communicator::BW_INDEX >(bw_index_);
}
inline void Basic_ctrl::set_bw_index(::communicator::BW_INDEX value) {
  
  bw_index_ = value;
  // @@protoc_insertion_point(field_set:communicator.Basic_ctrl.bw_index)
}

// uint32 ch = 4;
inline void Basic_ctrl::clear_ch() {
  ch_ = 0u;
}
inline ::google::protobuf::uint32 Basic_ctrl::ch() const {
  // @@protoc_insertion_point(field_get:communicator.Basic_ctrl.ch)
  return ch_;
}
inline void Basic_ctrl::set_ch(::google::protobuf::uint32 value) {
  
  ch_ = value;
  // @@protoc_insertion_point(field_set:communicator.Basic_ctrl.ch)
}

// uint32 frame = 5;
inline void Basic_ctrl::clear_frame() {
  frame_ = 0u;
}
inline ::google::protobuf::uint32 Basic_ctrl::frame() const {
  // @@protoc_insertion_point(field_get:communicator.Basic_ctrl.frame)
  return frame_;
}
inline void Basic_ctrl::set_frame(::google::protobuf::uint32 value) {
  
  frame_ = value;
  // @@protoc_insertion_point(field_set:communicator.Basic_ctrl.frame)
}

// uint32 slot = 6;
inline void Basic_ctrl::clear_slot() {
  slot_ = 0u;
}
inline ::google::protobuf::uint32 Basic_ctrl::slot() const {
  // @@protoc_insertion_point(field_get:communicator.Basic_ctrl.slot)
  return slot_;
}
inline void Basic_ctrl::set_slot(::google::protobuf::uint32 value) {
  
  slot_ = value;
  // @@protoc_insertion_point(field_set:communicator.Basic_ctrl.slot)
}

// uint64 timestamp = 7;
inline void Basic_ctrl::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Basic_ctrl::timestamp() const {
  // @@protoc_insertion_point(field_get:communicator.Basic_ctrl.timestamp)
  return timestamp_;
}
inline void Basic_ctrl::set_timestamp(::google::protobuf::uint64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:communicator.Basic_ctrl.timestamp)
}

// uint32 mcs = 8;
inline void Basic_ctrl::clear_mcs() {
  mcs_ = 0u;
}
inline ::google::protobuf::uint32 Basic_ctrl::mcs() const {
  // @@protoc_insertion_point(field_get:communicator.Basic_ctrl.mcs)
  return mcs_;
}
inline void Basic_ctrl::set_mcs(::google::protobuf::uint32 value) {
  
  mcs_ = value;
  // @@protoc_insertion_point(field_set:communicator.Basic_ctrl.mcs)
}

// int32 gain = 9;
inline void Basic_ctrl::clear_gain() {
  gain_ = 0;
}
inline ::google::protobuf::int32 Basic_ctrl::gain() const {
  // @@protoc_insertion_point(field_get:communicator.Basic_ctrl.gain)
  return gain_;
}
inline void Basic_ctrl::set_gain(::google::protobuf::int32 value) {
  
  gain_ = value;
  // @@protoc_insertion_point(field_set:communicator.Basic_ctrl.gain)
}

// float rf_boost = 10;
inline void Basic_ctrl::clear_rf_boost() {
  rf_boost_ = 0;
}
inline float Basic_ctrl::rf_boost() const {
  // @@protoc_insertion_point(field_get:communicator.Basic_ctrl.rf_boost)
  return rf_boost_;
}
inline void Basic_ctrl::set_rf_boost(float value) {
  
  rf_boost_ = value;
  // @@protoc_insertion_point(field_set:communicator.Basic_ctrl.rf_boost)
}

// uint32 length = 11;
inline void Basic_ctrl::clear_length() {
  length_ = 0u;
}
inline ::google::protobuf::uint32 Basic_ctrl::length() const {
  // @@protoc_insertion_point(field_get:communicator.Basic_ctrl.length)
  return length_;
}
inline void Basic_ctrl::set_length(::google::protobuf::uint32 value) {
  
  length_ = value;
  // @@protoc_insertion_point(field_set:communicator.Basic_ctrl.length)
}

// -------------------------------------------------------------------

// Phy_tx_stat

// int32 power = 1;
inline void Phy_tx_stat::clear_power() {
  power_ = 0;
}
inline ::google::protobuf::int32 Phy_tx_stat::power() const {
  // @@protoc_insertion_point(field_get:communicator.Phy_tx_stat.power)
  return power_;
}
inline void Phy_tx_stat::set_power(::google::protobuf::int32 value) {
  
  power_ = value;
  // @@protoc_insertion_point(field_set:communicator.Phy_tx_stat.power)
}

// uint64 channel_free_cnt = 2;
inline void Phy_tx_stat::clear_channel_free_cnt() {
  channel_free_cnt_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Phy_tx_stat::channel_free_cnt() const {
  // @@protoc_insertion_point(field_get:communicator.Phy_tx_stat.channel_free_cnt)
  return channel_free_cnt_;
}
inline void Phy_tx_stat::set_channel_free_cnt(::google::protobuf::uint64 value) {
  
  channel_free_cnt_ = value;
  // @@protoc_insertion_point(field_set:communicator.Phy_tx_stat.channel_free_cnt)
}

// uint64 channel_busy_cnt = 3;
inline void Phy_tx_stat::clear_channel_busy_cnt() {
  channel_busy_cnt_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Phy_tx_stat::channel_busy_cnt() const {
  // @@protoc_insertion_point(field_get:communicator.Phy_tx_stat.channel_busy_cnt)
  return channel_busy_cnt_;
}
inline void Phy_tx_stat::set_channel_busy_cnt(::google::protobuf::uint64 value) {
  
  channel_busy_cnt_ = value;
  // @@protoc_insertion_point(field_set:communicator.Phy_tx_stat.channel_busy_cnt)
}

// float free_energy = 4;
inline void Phy_tx_stat::clear_free_energy() {
  free_energy_ = 0;
}
inline float Phy_tx_stat::free_energy() const {
  // @@protoc_insertion_point(field_get:communicator.Phy_tx_stat.free_energy)
  return free_energy_;
}
inline void Phy_tx_stat::set_free_energy(float value) {
  
  free_energy_ = value;
  // @@protoc_insertion_point(field_set:communicator.Phy_tx_stat.free_energy)
}

// float busy_energy = 5;
inline void Phy_tx_stat::clear_busy_energy() {
  busy_energy_ = 0;
}
inline float Phy_tx_stat::busy_energy() const {
  // @@protoc_insertion_point(field_get:communicator.Phy_tx_stat.busy_energy)
  return busy_energy_;
}
inline void Phy_tx_stat::set_busy_energy(float value) {
  
  busy_energy_ = value;
  // @@protoc_insertion_point(field_set:communicator.Phy_tx_stat.busy_energy)
}

// uint64 total_dropped_slots = 6;
inline void Phy_tx_stat::clear_total_dropped_slots() {
  total_dropped_slots_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Phy_tx_stat::total_dropped_slots() const {
  // @@protoc_insertion_point(field_get:communicator.Phy_tx_stat.total_dropped_slots)
  return total_dropped_slots_;
}
inline void Phy_tx_stat::set_total_dropped_slots(::google::protobuf::uint64 value) {
  
  total_dropped_slots_ = value;
  // @@protoc_insertion_point(field_set:communicator.Phy_tx_stat.total_dropped_slots)
}

// float coding_time = 7;
inline void Phy_tx_stat::clear_coding_time() {
  coding_time_ = 0;
}
inline float Phy_tx_stat::coding_time() const {
  // @@protoc_insertion_point(field_get:communicator.Phy_tx_stat.coding_time)
  return coding_time_;
}
inline void Phy_tx_stat::set_coding_time(float value) {
  
  coding_time_ = value;
  // @@protoc_insertion_point(field_set:communicator.Phy_tx_stat.coding_time)
}

// float rf_boost = 8;
inline void Phy_tx_stat::clear_rf_boost() {
  rf_boost_ = 0;
}
inline float Phy_tx_stat::rf_boost() const {
  // @@protoc_insertion_point(field_get:communicator.Phy_tx_stat.rf_boost)
  return rf_boost_;
}
inline void Phy_tx_stat::set_rf_boost(float value) {
  
  rf_boost_ = value;
  // @@protoc_insertion_point(field_set:communicator.Phy_tx_stat.rf_boost)
}

// -------------------------------------------------------------------

// Phy_rx_stat

// int32 gain = 1;
inline void Phy_rx_stat::clear_gain() {
  gain_ = 0;
}
inline ::google::protobuf::int32 Phy_rx_stat::gain() const {
  // @@protoc_insertion_point(field_get:communicator.Phy_rx_stat.gain)
  return gain_;
}
inline void Phy_rx_stat::set_gain(::google::protobuf::int32 value) {
  
  gain_ = value;
  // @@protoc_insertion_point(field_set:communicator.Phy_rx_stat.gain)
}

// uint32 cqi = 2;
inline void Phy_rx_stat::clear_cqi() {
  cqi_ = 0u;
}
inline ::google::protobuf::uint32 Phy_rx_stat::cqi() const {
  // @@protoc_insertion_point(field_get:communicator.Phy_rx_stat.cqi)
  return cqi_;
}
inline void Phy_rx_stat::set_cqi(::google::protobuf::uint32 value) {
  
  cqi_ = value;
  // @@protoc_insertion_point(field_set:communicator.Phy_rx_stat.cqi)
}

// float rssi = 3;
inline void Phy_rx_stat::clear_rssi() {
  rssi_ = 0;
}
inline float Phy_rx_stat::rssi() const {
  // @@protoc_insertion_point(field_get:communicator.Phy_rx_stat.rssi)
  return rssi_;
}
inline void Phy_rx_stat::set_rssi(float value) {
  
  rssi_ = value;
  // @@protoc_insertion_point(field_set:communicator.Phy_rx_stat.rssi)
}

// float rsrp = 4;
inline void Phy_rx_stat::clear_rsrp() {
  rsrp_ = 0;
}
inline float Phy_rx_stat::rsrp() const {
  // @@protoc_insertion_point(field_get:communicator.Phy_rx_stat.rsrp)
  return rsrp_;
}
inline void Phy_rx_stat::set_rsrp(float value) {
  
  rsrp_ = value;
  // @@protoc_insertion_point(field_set:communicator.Phy_rx_stat.rsrp)
}

// float rsrq = 5;
inline void Phy_rx_stat::clear_rsrq() {
  rsrq_ = 0;
}
inline float Phy_rx_stat::rsrq() const {
  // @@protoc_insertion_point(field_get:communicator.Phy_rx_stat.rsrq)
  return rsrq_;
}
inline void Phy_rx_stat::set_rsrq(float value) {
  
  rsrq_ = value;
  // @@protoc_insertion_point(field_set:communicator.Phy_rx_stat.rsrq)
}

// float sinr = 6;
inline void Phy_rx_stat::clear_sinr() {
  sinr_ = 0;
}
inline float Phy_rx_stat::sinr() const {
  // @@protoc_insertion_point(field_get:communicator.Phy_rx_stat.sinr)
  return sinr_;
}
inline void Phy_rx_stat::set_sinr(float value) {
  
  sinr_ = value;
  // @@protoc_insertion_point(field_set:communicator.Phy_rx_stat.sinr)
}

// uint64 detection_errors = 7;
inline void Phy_rx_stat::clear_detection_errors() {
  detection_errors_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Phy_rx_stat::detection_errors() const {
  // @@protoc_insertion_point(field_get:communicator.Phy_rx_stat.detection_errors)
  return detection_errors_;
}
inline void Phy_rx_stat::set_detection_errors(::google::protobuf::uint64 value) {
  
  detection_errors_ = value;
  // @@protoc_insertion_point(field_set:communicator.Phy_rx_stat.detection_errors)
}

// uint64 decoding_errors = 8;
inline void Phy_rx_stat::clear_decoding_errors() {
  decoding_errors_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Phy_rx_stat::decoding_errors() const {
  // @@protoc_insertion_point(field_get:communicator.Phy_rx_stat.decoding_errors)
  return decoding_errors_;
}
inline void Phy_rx_stat::set_decoding_errors(::google::protobuf::uint64 value) {
  
  decoding_errors_ = value;
  // @@protoc_insertion_point(field_set:communicator.Phy_rx_stat.decoding_errors)
}

// uint64 filler_bits_error = 9;
inline void Phy_rx_stat::clear_filler_bits_error() {
  filler_bits_error_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Phy_rx_stat::filler_bits_error() const {
  // @@protoc_insertion_point(field_get:communicator.Phy_rx_stat.filler_bits_error)
  return filler_bits_error_;
}
inline void Phy_rx_stat::set_filler_bits_error(::google::protobuf::uint64 value) {
  
  filler_bits_error_ = value;
  // @@protoc_insertion_point(field_set:communicator.Phy_rx_stat.filler_bits_error)
}

// uint64 nof_cbs_exceeds_softbuffer_size_error = 10;
inline void Phy_rx_stat::clear_nof_cbs_exceeds_softbuffer_size_error() {
  nof_cbs_exceeds_softbuffer_size_error_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Phy_rx_stat::nof_cbs_exceeds_softbuffer_size_error() const {
  // @@protoc_insertion_point(field_get:communicator.Phy_rx_stat.nof_cbs_exceeds_softbuffer_size_error)
  return nof_cbs_exceeds_softbuffer_size_error_;
}
inline void Phy_rx_stat::set_nof_cbs_exceeds_softbuffer_size_error(::google::protobuf::uint64 value) {
  
  nof_cbs_exceeds_softbuffer_size_error_ = value;
  // @@protoc_insertion_point(field_set:communicator.Phy_rx_stat.nof_cbs_exceeds_softbuffer_size_error)
}

// uint64 rate_matching_error = 11;
inline void Phy_rx_stat::clear_rate_matching_error() {
  rate_matching_error_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Phy_rx_stat::rate_matching_error() const {
  // @@protoc_insertion_point(field_get:communicator.Phy_rx_stat.rate_matching_error)
  return rate_matching_error_;
}
inline void Phy_rx_stat::set_rate_matching_error(::google::protobuf::uint64 value) {
  
  rate_matching_error_ = value;
  // @@protoc_insertion_point(field_set:communicator.Phy_rx_stat.rate_matching_error)
}

// uint64 cb_crc_error = 12;
inline void Phy_rx_stat::clear_cb_crc_error() {
  cb_crc_error_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Phy_rx_stat::cb_crc_error() const {
  // @@protoc_insertion_point(field_get:communicator.Phy_rx_stat.cb_crc_error)
  return cb_crc_error_;
}
inline void Phy_rx_stat::set_cb_crc_error(::google::protobuf::uint64 value) {
  
  cb_crc_error_ = value;
  // @@protoc_insertion_point(field_set:communicator.Phy_rx_stat.cb_crc_error)
}

// uint64 tb_crc_error = 13;
inline void Phy_rx_stat::clear_tb_crc_error() {
  tb_crc_error_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Phy_rx_stat::tb_crc_error() const {
  // @@protoc_insertion_point(field_get:communicator.Phy_rx_stat.tb_crc_error)
  return tb_crc_error_;
}
inline void Phy_rx_stat::set_tb_crc_error(::google::protobuf::uint64 value) {
  
  tb_crc_error_ = value;
  // @@protoc_insertion_point(field_set:communicator.Phy_rx_stat.tb_crc_error)
}

// float peak_value = 14;
inline void Phy_rx_stat::clear_peak_value() {
  peak_value_ = 0;
}
inline float Phy_rx_stat::peak_value() const {
  // @@protoc_insertion_point(field_get:communicator.Phy_rx_stat.peak_value)
  return peak_value_;
}
inline void Phy_rx_stat::set_peak_value(float value) {
  
  peak_value_ = value;
  // @@protoc_insertion_point(field_set:communicator.Phy_rx_stat.peak_value)
}

// float noise = 15;
inline void Phy_rx_stat::clear_noise() {
  noise_ = 0;
}
inline float Phy_rx_stat::noise() const {
  // @@protoc_insertion_point(field_get:communicator.Phy_rx_stat.noise)
  return noise_;
}
inline void Phy_rx_stat::set_noise(float value) {
  
  noise_ = value;
  // @@protoc_insertion_point(field_set:communicator.Phy_rx_stat.noise)
}

// uint32 decoded_cfi = 16;
inline void Phy_rx_stat::clear_decoded_cfi() {
  decoded_cfi_ = 0u;
}
inline ::google::protobuf::uint32 Phy_rx_stat::decoded_cfi() const {
  // @@protoc_insertion_point(field_get:communicator.Phy_rx_stat.decoded_cfi)
  return decoded_cfi_;
}
inline void Phy_rx_stat::set_decoded_cfi(::google::protobuf::uint32 value) {
  
  decoded_cfi_ = value;
  // @@protoc_insertion_point(field_set:communicator.Phy_rx_stat.decoded_cfi)
}

// bool found_dci = 17;
inline void Phy_rx_stat::clear_found_dci() {
  found_dci_ = false;
}
inline bool Phy_rx_stat::found_dci() const {
  // @@protoc_insertion_point(field_get:communicator.Phy_rx_stat.found_dci)
  return found_dci_;
}
inline void Phy_rx_stat::set_found_dci(bool value) {
  
  found_dci_ = value;
  // @@protoc_insertion_point(field_set:communicator.Phy_rx_stat.found_dci)
}

// uint32 last_noi = 18;
inline void Phy_rx_stat::clear_last_noi() {
  last_noi_ = 0u;
}
inline ::google::protobuf::uint32 Phy_rx_stat::last_noi() const {
  // @@protoc_insertion_point(field_get:communicator.Phy_rx_stat.last_noi)
  return last_noi_;
}
inline void Phy_rx_stat::set_last_noi(::google::protobuf::uint32 value) {
  
  last_noi_ = value;
  // @@protoc_insertion_point(field_set:communicator.Phy_rx_stat.last_noi)
}

// uint64 total_packets_synchronized = 19;
inline void Phy_rx_stat::clear_total_packets_synchronized() {
  total_packets_synchronized_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Phy_rx_stat::total_packets_synchronized() const {
  // @@protoc_insertion_point(field_get:communicator.Phy_rx_stat.total_packets_synchronized)
  return total_packets_synchronized_;
}
inline void Phy_rx_stat::set_total_packets_synchronized(::google::protobuf::uint64 value) {
  
  total_packets_synchronized_ = value;
  // @@protoc_insertion_point(field_set:communicator.Phy_rx_stat.total_packets_synchronized)
}

// int32 length = 20;
inline void Phy_rx_stat::clear_length() {
  length_ = 0;
}
inline ::google::protobuf::int32 Phy_rx_stat::length() const {
  // @@protoc_insertion_point(field_get:communicator.Phy_rx_stat.length)
  return length_;
}
inline void Phy_rx_stat::set_length(::google::protobuf::int32 value) {
  
  length_ = value;
  // @@protoc_insertion_point(field_set:communicator.Phy_rx_stat.length)
}

// -------------------------------------------------------------------

// Phy_sensing_stat

// float frequency = 1;
inline void Phy_sensing_stat::clear_frequency() {
  frequency_ = 0;
}
inline float Phy_sensing_stat::frequency() const {
  // @@protoc_insertion_point(field_get:communicator.Phy_sensing_stat.frequency)
  return frequency_;
}
inline void Phy_sensing_stat::set_frequency(float value) {
  
  frequency_ = value;
  // @@protoc_insertion_point(field_set:communicator.Phy_sensing_stat.frequency)
}

// float sample_rate = 2;
inline void Phy_sensing_stat::clear_sample_rate() {
  sample_rate_ = 0;
}
inline float Phy_sensing_stat::sample_rate() const {
  // @@protoc_insertion_point(field_get:communicator.Phy_sensing_stat.sample_rate)
  return sample_rate_;
}
inline void Phy_sensing_stat::set_sample_rate(float value) {
  
  sample_rate_ = value;
  // @@protoc_insertion_point(field_set:communicator.Phy_sensing_stat.sample_rate)
}

// float gain = 3;
inline void Phy_sensing_stat::clear_gain() {
  gain_ = 0;
}
inline float Phy_sensing_stat::gain() const {
  // @@protoc_insertion_point(field_get:communicator.Phy_sensing_stat.gain)
  return gain_;
}
inline void Phy_sensing_stat::set_gain(float value) {
  
  gain_ = value;
  // @@protoc_insertion_point(field_set:communicator.Phy_sensing_stat.gain)
}

// float rssi = 4;
inline void Phy_sensing_stat::clear_rssi() {
  rssi_ = 0;
}
inline float Phy_sensing_stat::rssi() const {
  // @@protoc_insertion_point(field_get:communicator.Phy_sensing_stat.rssi)
  return rssi_;
}
inline void Phy_sensing_stat::set_rssi(float value) {
  
  rssi_ = value;
  // @@protoc_insertion_point(field_set:communicator.Phy_sensing_stat.rssi)
}

// int32 length = 5;
inline void Phy_sensing_stat::clear_length() {
  length_ = 0;
}
inline ::google::protobuf::int32 Phy_sensing_stat::length() const {
  // @@protoc_insertion_point(field_get:communicator.Phy_sensing_stat.length)
  return length_;
}
inline void Phy_sensing_stat::set_length(::google::protobuf::int32 value) {
  
  length_ = value;
  // @@protoc_insertion_point(field_set:communicator.Phy_sensing_stat.length)
}

// -------------------------------------------------------------------

// Phy_stat

// uint64 host_timestamp = 1;
inline void Phy_stat::clear_host_timestamp() {
  host_timestamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Phy_stat::host_timestamp() const {
  // @@protoc_insertion_point(field_get:communicator.Phy_stat.host_timestamp)
  return host_timestamp_;
}
inline void Phy_stat::set_host_timestamp(::google::protobuf::uint64 value) {
  
  host_timestamp_ = value;
  // @@protoc_insertion_point(field_set:communicator.Phy_stat.host_timestamp)
}

// uint64 fpga_timestamp = 2;
inline void Phy_stat::clear_fpga_timestamp() {
  fpga_timestamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Phy_stat::fpga_timestamp() const {
  // @@protoc_insertion_point(field_get:communicator.Phy_stat.fpga_timestamp)
  return fpga_timestamp_;
}
inline void Phy_stat::set_fpga_timestamp(::google::protobuf::uint64 value) {
  
  fpga_timestamp_ = value;
  // @@protoc_insertion_point(field_set:communicator.Phy_stat.fpga_timestamp)
}

// uint32 frame = 3;
inline void Phy_stat::clear_frame() {
  frame_ = 0u;
}
inline ::google::protobuf::uint32 Phy_stat::frame() const {
  // @@protoc_insertion_point(field_get:communicator.Phy_stat.frame)
  return frame_;
}
inline void Phy_stat::set_frame(::google::protobuf::uint32 value) {
  
  frame_ = value;
  // @@protoc_insertion_point(field_set:communicator.Phy_stat.frame)
}

// uint32 slot = 4;
inline void Phy_stat::clear_slot() {
  slot_ = 0u;
}
inline ::google::protobuf::uint32 Phy_stat::slot() const {
  // @@protoc_insertion_point(field_get:communicator.Phy_stat.slot)
  return slot_;
}
inline void Phy_stat::set_slot(::google::protobuf::uint32 value) {
  
  slot_ = value;
  // @@protoc_insertion_point(field_set:communicator.Phy_stat.slot)
}

// uint32 ch = 5;
inline void Phy_stat::clear_ch() {
  ch_ = 0u;
}
inline ::google::protobuf::uint32 Phy_stat::ch() const {
  // @@protoc_insertion_point(field_get:communicator.Phy_stat.ch)
  return ch_;
}
inline void Phy_stat::set_ch(::google::protobuf::uint32 value) {
  
  ch_ = value;
  // @@protoc_insertion_point(field_set:communicator.Phy_stat.ch)
}

// uint32 mcs = 6;
inline void Phy_stat::clear_mcs() {
  mcs_ = 0u;
}
inline ::google::protobuf::uint32 Phy_stat::mcs() const {
  // @@protoc_insertion_point(field_get:communicator.Phy_stat.mcs)
  return mcs_;
}
inline void Phy_stat::set_mcs(::google::protobuf::uint32 value) {
  
  mcs_ = value;
  // @@protoc_insertion_point(field_set:communicator.Phy_stat.mcs)
}

// uint32 num_cb_total = 7;
inline void Phy_stat::clear_num_cb_total() {
  num_cb_total_ = 0u;
}
inline ::google::protobuf::uint32 Phy_stat::num_cb_total() const {
  // @@protoc_insertion_point(field_get:communicator.Phy_stat.num_cb_total)
  return num_cb_total_;
}
inline void Phy_stat::set_num_cb_total(::google::protobuf::uint32 value) {
  
  num_cb_total_ = value;
  // @@protoc_insertion_point(field_set:communicator.Phy_stat.num_cb_total)
}

// uint32 num_cb_err = 8;
inline void Phy_stat::clear_num_cb_err() {
  num_cb_err_ = 0u;
}
inline ::google::protobuf::uint32 Phy_stat::num_cb_err() const {
  // @@protoc_insertion_point(field_get:communicator.Phy_stat.num_cb_err)
  return num_cb_err_;
}
inline void Phy_stat::set_num_cb_err(::google::protobuf::uint32 value) {
  
  num_cb_err_ = value;
  // @@protoc_insertion_point(field_set:communicator.Phy_stat.num_cb_err)
}

// uint32 wrong_decoding_counter = 9;
inline void Phy_stat::clear_wrong_decoding_counter() {
  wrong_decoding_counter_ = 0u;
}
inline ::google::protobuf::uint32 Phy_stat::wrong_decoding_counter() const {
  // @@protoc_insertion_point(field_get:communicator.Phy_stat.wrong_decoding_counter)
  return wrong_decoding_counter_;
}
inline void Phy_stat::set_wrong_decoding_counter(::google::protobuf::uint32 value) {
  
  wrong_decoding_counter_ = value;
  // @@protoc_insertion_point(field_set:communicator.Phy_stat.wrong_decoding_counter)
}

// .communicator.Phy_tx_stat tx_stat = 10;
inline bool Phy_stat::has_tx_stat() const {
  return stat_case() == kTxStat;
}
inline void Phy_stat::set_has_tx_stat() {
  _oneof_case_[0] = kTxStat;
}
inline void Phy_stat::clear_tx_stat() {
  if (has_tx_stat()) {
    delete stat_.tx_stat_;
    clear_has_stat();
  }
}
inline  const ::communicator::Phy_tx_stat& Phy_stat::tx_stat() const {
  // @@protoc_insertion_point(field_get:communicator.Phy_stat.tx_stat)
  return has_tx_stat()
      ? *stat_.tx_stat_
      : ::communicator::Phy_tx_stat::default_instance();
}
inline ::communicator::Phy_tx_stat* Phy_stat::mutable_tx_stat() {
  if (!has_tx_stat()) {
    clear_stat();
    set_has_tx_stat();
    stat_.tx_stat_ = new ::communicator::Phy_tx_stat;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Phy_stat.tx_stat)
  return stat_.tx_stat_;
}
inline ::communicator::Phy_tx_stat* Phy_stat::release_tx_stat() {
  // @@protoc_insertion_point(field_release:communicator.Phy_stat.tx_stat)
  if (has_tx_stat()) {
    clear_has_stat();
    ::communicator::Phy_tx_stat* temp = stat_.tx_stat_;
    stat_.tx_stat_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Phy_stat::set_allocated_tx_stat(::communicator::Phy_tx_stat* tx_stat) {
  clear_stat();
  if (tx_stat) {
    set_has_tx_stat();
    stat_.tx_stat_ = tx_stat;
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Phy_stat.tx_stat)
}

// .communicator.Phy_rx_stat rx_stat = 11;
inline bool Phy_stat::has_rx_stat() const {
  return stat_case() == kRxStat;
}
inline void Phy_stat::set_has_rx_stat() {
  _oneof_case_[0] = kRxStat;
}
inline void Phy_stat::clear_rx_stat() {
  if (has_rx_stat()) {
    delete stat_.rx_stat_;
    clear_has_stat();
  }
}
inline  const ::communicator::Phy_rx_stat& Phy_stat::rx_stat() const {
  // @@protoc_insertion_point(field_get:communicator.Phy_stat.rx_stat)
  return has_rx_stat()
      ? *stat_.rx_stat_
      : ::communicator::Phy_rx_stat::default_instance();
}
inline ::communicator::Phy_rx_stat* Phy_stat::mutable_rx_stat() {
  if (!has_rx_stat()) {
    clear_stat();
    set_has_rx_stat();
    stat_.rx_stat_ = new ::communicator::Phy_rx_stat;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Phy_stat.rx_stat)
  return stat_.rx_stat_;
}
inline ::communicator::Phy_rx_stat* Phy_stat::release_rx_stat() {
  // @@protoc_insertion_point(field_release:communicator.Phy_stat.rx_stat)
  if (has_rx_stat()) {
    clear_has_stat();
    ::communicator::Phy_rx_stat* temp = stat_.rx_stat_;
    stat_.rx_stat_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Phy_stat::set_allocated_rx_stat(::communicator::Phy_rx_stat* rx_stat) {
  clear_stat();
  if (rx_stat) {
    set_has_rx_stat();
    stat_.rx_stat_ = rx_stat;
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Phy_stat.rx_stat)
}

// .communicator.Phy_sensing_stat sensing_stat = 12;
inline bool Phy_stat::has_sensing_stat() const {
  return stat_case() == kSensingStat;
}
inline void Phy_stat::set_has_sensing_stat() {
  _oneof_case_[0] = kSensingStat;
}
inline void Phy_stat::clear_sensing_stat() {
  if (has_sensing_stat()) {
    delete stat_.sensing_stat_;
    clear_has_stat();
  }
}
inline  const ::communicator::Phy_sensing_stat& Phy_stat::sensing_stat() const {
  // @@protoc_insertion_point(field_get:communicator.Phy_stat.sensing_stat)
  return has_sensing_stat()
      ? *stat_.sensing_stat_
      : ::communicator::Phy_sensing_stat::default_instance();
}
inline ::communicator::Phy_sensing_stat* Phy_stat::mutable_sensing_stat() {
  if (!has_sensing_stat()) {
    clear_stat();
    set_has_sensing_stat();
    stat_.sensing_stat_ = new ::communicator::Phy_sensing_stat;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Phy_stat.sensing_stat)
  return stat_.sensing_stat_;
}
inline ::communicator::Phy_sensing_stat* Phy_stat::release_sensing_stat() {
  // @@protoc_insertion_point(field_release:communicator.Phy_stat.sensing_stat)
  if (has_sensing_stat()) {
    clear_has_stat();
    ::communicator::Phy_sensing_stat* temp = stat_.sensing_stat_;
    stat_.sensing_stat_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Phy_stat::set_allocated_sensing_stat(::communicator::Phy_sensing_stat* sensing_stat) {
  clear_stat();
  if (sensing_stat) {
    set_has_sensing_stat();
    stat_.sensing_stat_ = sensing_stat;
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Phy_stat.sensing_stat)
}

inline bool Phy_stat::has_stat() const {
  return stat_case() != STAT_NOT_SET;
}
inline void Phy_stat::clear_has_stat() {
  _oneof_case_[0] = STAT_NOT_SET;
}
inline Phy_stat::StatCase Phy_stat::stat_case() const {
  return Phy_stat::StatCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Mac_ack_stat

// uint64 destination_address = 1;
inline void Mac_ack_stat::clear_destination_address() {
  destination_address_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Mac_ack_stat::destination_address() const {
  // @@protoc_insertion_point(field_get:communicator.Mac_ack_stat.destination_address)
  return destination_address_;
}
inline void Mac_ack_stat::set_destination_address(::google::protobuf::uint64 value) {
  
  destination_address_ = value;
  // @@protoc_insertion_point(field_set:communicator.Mac_ack_stat.destination_address)
}

// .communicator.Mac_ack_stat.AckStatus status = 2;
inline void Mac_ack_stat::clear_status() {
  status_ = 0;
}
inline ::communicator::Mac_ack_stat_AckStatus Mac_ack_stat::status() const {
  // @@protoc_insertion_point(field_get:communicator.Mac_ack_stat.status)
  return static_cast< ::communicator::Mac_ack_stat_AckStatus >(status_);
}
inline void Mac_ack_stat::set_status(::communicator::Mac_ack_stat_AckStatus value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:communicator.Mac_ack_stat.status)
}

// uint32 mcs = 3;
inline void Mac_ack_stat::clear_mcs() {
  mcs_ = 0u;
}
inline ::google::protobuf::uint32 Mac_ack_stat::mcs() const {
  // @@protoc_insertion_point(field_get:communicator.Mac_ack_stat.mcs)
  return mcs_;
}
inline void Mac_ack_stat::set_mcs(::google::protobuf::uint32 value) {
  
  mcs_ = value;
  // @@protoc_insertion_point(field_set:communicator.Mac_ack_stat.mcs)
}

// uint32 tx_gain = 4;
inline void Mac_ack_stat::clear_tx_gain() {
  tx_gain_ = 0u;
}
inline ::google::protobuf::uint32 Mac_ack_stat::tx_gain() const {
  // @@protoc_insertion_point(field_get:communicator.Mac_ack_stat.tx_gain)
  return tx_gain_;
}
inline void Mac_ack_stat::set_tx_gain(::google::protobuf::uint32 value) {
  
  tx_gain_ = value;
  // @@protoc_insertion_point(field_set:communicator.Mac_ack_stat.tx_gain)
}

// uint32 port = 5;
inline void Mac_ack_stat::clear_port() {
  port_ = 0u;
}
inline ::google::protobuf::uint32 Mac_ack_stat::port() const {
  // @@protoc_insertion_point(field_get:communicator.Mac_ack_stat.port)
  return port_;
}
inline void Mac_ack_stat::set_port(::google::protobuf::uint32 value) {
  
  port_ = value;
  // @@protoc_insertion_point(field_set:communicator.Mac_ack_stat.port)
}

// uint32 payload_size = 6;
inline void Mac_ack_stat::clear_payload_size() {
  payload_size_ = 0u;
}
inline ::google::protobuf::uint32 Mac_ack_stat::payload_size() const {
  // @@protoc_insertion_point(field_get:communicator.Mac_ack_stat.payload_size)
  return payload_size_;
}
inline void Mac_ack_stat::set_payload_size(::google::protobuf::uint32 value) {
  
  payload_size_ = value;
  // @@protoc_insertion_point(field_set:communicator.Mac_ack_stat.payload_size)
}

// uint32 tx_channel = 7;
inline void Mac_ack_stat::clear_tx_channel() {
  tx_channel_ = 0u;
}
inline ::google::protobuf::uint32 Mac_ack_stat::tx_channel() const {
  // @@protoc_insertion_point(field_get:communicator.Mac_ack_stat.tx_channel)
  return tx_channel_;
}
inline void Mac_ack_stat::set_tx_channel(::google::protobuf::uint32 value) {
  
  tx_channel_ = value;
  // @@protoc_insertion_point(field_set:communicator.Mac_ack_stat.tx_channel)
}

// uint32 slot_index = 8;
inline void Mac_ack_stat::clear_slot_index() {
  slot_index_ = 0u;
}
inline ::google::protobuf::uint32 Mac_ack_stat::slot_index() const {
  // @@protoc_insertion_point(field_get:communicator.Mac_ack_stat.slot_index)
  return slot_index_;
}
inline void Mac_ack_stat::set_slot_index(::google::protobuf::uint32 value) {
  
  slot_index_ = value;
  // @@protoc_insertion_point(field_set:communicator.Mac_ack_stat.slot_index)
}

// uint32 max_retries = 9;
inline void Mac_ack_stat::clear_max_retries() {
  max_retries_ = 0u;
}
inline ::google::protobuf::uint32 Mac_ack_stat::max_retries() const {
  // @@protoc_insertion_point(field_get:communicator.Mac_ack_stat.max_retries)
  return max_retries_;
}
inline void Mac_ack_stat::set_max_retries(::google::protobuf::uint32 value) {
  
  max_retries_ = value;
  // @@protoc_insertion_point(field_set:communicator.Mac_ack_stat.max_retries)
}

// uint32 num_retries = 10;
inline void Mac_ack_stat::clear_num_retries() {
  num_retries_ = 0u;
}
inline ::google::protobuf::uint32 Mac_ack_stat::num_retries() const {
  // @@protoc_insertion_point(field_get:communicator.Mac_ack_stat.num_retries)
  return num_retries_;
}
inline void Mac_ack_stat::set_num_retries(::google::protobuf::uint32 value) {
  
  num_retries_ = value;
  // @@protoc_insertion_point(field_set:communicator.Mac_ack_stat.num_retries)
}

// uint64 bytes_transmitted = 11;
inline void Mac_ack_stat::clear_bytes_transmitted() {
  bytes_transmitted_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Mac_ack_stat::bytes_transmitted() const {
  // @@protoc_insertion_point(field_get:communicator.Mac_ack_stat.bytes_transmitted)
  return bytes_transmitted_;
}
inline void Mac_ack_stat::set_bytes_transmitted(::google::protobuf::uint64 value) {
  
  bytes_transmitted_ = value;
  // @@protoc_insertion_point(field_set:communicator.Mac_ack_stat.bytes_transmitted)
}

// .communicator.Phy_rx_stat receiver_stats = 12;
inline bool Mac_ack_stat::has_receiver_stats() const {
  return this != internal_default_instance() && receiver_stats_ != NULL;
}
inline void Mac_ack_stat::clear_receiver_stats() {
  if (GetArenaNoVirtual() == NULL && receiver_stats_ != NULL) delete receiver_stats_;
  receiver_stats_ = NULL;
}
inline const ::communicator::Phy_rx_stat& Mac_ack_stat::receiver_stats() const {
  // @@protoc_insertion_point(field_get:communicator.Mac_ack_stat.receiver_stats)
  return receiver_stats_ != NULL ? *receiver_stats_
                         : *::communicator::Phy_rx_stat::internal_default_instance();
}
inline ::communicator::Phy_rx_stat* Mac_ack_stat::mutable_receiver_stats() {
  
  if (receiver_stats_ == NULL) {
    receiver_stats_ = new ::communicator::Phy_rx_stat;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Mac_ack_stat.receiver_stats)
  return receiver_stats_;
}
inline ::communicator::Phy_rx_stat* Mac_ack_stat::release_receiver_stats() {
  // @@protoc_insertion_point(field_release:communicator.Mac_ack_stat.receiver_stats)
  
  ::communicator::Phy_rx_stat* temp = receiver_stats_;
  receiver_stats_ = NULL;
  return temp;
}
inline void Mac_ack_stat::set_allocated_receiver_stats(::communicator::Phy_rx_stat* receiver_stats) {
  delete receiver_stats_;
  receiver_stats_ = receiver_stats;
  if (receiver_stats) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Mac_ack_stat.receiver_stats)
}

// -------------------------------------------------------------------

// Mac_tx_stat

// repeated .communicator.Mac_ack_stat ack_stat = 1;
inline int Mac_tx_stat::ack_stat_size() const {
  return ack_stat_.size();
}
inline void Mac_tx_stat::clear_ack_stat() {
  ack_stat_.Clear();
}
inline const ::communicator::Mac_ack_stat& Mac_tx_stat::ack_stat(int index) const {
  // @@protoc_insertion_point(field_get:communicator.Mac_tx_stat.ack_stat)
  return ack_stat_.Get(index);
}
inline ::communicator::Mac_ack_stat* Mac_tx_stat::mutable_ack_stat(int index) {
  // @@protoc_insertion_point(field_mutable:communicator.Mac_tx_stat.ack_stat)
  return ack_stat_.Mutable(index);
}
inline ::communicator::Mac_ack_stat* Mac_tx_stat::add_ack_stat() {
  // @@protoc_insertion_point(field_add:communicator.Mac_tx_stat.ack_stat)
  return ack_stat_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::communicator::Mac_ack_stat >*
Mac_tx_stat::mutable_ack_stat() {
  // @@protoc_insertion_point(field_mutable_list:communicator.Mac_tx_stat.ack_stat)
  return &ack_stat_;
}
inline const ::google::protobuf::RepeatedPtrField< ::communicator::Mac_ack_stat >&
Mac_tx_stat::ack_stat() const {
  // @@protoc_insertion_point(field_list:communicator.Mac_tx_stat.ack_stat)
  return ack_stat_;
}

// -------------------------------------------------------------------

// Mac_rx_stat

// uint32 num_byte_overflow_drop = 1;
inline void Mac_rx_stat::clear_num_byte_overflow_drop() {
  num_byte_overflow_drop_ = 0u;
}
inline ::google::protobuf::uint32 Mac_rx_stat::num_byte_overflow_drop() const {
  // @@protoc_insertion_point(field_get:communicator.Mac_rx_stat.num_byte_overflow_drop)
  return num_byte_overflow_drop_;
}
inline void Mac_rx_stat::set_num_byte_overflow_drop(::google::protobuf::uint32 value) {
  
  num_byte_overflow_drop_ = value;
  // @@protoc_insertion_point(field_set:communicator.Mac_rx_stat.num_byte_overflow_drop)
}

// bool crc = 2;
inline void Mac_rx_stat::clear_crc() {
  crc_ = false;
}
inline bool Mac_rx_stat::crc() const {
  // @@protoc_insertion_point(field_get:communicator.Mac_rx_stat.crc)
  return crc_;
}
inline void Mac_rx_stat::set_crc(bool value) {
  
  crc_ = value;
  // @@protoc_insertion_point(field_set:communicator.Mac_rx_stat.crc)
}

// uint32 tx_channel = 3;
inline void Mac_rx_stat::clear_tx_channel() {
  tx_channel_ = 0u;
}
inline ::google::protobuf::uint32 Mac_rx_stat::tx_channel() const {
  // @@protoc_insertion_point(field_get:communicator.Mac_rx_stat.tx_channel)
  return tx_channel_;
}
inline void Mac_rx_stat::set_tx_channel(::google::protobuf::uint32 value) {
  
  tx_channel_ = value;
  // @@protoc_insertion_point(field_set:communicator.Mac_rx_stat.tx_channel)
}

// uint32 slot_index = 4;
inline void Mac_rx_stat::clear_slot_index() {
  slot_index_ = 0u;
}
inline ::google::protobuf::uint32 Mac_rx_stat::slot_index() const {
  // @@protoc_insertion_point(field_get:communicator.Mac_rx_stat.slot_index)
  return slot_index_;
}
inline void Mac_rx_stat::set_slot_index(::google::protobuf::uint32 value) {
  
  slot_index_ = value;
  // @@protoc_insertion_point(field_set:communicator.Mac_rx_stat.slot_index)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Mac_queue_stat

// uint32 high_queue_size = 1;
inline void Mac_queue_stat::clear_high_queue_size() {
  high_queue_size_ = 0u;
}
inline ::google::protobuf::uint32 Mac_queue_stat::high_queue_size() const {
  // @@protoc_insertion_point(field_get:communicator.Mac_queue_stat.high_queue_size)
  return high_queue_size_;
}
inline void Mac_queue_stat::set_high_queue_size(::google::protobuf::uint32 value) {
  
  high_queue_size_ = value;
  // @@protoc_insertion_point(field_set:communicator.Mac_queue_stat.high_queue_size)
}

// uint32 high_messages_in_queue = 2;
inline void Mac_queue_stat::clear_high_messages_in_queue() {
  high_messages_in_queue_ = 0u;
}
inline ::google::protobuf::uint32 Mac_queue_stat::high_messages_in_queue() const {
  // @@protoc_insertion_point(field_get:communicator.Mac_queue_stat.high_messages_in_queue)
  return high_messages_in_queue_;
}
inline void Mac_queue_stat::set_high_messages_in_queue(::google::protobuf::uint32 value) {
  
  high_messages_in_queue_ = value;
  // @@protoc_insertion_point(field_set:communicator.Mac_queue_stat.high_messages_in_queue)
}

// uint32 high_pkts_lost_overflow = 3;
inline void Mac_queue_stat::clear_high_pkts_lost_overflow() {
  high_pkts_lost_overflow_ = 0u;
}
inline ::google::protobuf::uint32 Mac_queue_stat::high_pkts_lost_overflow() const {
  // @@protoc_insertion_point(field_get:communicator.Mac_queue_stat.high_pkts_lost_overflow)
  return high_pkts_lost_overflow_;
}
inline void Mac_queue_stat::set_high_pkts_lost_overflow(::google::protobuf::uint32 value) {
  
  high_pkts_lost_overflow_ = value;
  // @@protoc_insertion_point(field_set:communicator.Mac_queue_stat.high_pkts_lost_overflow)
}

// uint32 high_average_queue_delay = 4;
inline void Mac_queue_stat::clear_high_average_queue_delay() {
  high_average_queue_delay_ = 0u;
}
inline ::google::protobuf::uint32 Mac_queue_stat::high_average_queue_delay() const {
  // @@protoc_insertion_point(field_get:communicator.Mac_queue_stat.high_average_queue_delay)
  return high_average_queue_delay_;
}
inline void Mac_queue_stat::set_high_average_queue_delay(::google::protobuf::uint32 value) {
  
  high_average_queue_delay_ = value;
  // @@protoc_insertion_point(field_set:communicator.Mac_queue_stat.high_average_queue_delay)
}

// uint32 low_queue_size = 5;
inline void Mac_queue_stat::clear_low_queue_size() {
  low_queue_size_ = 0u;
}
inline ::google::protobuf::uint32 Mac_queue_stat::low_queue_size() const {
  // @@protoc_insertion_point(field_get:communicator.Mac_queue_stat.low_queue_size)
  return low_queue_size_;
}
inline void Mac_queue_stat::set_low_queue_size(::google::protobuf::uint32 value) {
  
  low_queue_size_ = value;
  // @@protoc_insertion_point(field_set:communicator.Mac_queue_stat.low_queue_size)
}

// uint32 low_messages_in_queue = 6;
inline void Mac_queue_stat::clear_low_messages_in_queue() {
  low_messages_in_queue_ = 0u;
}
inline ::google::protobuf::uint32 Mac_queue_stat::low_messages_in_queue() const {
  // @@protoc_insertion_point(field_get:communicator.Mac_queue_stat.low_messages_in_queue)
  return low_messages_in_queue_;
}
inline void Mac_queue_stat::set_low_messages_in_queue(::google::protobuf::uint32 value) {
  
  low_messages_in_queue_ = value;
  // @@protoc_insertion_point(field_set:communicator.Mac_queue_stat.low_messages_in_queue)
}

// uint32 low_pkts_lost_overflow = 7;
inline void Mac_queue_stat::clear_low_pkts_lost_overflow() {
  low_pkts_lost_overflow_ = 0u;
}
inline ::google::protobuf::uint32 Mac_queue_stat::low_pkts_lost_overflow() const {
  // @@protoc_insertion_point(field_get:communicator.Mac_queue_stat.low_pkts_lost_overflow)
  return low_pkts_lost_overflow_;
}
inline void Mac_queue_stat::set_low_pkts_lost_overflow(::google::protobuf::uint32 value) {
  
  low_pkts_lost_overflow_ = value;
  // @@protoc_insertion_point(field_set:communicator.Mac_queue_stat.low_pkts_lost_overflow)
}

// uint32 low_average_queue_delay = 8;
inline void Mac_queue_stat::clear_low_average_queue_delay() {
  low_average_queue_delay_ = 0u;
}
inline ::google::protobuf::uint32 Mac_queue_stat::low_average_queue_delay() const {
  // @@protoc_insertion_point(field_get:communicator.Mac_queue_stat.low_average_queue_delay)
  return low_average_queue_delay_;
}
inline void Mac_queue_stat::set_low_average_queue_delay(::google::protobuf::uint32 value) {
  
  low_average_queue_delay_ = value;
  // @@protoc_insertion_point(field_set:communicator.Mac_queue_stat.low_average_queue_delay)
}

// map<uint64, uint32> queue_inf = 9;
inline int Mac_queue_stat::queue_inf_size() const {
  return queue_inf_.size();
}
inline void Mac_queue_stat::clear_queue_inf() {
  queue_inf_.Clear();
}
inline const ::google::protobuf::Map< ::google::protobuf::uint64, ::google::protobuf::uint32 >&
Mac_queue_stat::queue_inf() const {
  // @@protoc_insertion_point(field_map:communicator.Mac_queue_stat.queue_inf)
  return queue_inf_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::uint64, ::google::protobuf::uint32 >*
Mac_queue_stat::mutable_queue_inf() {
  // @@protoc_insertion_point(field_mutable_map:communicator.Mac_queue_stat.queue_inf)
  return queue_inf_.MutableMap();
}

// -------------------------------------------------------------------

// Mac_stat_Cell_information

// uint32 ch = 1;
inline void Mac_stat_Cell_information::clear_ch() {
  ch_ = 0u;
}
inline ::google::protobuf::uint32 Mac_stat_Cell_information::ch() const {
  // @@protoc_insertion_point(field_get:communicator.Mac_stat.Cell_information.ch)
  return ch_;
}
inline void Mac_stat_Cell_information::set_ch(::google::protobuf::uint32 value) {
  
  ch_ = value;
  // @@protoc_insertion_point(field_set:communicator.Mac_stat.Cell_information.ch)
}

// uint32 slot = 2;
inline void Mac_stat_Cell_information::clear_slot() {
  slot_ = 0u;
}
inline ::google::protobuf::uint32 Mac_stat_Cell_information::slot() const {
  // @@protoc_insertion_point(field_get:communicator.Mac_stat.Cell_information.slot)
  return slot_;
}
inline void Mac_stat_Cell_information::set_slot(::google::protobuf::uint32 value) {
  
  slot_ = value;
  // @@protoc_insertion_point(field_set:communicator.Mac_stat.Cell_information.slot)
}

// uint32 num_byte_total = 3;
inline void Mac_stat_Cell_information::clear_num_byte_total() {
  num_byte_total_ = 0u;
}
inline ::google::protobuf::uint32 Mac_stat_Cell_information::num_byte_total() const {
  // @@protoc_insertion_point(field_get:communicator.Mac_stat.Cell_information.num_byte_total)
  return num_byte_total_;
}
inline void Mac_stat_Cell_information::set_num_byte_total(::google::protobuf::uint32 value) {
  
  num_byte_total_ = value;
  // @@protoc_insertion_point(field_set:communicator.Mac_stat.Cell_information.num_byte_total)
}

// uint32 num_byte_crc_drop = 4;
inline void Mac_stat_Cell_information::clear_num_byte_crc_drop() {
  num_byte_crc_drop_ = 0u;
}
inline ::google::protobuf::uint32 Mac_stat_Cell_information::num_byte_crc_drop() const {
  // @@protoc_insertion_point(field_get:communicator.Mac_stat.Cell_information.num_byte_crc_drop)
  return num_byte_crc_drop_;
}
inline void Mac_stat_Cell_information::set_num_byte_crc_drop(::google::protobuf::uint32 value) {
  
  num_byte_crc_drop_ = value;
  // @@protoc_insertion_point(field_set:communicator.Mac_stat.Cell_information.num_byte_crc_drop)
}

// .communicator.Mac_tx_stat tx_stat = 5;
inline bool Mac_stat_Cell_information::has_tx_stat() const {
  return rx_tx_stat_case() == kTxStat;
}
inline void Mac_stat_Cell_information::set_has_tx_stat() {
  _oneof_case_[0] = kTxStat;
}
inline void Mac_stat_Cell_information::clear_tx_stat() {
  if (has_tx_stat()) {
    delete rx_tx_stat_.tx_stat_;
    clear_has_rx_tx_stat();
  }
}
inline  const ::communicator::Mac_tx_stat& Mac_stat_Cell_information::tx_stat() const {
  // @@protoc_insertion_point(field_get:communicator.Mac_stat.Cell_information.tx_stat)
  return has_tx_stat()
      ? *rx_tx_stat_.tx_stat_
      : ::communicator::Mac_tx_stat::default_instance();
}
inline ::communicator::Mac_tx_stat* Mac_stat_Cell_information::mutable_tx_stat() {
  if (!has_tx_stat()) {
    clear_rx_tx_stat();
    set_has_tx_stat();
    rx_tx_stat_.tx_stat_ = new ::communicator::Mac_tx_stat;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Mac_stat.Cell_information.tx_stat)
  return rx_tx_stat_.tx_stat_;
}
inline ::communicator::Mac_tx_stat* Mac_stat_Cell_information::release_tx_stat() {
  // @@protoc_insertion_point(field_release:communicator.Mac_stat.Cell_information.tx_stat)
  if (has_tx_stat()) {
    clear_has_rx_tx_stat();
    ::communicator::Mac_tx_stat* temp = rx_tx_stat_.tx_stat_;
    rx_tx_stat_.tx_stat_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Mac_stat_Cell_information::set_allocated_tx_stat(::communicator::Mac_tx_stat* tx_stat) {
  clear_rx_tx_stat();
  if (tx_stat) {
    set_has_tx_stat();
    rx_tx_stat_.tx_stat_ = tx_stat;
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Mac_stat.Cell_information.tx_stat)
}

// .communicator.Mac_rx_stat rx_stat = 6;
inline bool Mac_stat_Cell_information::has_rx_stat() const {
  return rx_tx_stat_case() == kRxStat;
}
inline void Mac_stat_Cell_information::set_has_rx_stat() {
  _oneof_case_[0] = kRxStat;
}
inline void Mac_stat_Cell_information::clear_rx_stat() {
  if (has_rx_stat()) {
    delete rx_tx_stat_.rx_stat_;
    clear_has_rx_tx_stat();
  }
}
inline  const ::communicator::Mac_rx_stat& Mac_stat_Cell_information::rx_stat() const {
  // @@protoc_insertion_point(field_get:communicator.Mac_stat.Cell_information.rx_stat)
  return has_rx_stat()
      ? *rx_tx_stat_.rx_stat_
      : ::communicator::Mac_rx_stat::default_instance();
}
inline ::communicator::Mac_rx_stat* Mac_stat_Cell_information::mutable_rx_stat() {
  if (!has_rx_stat()) {
    clear_rx_tx_stat();
    set_has_rx_stat();
    rx_tx_stat_.rx_stat_ = new ::communicator::Mac_rx_stat;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Mac_stat.Cell_information.rx_stat)
  return rx_tx_stat_.rx_stat_;
}
inline ::communicator::Mac_rx_stat* Mac_stat_Cell_information::release_rx_stat() {
  // @@protoc_insertion_point(field_release:communicator.Mac_stat.Cell_information.rx_stat)
  if (has_rx_stat()) {
    clear_has_rx_tx_stat();
    ::communicator::Mac_rx_stat* temp = rx_tx_stat_.rx_stat_;
    rx_tx_stat_.rx_stat_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Mac_stat_Cell_information::set_allocated_rx_stat(::communicator::Mac_rx_stat* rx_stat) {
  clear_rx_tx_stat();
  if (rx_stat) {
    set_has_rx_stat();
    rx_tx_stat_.rx_stat_ = rx_stat;
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Mac_stat.Cell_information.rx_stat)
}

inline bool Mac_stat_Cell_information::has_rx_tx_stat() const {
  return rx_tx_stat_case() != RX_TX_STAT_NOT_SET;
}
inline void Mac_stat_Cell_information::clear_has_rx_tx_stat() {
  _oneof_case_[0] = RX_TX_STAT_NOT_SET;
}
inline Mac_stat_Cell_information::RxTxStatCase Mac_stat_Cell_information::rx_tx_stat_case() const {
  return Mac_stat_Cell_information::RxTxStatCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Mac_stat_Mac_send_stat

// uint64 start_timestamp = 1;
inline void Mac_stat_Mac_send_stat::clear_start_timestamp() {
  start_timestamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Mac_stat_Mac_send_stat::start_timestamp() const {
  // @@protoc_insertion_point(field_get:communicator.Mac_stat.Mac_send_stat.start_timestamp)
  return start_timestamp_;
}
inline void Mac_stat_Mac_send_stat::set_start_timestamp(::google::protobuf::uint64 value) {
  
  start_timestamp_ = value;
  // @@protoc_insertion_point(field_set:communicator.Mac_stat.Mac_send_stat.start_timestamp)
}

// uint32 packet_count = 2;
inline void Mac_stat_Mac_send_stat::clear_packet_count() {
  packet_count_ = 0u;
}
inline ::google::protobuf::uint32 Mac_stat_Mac_send_stat::packet_count() const {
  // @@protoc_insertion_point(field_get:communicator.Mac_stat.Mac_send_stat.packet_count)
  return packet_count_;
}
inline void Mac_stat_Mac_send_stat::set_packet_count(::google::protobuf::uint32 value) {
  
  packet_count_ = value;
  // @@protoc_insertion_point(field_set:communicator.Mac_stat.Mac_send_stat.packet_count)
}

// uint32 ch = 3;
inline void Mac_stat_Mac_send_stat::clear_ch() {
  ch_ = 0u;
}
inline ::google::protobuf::uint32 Mac_stat_Mac_send_stat::ch() const {
  // @@protoc_insertion_point(field_get:communicator.Mac_stat.Mac_send_stat.ch)
  return ch_;
}
inline void Mac_stat_Mac_send_stat::set_ch(::google::protobuf::uint32 value) {
  
  ch_ = value;
  // @@protoc_insertion_point(field_set:communicator.Mac_stat.Mac_send_stat.ch)
}

// -------------------------------------------------------------------

// Mac_stat

// uint32 average_mac_delay = 1;
inline void Mac_stat::clear_average_mac_delay() {
  average_mac_delay_ = 0u;
}
inline ::google::protobuf::uint32 Mac_stat::average_mac_delay() const {
  // @@protoc_insertion_point(field_get:communicator.Mac_stat.average_mac_delay)
  return average_mac_delay_;
}
inline void Mac_stat::set_average_mac_delay(::google::protobuf::uint32 value) {
  
  average_mac_delay_ = value;
  // @@protoc_insertion_point(field_set:communicator.Mac_stat.average_mac_delay)
}

// uint32 pkts_lost_mac = 2;
inline void Mac_stat::clear_pkts_lost_mac() {
  pkts_lost_mac_ = 0u;
}
inline ::google::protobuf::uint32 Mac_stat::pkts_lost_mac() const {
  // @@protoc_insertion_point(field_get:communicator.Mac_stat.pkts_lost_mac)
  return pkts_lost_mac_;
}
inline void Mac_stat::set_pkts_lost_mac(::google::protobuf::uint32 value) {
  
  pkts_lost_mac_ = value;
  // @@protoc_insertion_point(field_set:communicator.Mac_stat.pkts_lost_mac)
}

// uint64 host_timestamp = 3;
inline void Mac_stat::clear_host_timestamp() {
  host_timestamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Mac_stat::host_timestamp() const {
  // @@protoc_insertion_point(field_get:communicator.Mac_stat.host_timestamp)
  return host_timestamp_;
}
inline void Mac_stat::set_host_timestamp(::google::protobuf::uint64 value) {
  
  host_timestamp_ = value;
  // @@protoc_insertion_point(field_set:communicator.Mac_stat.host_timestamp)
}

// uint64 fpga_timestamp = 4;
inline void Mac_stat::clear_fpga_timestamp() {
  fpga_timestamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Mac_stat::fpga_timestamp() const {
  // @@protoc_insertion_point(field_get:communicator.Mac_stat.fpga_timestamp)
  return fpga_timestamp_;
}
inline void Mac_stat::set_fpga_timestamp(::google::protobuf::uint64 value) {
  
  fpga_timestamp_ = value;
  // @@protoc_insertion_point(field_set:communicator.Mac_stat.fpga_timestamp)
}

// uint64 frame = 5;
inline void Mac_stat::clear_frame() {
  frame_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Mac_stat::frame() const {
  // @@protoc_insertion_point(field_get:communicator.Mac_stat.frame)
  return frame_;
}
inline void Mac_stat::set_frame(::google::protobuf::uint64 value) {
  
  frame_ = value;
  // @@protoc_insertion_point(field_set:communicator.Mac_stat.frame)
}

// .communicator.Mac_stat.Cell_information rx_tx_stat = 6;
inline bool Mac_stat::has_rx_tx_stat() const {
  return stat_case() == kRxTxStat;
}
inline void Mac_stat::set_has_rx_tx_stat() {
  _oneof_case_[0] = kRxTxStat;
}
inline void Mac_stat::clear_rx_tx_stat() {
  if (has_rx_tx_stat()) {
    delete stat_.rx_tx_stat_;
    clear_has_stat();
  }
}
inline  const ::communicator::Mac_stat_Cell_information& Mac_stat::rx_tx_stat() const {
  // @@protoc_insertion_point(field_get:communicator.Mac_stat.rx_tx_stat)
  return has_rx_tx_stat()
      ? *stat_.rx_tx_stat_
      : ::communicator::Mac_stat_Cell_information::default_instance();
}
inline ::communicator::Mac_stat_Cell_information* Mac_stat::mutable_rx_tx_stat() {
  if (!has_rx_tx_stat()) {
    clear_stat();
    set_has_rx_tx_stat();
    stat_.rx_tx_stat_ = new ::communicator::Mac_stat_Cell_information;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Mac_stat.rx_tx_stat)
  return stat_.rx_tx_stat_;
}
inline ::communicator::Mac_stat_Cell_information* Mac_stat::release_rx_tx_stat() {
  // @@protoc_insertion_point(field_release:communicator.Mac_stat.rx_tx_stat)
  if (has_rx_tx_stat()) {
    clear_has_stat();
    ::communicator::Mac_stat_Cell_information* temp = stat_.rx_tx_stat_;
    stat_.rx_tx_stat_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Mac_stat::set_allocated_rx_tx_stat(::communicator::Mac_stat_Cell_information* rx_tx_stat) {
  clear_stat();
  if (rx_tx_stat) {
    set_has_rx_tx_stat();
    stat_.rx_tx_stat_ = rx_tx_stat;
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Mac_stat.rx_tx_stat)
}

// .communicator.Mac_queue_stat queue_stat = 7;
inline bool Mac_stat::has_queue_stat() const {
  return stat_case() == kQueueStat;
}
inline void Mac_stat::set_has_queue_stat() {
  _oneof_case_[0] = kQueueStat;
}
inline void Mac_stat::clear_queue_stat() {
  if (has_queue_stat()) {
    delete stat_.queue_stat_;
    clear_has_stat();
  }
}
inline  const ::communicator::Mac_queue_stat& Mac_stat::queue_stat() const {
  // @@protoc_insertion_point(field_get:communicator.Mac_stat.queue_stat)
  return has_queue_stat()
      ? *stat_.queue_stat_
      : ::communicator::Mac_queue_stat::default_instance();
}
inline ::communicator::Mac_queue_stat* Mac_stat::mutable_queue_stat() {
  if (!has_queue_stat()) {
    clear_stat();
    set_has_queue_stat();
    stat_.queue_stat_ = new ::communicator::Mac_queue_stat;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Mac_stat.queue_stat)
  return stat_.queue_stat_;
}
inline ::communicator::Mac_queue_stat* Mac_stat::release_queue_stat() {
  // @@protoc_insertion_point(field_release:communicator.Mac_stat.queue_stat)
  if (has_queue_stat()) {
    clear_has_stat();
    ::communicator::Mac_queue_stat* temp = stat_.queue_stat_;
    stat_.queue_stat_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Mac_stat::set_allocated_queue_stat(::communicator::Mac_queue_stat* queue_stat) {
  clear_stat();
  if (queue_stat) {
    set_has_queue_stat();
    stat_.queue_stat_ = queue_stat;
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Mac_stat.queue_stat)
}

// .communicator.Mac_stat.Mac_send_stat send_stat = 8;
inline bool Mac_stat::has_send_stat() const {
  return stat_case() == kSendStat;
}
inline void Mac_stat::set_has_send_stat() {
  _oneof_case_[0] = kSendStat;
}
inline void Mac_stat::clear_send_stat() {
  if (has_send_stat()) {
    delete stat_.send_stat_;
    clear_has_stat();
  }
}
inline  const ::communicator::Mac_stat_Mac_send_stat& Mac_stat::send_stat() const {
  // @@protoc_insertion_point(field_get:communicator.Mac_stat.send_stat)
  return has_send_stat()
      ? *stat_.send_stat_
      : ::communicator::Mac_stat_Mac_send_stat::default_instance();
}
inline ::communicator::Mac_stat_Mac_send_stat* Mac_stat::mutable_send_stat() {
  if (!has_send_stat()) {
    clear_stat();
    set_has_send_stat();
    stat_.send_stat_ = new ::communicator::Mac_stat_Mac_send_stat;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Mac_stat.send_stat)
  return stat_.send_stat_;
}
inline ::communicator::Mac_stat_Mac_send_stat* Mac_stat::release_send_stat() {
  // @@protoc_insertion_point(field_release:communicator.Mac_stat.send_stat)
  if (has_send_stat()) {
    clear_has_stat();
    ::communicator::Mac_stat_Mac_send_stat* temp = stat_.send_stat_;
    stat_.send_stat_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Mac_stat::set_allocated_send_stat(::communicator::Mac_stat_Mac_send_stat* send_stat) {
  clear_stat();
  if (send_stat) {
    set_has_send_stat();
    stat_.send_stat_ = send_stat;
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Mac_stat.send_stat)
}

inline bool Mac_stat::has_stat() const {
  return stat_case() != STAT_NOT_SET;
}
inline void Mac_stat::clear_has_stat() {
  _oneof_case_[0] = STAT_NOT_SET;
}
inline Mac_stat::StatCase Mac_stat::stat_case() const {
  return Mac_stat::StatCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RF_timeslot_stat

// uint64 host_timestamp = 1;
inline void RF_timeslot_stat::clear_host_timestamp() {
  host_timestamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RF_timeslot_stat::host_timestamp() const {
  // @@protoc_insertion_point(field_get:communicator.RF_timeslot_stat.host_timestamp)
  return host_timestamp_;
}
inline void RF_timeslot_stat::set_host_timestamp(::google::protobuf::uint64 value) {
  
  host_timestamp_ = value;
  // @@protoc_insertion_point(field_set:communicator.RF_timeslot_stat.host_timestamp)
}

// uint64 fpga_timestamp = 2;
inline void RF_timeslot_stat::clear_fpga_timestamp() {
  fpga_timestamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RF_timeslot_stat::fpga_timestamp() const {
  // @@protoc_insertion_point(field_get:communicator.RF_timeslot_stat.fpga_timestamp)
  return fpga_timestamp_;
}
inline void RF_timeslot_stat::set_fpga_timestamp(::google::protobuf::uint64 value) {
  
  fpga_timestamp_ = value;
  // @@protoc_insertion_point(field_set:communicator.RF_timeslot_stat.fpga_timestamp)
}

// uint64 frame = 3;
inline void RF_timeslot_stat::clear_frame() {
  frame_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RF_timeslot_stat::frame() const {
  // @@protoc_insertion_point(field_get:communicator.RF_timeslot_stat.frame)
  return frame_;
}
inline void RF_timeslot_stat::set_frame(::google::protobuf::uint64 value) {
  
  frame_ = value;
  // @@protoc_insertion_point(field_set:communicator.RF_timeslot_stat.frame)
}

// uint32 slot = 4;
inline void RF_timeslot_stat::clear_slot() {
  slot_ = 0u;
}
inline ::google::protobuf::uint32 RF_timeslot_stat::slot() const {
  // @@protoc_insertion_point(field_get:communicator.RF_timeslot_stat.slot)
  return slot_;
}
inline void RF_timeslot_stat::set_slot(::google::protobuf::uint32 value) {
  
  slot_ = value;
  // @@protoc_insertion_point(field_set:communicator.RF_timeslot_stat.slot)
}

// repeated double rssi = 5;
inline int RF_timeslot_stat::rssi_size() const {
  return rssi_.size();
}
inline void RF_timeslot_stat::clear_rssi() {
  rssi_.Clear();
}
inline double RF_timeslot_stat::rssi(int index) const {
  // @@protoc_insertion_point(field_get:communicator.RF_timeslot_stat.rssi)
  return rssi_.Get(index);
}
inline void RF_timeslot_stat::set_rssi(int index, double value) {
  rssi_.Set(index, value);
  // @@protoc_insertion_point(field_set:communicator.RF_timeslot_stat.rssi)
}
inline void RF_timeslot_stat::add_rssi(double value) {
  rssi_.Add(value);
  // @@protoc_insertion_point(field_add:communicator.RF_timeslot_stat.rssi)
}
inline const ::google::protobuf::RepeatedField< double >&
RF_timeslot_stat::rssi() const {
  // @@protoc_insertion_point(field_list:communicator.RF_timeslot_stat.rssi)
  return rssi_;
}
inline ::google::protobuf::RepeatedField< double >*
RF_timeslot_stat::mutable_rssi() {
  // @@protoc_insertion_point(field_mutable_list:communicator.RF_timeslot_stat.rssi)
  return &rssi_;
}

// -------------------------------------------------------------------

// RF_stat

// repeated .communicator.RF_timeslot_stat stats = 1;
inline int RF_stat::stats_size() const {
  return stats_.size();
}
inline void RF_stat::clear_stats() {
  stats_.Clear();
}
inline const ::communicator::RF_timeslot_stat& RF_stat::stats(int index) const {
  // @@protoc_insertion_point(field_get:communicator.RF_stat.stats)
  return stats_.Get(index);
}
inline ::communicator::RF_timeslot_stat* RF_stat::mutable_stats(int index) {
  // @@protoc_insertion_point(field_mutable:communicator.RF_stat.stats)
  return stats_.Mutable(index);
}
inline ::communicator::RF_timeslot_stat* RF_stat::add_stats() {
  // @@protoc_insertion_point(field_add:communicator.RF_stat.stats)
  return stats_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::communicator::RF_timeslot_stat >*
RF_stat::mutable_stats() {
  // @@protoc_insertion_point(field_mutable_list:communicator.RF_stat.stats)
  return &stats_;
}
inline const ::google::protobuf::RepeatedPtrField< ::communicator::RF_timeslot_stat >&
RF_stat::stats() const {
  // @@protoc_insertion_point(field_list:communicator.RF_stat.stats)
  return stats_;
}

// -------------------------------------------------------------------

// Application_data

// uint64 next_mac = 1;
inline void Application_data::clear_next_mac() {
  next_mac_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Application_data::next_mac() const {
  // @@protoc_insertion_point(field_get:communicator.Application_data.next_mac)
  return next_mac_;
}
inline void Application_data::set_next_mac(::google::protobuf::uint64 value) {
  
  next_mac_ = value;
  // @@protoc_insertion_point(field_set:communicator.Application_data.next_mac)
}

// fixed32 destination_ip = 2;
inline void Application_data::clear_destination_ip() {
  destination_ip_ = 0u;
}
inline ::google::protobuf::uint32 Application_data::destination_ip() const {
  // @@protoc_insertion_point(field_get:communicator.Application_data.destination_ip)
  return destination_ip_;
}
inline void Application_data::set_destination_ip(::google::protobuf::uint32 value) {
  
  destination_ip_ = value;
  // @@protoc_insertion_point(field_set:communicator.Application_data.destination_ip)
}

// .communicator.Application_data.PACKET_TYPE packet_type = 3;
inline void Application_data::clear_packet_type() {
  packet_type_ = 0;
}
inline ::communicator::Application_data_PACKET_TYPE Application_data::packet_type() const {
  // @@protoc_insertion_point(field_get:communicator.Application_data.packet_type)
  return static_cast< ::communicator::Application_data_PACKET_TYPE >(packet_type_);
}
inline void Application_data::set_packet_type(::communicator::Application_data_PACKET_TYPE value) {
  
  packet_type_ = value;
  // @@protoc_insertion_point(field_set:communicator.Application_data.packet_type)
}

// .communicator.Application_data.TRAFFIC_CLASS traffic_class = 4;
inline void Application_data::clear_traffic_class() {
  traffic_class_ = 0;
}
inline ::communicator::Application_data_TRAFFIC_CLASS Application_data::traffic_class() const {
  // @@protoc_insertion_point(field_get:communicator.Application_data.traffic_class)
  return static_cast< ::communicator::Application_data_TRAFFIC_CLASS >(traffic_class_);
}
inline void Application_data::set_traffic_class(::communicator::Application_data_TRAFFIC_CLASS value) {
  
  traffic_class_ = value;
  // @@protoc_insertion_point(field_set:communicator.Application_data.traffic_class)
}

// uint32 priority = 5;
inline void Application_data::clear_priority() {
  priority_ = 0u;
}
inline ::google::protobuf::uint32 Application_data::priority() const {
  // @@protoc_insertion_point(field_get:communicator.Application_data.priority)
  return priority_;
}
inline void Application_data::set_priority(::google::protobuf::uint32 value) {
  
  priority_ = value;
  // @@protoc_insertion_point(field_set:communicator.Application_data.priority)
}

// bytes data = 6;
inline void Application_data::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Application_data::data() const {
  // @@protoc_insertion_point(field_get:communicator.Application_data.data)
  return data_.GetNoArena();
}
inline void Application_data::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:communicator.Application_data.data)
}
#if LANG_CXX11
inline void Application_data::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:communicator.Application_data.data)
}
#endif
inline void Application_data::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:communicator.Application_data.data)
}
inline void Application_data::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:communicator.Application_data.data)
}
inline ::std::string* Application_data::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:communicator.Application_data.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Application_data::release_data() {
  // @@protoc_insertion_point(field_release:communicator.Application_data.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Application_data::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:communicator.Application_data.data)
}

// uint64 timestamp = 7;
inline void Application_data::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Application_data::timestamp() const {
  // @@protoc_insertion_point(field_get:communicator.Application_data.timestamp)
  return timestamp_;
}
inline void Application_data::set_timestamp(::google::protobuf::uint64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:communicator.Application_data.timestamp)
}

// -------------------------------------------------------------------

// Link_MCS_TxGain_BW

// uint64 destination_mac = 1;
inline void Link_MCS_TxGain_BW::clear_destination_mac() {
  destination_mac_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Link_MCS_TxGain_BW::destination_mac() const {
  // @@protoc_insertion_point(field_get:communicator.Link_MCS_TxGain_BW.destination_mac)
  return destination_mac_;
}
inline void Link_MCS_TxGain_BW::set_destination_mac(::google::protobuf::uint64 value) {
  
  destination_mac_ = value;
  // @@protoc_insertion_point(field_set:communicator.Link_MCS_TxGain_BW.destination_mac)
}

// uint32 mcs = 2;
inline void Link_MCS_TxGain_BW::clear_mcs() {
  mcs_ = 0u;
}
inline ::google::protobuf::uint32 Link_MCS_TxGain_BW::mcs() const {
  // @@protoc_insertion_point(field_get:communicator.Link_MCS_TxGain_BW.mcs)
  return mcs_;
}
inline void Link_MCS_TxGain_BW::set_mcs(::google::protobuf::uint32 value) {
  
  mcs_ = value;
  // @@protoc_insertion_point(field_set:communicator.Link_MCS_TxGain_BW.mcs)
}

// uint32 tx_gain = 3;
inline void Link_MCS_TxGain_BW::clear_tx_gain() {
  tx_gain_ = 0u;
}
inline ::google::protobuf::uint32 Link_MCS_TxGain_BW::tx_gain() const {
  // @@protoc_insertion_point(field_get:communicator.Link_MCS_TxGain_BW.tx_gain)
  return tx_gain_;
}
inline void Link_MCS_TxGain_BW::set_tx_gain(::google::protobuf::uint32 value) {
  
  tx_gain_ = value;
  // @@protoc_insertion_point(field_set:communicator.Link_MCS_TxGain_BW.tx_gain)
}

// .communicator.BW_INDEX bw_index = 4;
inline void Link_MCS_TxGain_BW::clear_bw_index() {
  bw_index_ = 0;
}
inline ::communicator::BW_INDEX Link_MCS_TxGain_BW::bw_index() const {
  // @@protoc_insertion_point(field_get:communicator.Link_MCS_TxGain_BW.bw_index)
  return static_cast< ::communicator::BW_INDEX >(bw_index_);
}
inline void Link_MCS_TxGain_BW::set_bw_index(::communicator::BW_INDEX value) {
  
  bw_index_ = value;
  // @@protoc_insertion_point(field_set:communicator.Link_MCS_TxGain_BW.bw_index)
}

// -------------------------------------------------------------------

// MFTDMA_Slot

// uint32 frequency_num = 1;
inline void MFTDMA_Slot::clear_frequency_num() {
  frequency_num_ = 0u;
}
inline ::google::protobuf::uint32 MFTDMA_Slot::frequency_num() const {
  // @@protoc_insertion_point(field_get:communicator.MFTDMA_Slot.frequency_num)
  return frequency_num_;
}
inline void MFTDMA_Slot::set_frequency_num(::google::protobuf::uint32 value) {
  
  frequency_num_ = value;
  // @@protoc_insertion_point(field_set:communicator.MFTDMA_Slot.frequency_num)
}

// uint32 timeslot_num = 2;
inline void MFTDMA_Slot::clear_timeslot_num() {
  timeslot_num_ = 0u;
}
inline ::google::protobuf::uint32 MFTDMA_Slot::timeslot_num() const {
  // @@protoc_insertion_point(field_get:communicator.MFTDMA_Slot.timeslot_num)
  return timeslot_num_;
}
inline void MFTDMA_Slot::set_timeslot_num(::google::protobuf::uint32 value) {
  
  timeslot_num_ = value;
  // @@protoc_insertion_point(field_set:communicator.MFTDMA_Slot.timeslot_num)
}

// -------------------------------------------------------------------

// Proposed_Slots_Request

// uint64 mac = 1;
inline void Proposed_Slots_Request::clear_mac() {
  mac_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Proposed_Slots_Request::mac() const {
  // @@protoc_insertion_point(field_get:communicator.Proposed_Slots_Request.mac)
  return mac_;
}
inline void Proposed_Slots_Request::set_mac(::google::protobuf::uint64 value) {
  
  mac_ = value;
  // @@protoc_insertion_point(field_set:communicator.Proposed_Slots_Request.mac)
}

// uint32 num_slots = 2;
inline void Proposed_Slots_Request::clear_num_slots() {
  num_slots_ = 0u;
}
inline ::google::protobuf::uint32 Proposed_Slots_Request::num_slots() const {
  // @@protoc_insertion_point(field_get:communicator.Proposed_Slots_Request.num_slots)
  return num_slots_;
}
inline void Proposed_Slots_Request::set_num_slots(::google::protobuf::uint32 value) {
  
  num_slots_ = value;
  // @@protoc_insertion_point(field_set:communicator.Proposed_Slots_Request.num_slots)
}

// -------------------------------------------------------------------

// Proposed_Slots

// uint64 mac = 1;
inline void Proposed_Slots::clear_mac() {
  mac_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Proposed_Slots::mac() const {
  // @@protoc_insertion_point(field_get:communicator.Proposed_Slots.mac)
  return mac_;
}
inline void Proposed_Slots::set_mac(::google::protobuf::uint64 value) {
  
  mac_ = value;
  // @@protoc_insertion_point(field_set:communicator.Proposed_Slots.mac)
}

// repeated .communicator.MFTDMA_Slot slots = 2;
inline int Proposed_Slots::slots_size() const {
  return slots_.size();
}
inline void Proposed_Slots::clear_slots() {
  slots_.Clear();
}
inline const ::communicator::MFTDMA_Slot& Proposed_Slots::slots(int index) const {
  // @@protoc_insertion_point(field_get:communicator.Proposed_Slots.slots)
  return slots_.Get(index);
}
inline ::communicator::MFTDMA_Slot* Proposed_Slots::mutable_slots(int index) {
  // @@protoc_insertion_point(field_mutable:communicator.Proposed_Slots.slots)
  return slots_.Mutable(index);
}
inline ::communicator::MFTDMA_Slot* Proposed_Slots::add_slots() {
  // @@protoc_insertion_point(field_add:communicator.Proposed_Slots.slots)
  return slots_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::communicator::MFTDMA_Slot >*
Proposed_Slots::mutable_slots() {
  // @@protoc_insertion_point(field_mutable_list:communicator.Proposed_Slots.slots)
  return &slots_;
}
inline const ::google::protobuf::RepeatedPtrField< ::communicator::MFTDMA_Slot >&
Proposed_Slots::slots() const {
  // @@protoc_insertion_point(field_list:communicator.Proposed_Slots.slots)
  return slots_;
}

// -------------------------------------------------------------------

// Proposed_Move_Slots

// uint64 mac = 1;
inline void Proposed_Move_Slots::clear_mac() {
  mac_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Proposed_Move_Slots::mac() const {
  // @@protoc_insertion_point(field_get:communicator.Proposed_Move_Slots.mac)
  return mac_;
}
inline void Proposed_Move_Slots::set_mac(::google::protobuf::uint64 value) {
  
  mac_ = value;
  // @@protoc_insertion_point(field_set:communicator.Proposed_Move_Slots.mac)
}

// .communicator.MFTDMA_Slot old_slot = 2;
inline bool Proposed_Move_Slots::has_old_slot() const {
  return this != internal_default_instance() && old_slot_ != NULL;
}
inline void Proposed_Move_Slots::clear_old_slot() {
  if (GetArenaNoVirtual() == NULL && old_slot_ != NULL) delete old_slot_;
  old_slot_ = NULL;
}
inline const ::communicator::MFTDMA_Slot& Proposed_Move_Slots::old_slot() const {
  // @@protoc_insertion_point(field_get:communicator.Proposed_Move_Slots.old_slot)
  return old_slot_ != NULL ? *old_slot_
                         : *::communicator::MFTDMA_Slot::internal_default_instance();
}
inline ::communicator::MFTDMA_Slot* Proposed_Move_Slots::mutable_old_slot() {
  
  if (old_slot_ == NULL) {
    old_slot_ = new ::communicator::MFTDMA_Slot;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Proposed_Move_Slots.old_slot)
  return old_slot_;
}
inline ::communicator::MFTDMA_Slot* Proposed_Move_Slots::release_old_slot() {
  // @@protoc_insertion_point(field_release:communicator.Proposed_Move_Slots.old_slot)
  
  ::communicator::MFTDMA_Slot* temp = old_slot_;
  old_slot_ = NULL;
  return temp;
}
inline void Proposed_Move_Slots::set_allocated_old_slot(::communicator::MFTDMA_Slot* old_slot) {
  delete old_slot_;
  old_slot_ = old_slot;
  if (old_slot) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Proposed_Move_Slots.old_slot)
}

// repeated .communicator.MFTDMA_Slot slots = 3;
inline int Proposed_Move_Slots::slots_size() const {
  return slots_.size();
}
inline void Proposed_Move_Slots::clear_slots() {
  slots_.Clear();
}
inline const ::communicator::MFTDMA_Slot& Proposed_Move_Slots::slots(int index) const {
  // @@protoc_insertion_point(field_get:communicator.Proposed_Move_Slots.slots)
  return slots_.Get(index);
}
inline ::communicator::MFTDMA_Slot* Proposed_Move_Slots::mutable_slots(int index) {
  // @@protoc_insertion_point(field_mutable:communicator.Proposed_Move_Slots.slots)
  return slots_.Mutable(index);
}
inline ::communicator::MFTDMA_Slot* Proposed_Move_Slots::add_slots() {
  // @@protoc_insertion_point(field_add:communicator.Proposed_Move_Slots.slots)
  return slots_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::communicator::MFTDMA_Slot >*
Proposed_Move_Slots::mutable_slots() {
  // @@protoc_insertion_point(field_mutable_list:communicator.Proposed_Move_Slots.slots)
  return &slots_;
}
inline const ::google::protobuf::RepeatedPtrField< ::communicator::MFTDMA_Slot >&
Proposed_Move_Slots::slots() const {
  // @@protoc_insertion_point(field_list:communicator.Proposed_Move_Slots.slots)
  return slots_;
}

// -------------------------------------------------------------------

// Selected_Slot

// uint64 mac = 1;
inline void Selected_Slot::clear_mac() {
  mac_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Selected_Slot::mac() const {
  // @@protoc_insertion_point(field_get:communicator.Selected_Slot.mac)
  return mac_;
}
inline void Selected_Slot::set_mac(::google::protobuf::uint64 value) {
  
  mac_ = value;
  // @@protoc_insertion_point(field_set:communicator.Selected_Slot.mac)
}

// .communicator.MFTDMA_Slot slot = 2;
inline bool Selected_Slot::has_slot() const {
  return this != internal_default_instance() && slot_ != NULL;
}
inline void Selected_Slot::clear_slot() {
  if (GetArenaNoVirtual() == NULL && slot_ != NULL) delete slot_;
  slot_ = NULL;
}
inline const ::communicator::MFTDMA_Slot& Selected_Slot::slot() const {
  // @@protoc_insertion_point(field_get:communicator.Selected_Slot.slot)
  return slot_ != NULL ? *slot_
                         : *::communicator::MFTDMA_Slot::internal_default_instance();
}
inline ::communicator::MFTDMA_Slot* Selected_Slot::mutable_slot() {
  
  if (slot_ == NULL) {
    slot_ = new ::communicator::MFTDMA_Slot;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Selected_Slot.slot)
  return slot_;
}
inline ::communicator::MFTDMA_Slot* Selected_Slot::release_slot() {
  // @@protoc_insertion_point(field_release:communicator.Selected_Slot.slot)
  
  ::communicator::MFTDMA_Slot* temp = slot_;
  slot_ = NULL;
  return temp;
}
inline void Selected_Slot::set_allocated_slot(::communicator::MFTDMA_Slot* slot) {
  delete slot_;
  slot_ = slot;
  if (slot) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Selected_Slot.slot)
}

// -------------------------------------------------------------------

// Selected_Move_Slot

// uint64 mac = 1;
inline void Selected_Move_Slot::clear_mac() {
  mac_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Selected_Move_Slot::mac() const {
  // @@protoc_insertion_point(field_get:communicator.Selected_Move_Slot.mac)
  return mac_;
}
inline void Selected_Move_Slot::set_mac(::google::protobuf::uint64 value) {
  
  mac_ = value;
  // @@protoc_insertion_point(field_set:communicator.Selected_Move_Slot.mac)
}

// .communicator.MFTDMA_Slot old_slot = 2;
inline bool Selected_Move_Slot::has_old_slot() const {
  return this != internal_default_instance() && old_slot_ != NULL;
}
inline void Selected_Move_Slot::clear_old_slot() {
  if (GetArenaNoVirtual() == NULL && old_slot_ != NULL) delete old_slot_;
  old_slot_ = NULL;
}
inline const ::communicator::MFTDMA_Slot& Selected_Move_Slot::old_slot() const {
  // @@protoc_insertion_point(field_get:communicator.Selected_Move_Slot.old_slot)
  return old_slot_ != NULL ? *old_slot_
                         : *::communicator::MFTDMA_Slot::internal_default_instance();
}
inline ::communicator::MFTDMA_Slot* Selected_Move_Slot::mutable_old_slot() {
  
  if (old_slot_ == NULL) {
    old_slot_ = new ::communicator::MFTDMA_Slot;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Selected_Move_Slot.old_slot)
  return old_slot_;
}
inline ::communicator::MFTDMA_Slot* Selected_Move_Slot::release_old_slot() {
  // @@protoc_insertion_point(field_release:communicator.Selected_Move_Slot.old_slot)
  
  ::communicator::MFTDMA_Slot* temp = old_slot_;
  old_slot_ = NULL;
  return temp;
}
inline void Selected_Move_Slot::set_allocated_old_slot(::communicator::MFTDMA_Slot* old_slot) {
  delete old_slot_;
  old_slot_ = old_slot;
  if (old_slot) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Selected_Move_Slot.old_slot)
}

// .communicator.MFTDMA_Slot new_slot = 3;
inline bool Selected_Move_Slot::has_new_slot() const {
  return this != internal_default_instance() && new_slot_ != NULL;
}
inline void Selected_Move_Slot::clear_new_slot() {
  if (GetArenaNoVirtual() == NULL && new_slot_ != NULL) delete new_slot_;
  new_slot_ = NULL;
}
inline const ::communicator::MFTDMA_Slot& Selected_Move_Slot::new_slot() const {
  // @@protoc_insertion_point(field_get:communicator.Selected_Move_Slot.new_slot)
  return new_slot_ != NULL ? *new_slot_
                         : *::communicator::MFTDMA_Slot::internal_default_instance();
}
inline ::communicator::MFTDMA_Slot* Selected_Move_Slot::mutable_new_slot() {
  
  if (new_slot_ == NULL) {
    new_slot_ = new ::communicator::MFTDMA_Slot;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Selected_Move_Slot.new_slot)
  return new_slot_;
}
inline ::communicator::MFTDMA_Slot* Selected_Move_Slot::release_new_slot() {
  // @@protoc_insertion_point(field_release:communicator.Selected_Move_Slot.new_slot)
  
  ::communicator::MFTDMA_Slot* temp = new_slot_;
  new_slot_ = NULL;
  return temp;
}
inline void Selected_Move_Slot::set_allocated_new_slot(::communicator::MFTDMA_Slot* new_slot) {
  delete new_slot_;
  new_slot_ = new_slot;
  if (new_slot) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Selected_Move_Slot.new_slot)
}

// -------------------------------------------------------------------

// External_Slot_Allocation

// uint64 src_mac = 1;
inline void External_Slot_Allocation::clear_src_mac() {
  src_mac_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 External_Slot_Allocation::src_mac() const {
  // @@protoc_insertion_point(field_get:communicator.External_Slot_Allocation.src_mac)
  return src_mac_;
}
inline void External_Slot_Allocation::set_src_mac(::google::protobuf::uint64 value) {
  
  src_mac_ = value;
  // @@protoc_insertion_point(field_set:communicator.External_Slot_Allocation.src_mac)
}

// uint64 dst_mac = 2;
inline void External_Slot_Allocation::clear_dst_mac() {
  dst_mac_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 External_Slot_Allocation::dst_mac() const {
  // @@protoc_insertion_point(field_get:communicator.External_Slot_Allocation.dst_mac)
  return dst_mac_;
}
inline void External_Slot_Allocation::set_dst_mac(::google::protobuf::uint64 value) {
  
  dst_mac_ = value;
  // @@protoc_insertion_point(field_set:communicator.External_Slot_Allocation.dst_mac)
}

// .communicator.MFTDMA_Slot slot = 3;
inline bool External_Slot_Allocation::has_slot() const {
  return this != internal_default_instance() && slot_ != NULL;
}
inline void External_Slot_Allocation::clear_slot() {
  if (GetArenaNoVirtual() == NULL && slot_ != NULL) delete slot_;
  slot_ = NULL;
}
inline const ::communicator::MFTDMA_Slot& External_Slot_Allocation::slot() const {
  // @@protoc_insertion_point(field_get:communicator.External_Slot_Allocation.slot)
  return slot_ != NULL ? *slot_
                         : *::communicator::MFTDMA_Slot::internal_default_instance();
}
inline ::communicator::MFTDMA_Slot* External_Slot_Allocation::mutable_slot() {
  
  if (slot_ == NULL) {
    slot_ = new ::communicator::MFTDMA_Slot;
  }
  // @@protoc_insertion_point(field_mutable:communicator.External_Slot_Allocation.slot)
  return slot_;
}
inline ::communicator::MFTDMA_Slot* External_Slot_Allocation::release_slot() {
  // @@protoc_insertion_point(field_release:communicator.External_Slot_Allocation.slot)
  
  ::communicator::MFTDMA_Slot* temp = slot_;
  slot_ = NULL;
  return temp;
}
inline void External_Slot_Allocation::set_allocated_slot(::communicator::MFTDMA_Slot* slot) {
  delete slot_;
  slot_ = slot;
  if (slot) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.External_Slot_Allocation.slot)
}

// -------------------------------------------------------------------

// External_Slot_Removal

// uint64 src_mac = 1;
inline void External_Slot_Removal::clear_src_mac() {
  src_mac_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 External_Slot_Removal::src_mac() const {
  // @@protoc_insertion_point(field_get:communicator.External_Slot_Removal.src_mac)
  return src_mac_;
}
inline void External_Slot_Removal::set_src_mac(::google::protobuf::uint64 value) {
  
  src_mac_ = value;
  // @@protoc_insertion_point(field_set:communicator.External_Slot_Removal.src_mac)
}

// uint64 dst_mac = 2;
inline void External_Slot_Removal::clear_dst_mac() {
  dst_mac_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 External_Slot_Removal::dst_mac() const {
  // @@protoc_insertion_point(field_get:communicator.External_Slot_Removal.dst_mac)
  return dst_mac_;
}
inline void External_Slot_Removal::set_dst_mac(::google::protobuf::uint64 value) {
  
  dst_mac_ = value;
  // @@protoc_insertion_point(field_set:communicator.External_Slot_Removal.dst_mac)
}

// .communicator.MFTDMA_Slot slot = 3;
inline bool External_Slot_Removal::has_slot() const {
  return this != internal_default_instance() && slot_ != NULL;
}
inline void External_Slot_Removal::clear_slot() {
  if (GetArenaNoVirtual() == NULL && slot_ != NULL) delete slot_;
  slot_ = NULL;
}
inline const ::communicator::MFTDMA_Slot& External_Slot_Removal::slot() const {
  // @@protoc_insertion_point(field_get:communicator.External_Slot_Removal.slot)
  return slot_ != NULL ? *slot_
                         : *::communicator::MFTDMA_Slot::internal_default_instance();
}
inline ::communicator::MFTDMA_Slot* External_Slot_Removal::mutable_slot() {
  
  if (slot_ == NULL) {
    slot_ = new ::communicator::MFTDMA_Slot;
  }
  // @@protoc_insertion_point(field_mutable:communicator.External_Slot_Removal.slot)
  return slot_;
}
inline ::communicator::MFTDMA_Slot* External_Slot_Removal::release_slot() {
  // @@protoc_insertion_point(field_release:communicator.External_Slot_Removal.slot)
  
  ::communicator::MFTDMA_Slot* temp = slot_;
  slot_ = NULL;
  return temp;
}
inline void External_Slot_Removal::set_allocated_slot(::communicator::MFTDMA_Slot* slot) {
  delete slot_;
  slot_ = slot;
  if (slot) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.External_Slot_Removal.slot)
}

// -------------------------------------------------------------------

// BC_Slots_Announcement

// repeated .communicator.MFTDMA_Slot slots = 1;
inline int BC_Slots_Announcement::slots_size() const {
  return slots_.size();
}
inline void BC_Slots_Announcement::clear_slots() {
  slots_.Clear();
}
inline const ::communicator::MFTDMA_Slot& BC_Slots_Announcement::slots(int index) const {
  // @@protoc_insertion_point(field_get:communicator.BC_Slots_Announcement.slots)
  return slots_.Get(index);
}
inline ::communicator::MFTDMA_Slot* BC_Slots_Announcement::mutable_slots(int index) {
  // @@protoc_insertion_point(field_mutable:communicator.BC_Slots_Announcement.slots)
  return slots_.Mutable(index);
}
inline ::communicator::MFTDMA_Slot* BC_Slots_Announcement::add_slots() {
  // @@protoc_insertion_point(field_add:communicator.BC_Slots_Announcement.slots)
  return slots_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::communicator::MFTDMA_Slot >*
BC_Slots_Announcement::mutable_slots() {
  // @@protoc_insertion_point(field_mutable_list:communicator.BC_Slots_Announcement.slots)
  return &slots_;
}
inline const ::google::protobuf::RepeatedPtrField< ::communicator::MFTDMA_Slot >&
BC_Slots_Announcement::slots() const {
  // @@protoc_insertion_point(field_list:communicator.BC_Slots_Announcement.slots)
  return slots_;
}

// -------------------------------------------------------------------

// Slot_Allocation

// uint64 mac = 1;
inline void Slot_Allocation::clear_mac() {
  mac_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Slot_Allocation::mac() const {
  // @@protoc_insertion_point(field_get:communicator.Slot_Allocation.mac)
  return mac_;
}
inline void Slot_Allocation::set_mac(::google::protobuf::uint64 value) {
  
  mac_ = value;
  // @@protoc_insertion_point(field_set:communicator.Slot_Allocation.mac)
}

// .communicator.MFTDMA_Slot slot = 2;
inline bool Slot_Allocation::has_slot() const {
  return this != internal_default_instance() && slot_ != NULL;
}
inline void Slot_Allocation::clear_slot() {
  if (GetArenaNoVirtual() == NULL && slot_ != NULL) delete slot_;
  slot_ = NULL;
}
inline const ::communicator::MFTDMA_Slot& Slot_Allocation::slot() const {
  // @@protoc_insertion_point(field_get:communicator.Slot_Allocation.slot)
  return slot_ != NULL ? *slot_
                         : *::communicator::MFTDMA_Slot::internal_default_instance();
}
inline ::communicator::MFTDMA_Slot* Slot_Allocation::mutable_slot() {
  
  if (slot_ == NULL) {
    slot_ = new ::communicator::MFTDMA_Slot;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Slot_Allocation.slot)
  return slot_;
}
inline ::communicator::MFTDMA_Slot* Slot_Allocation::release_slot() {
  // @@protoc_insertion_point(field_release:communicator.Slot_Allocation.slot)
  
  ::communicator::MFTDMA_Slot* temp = slot_;
  slot_ = NULL;
  return temp;
}
inline void Slot_Allocation::set_allocated_slot(::communicator::MFTDMA_Slot* slot) {
  delete slot_;
  slot_ = slot;
  if (slot) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Slot_Allocation.slot)
}

// .communicator.SLOT_MODE mode = 3;
inline void Slot_Allocation::clear_mode() {
  mode_ = 0;
}
inline ::communicator::SLOT_MODE Slot_Allocation::mode() const {
  // @@protoc_insertion_point(field_get:communicator.Slot_Allocation.mode)
  return static_cast< ::communicator::SLOT_MODE >(mode_);
}
inline void Slot_Allocation::set_mode(::communicator::SLOT_MODE value) {
  
  mode_ = value;
  // @@protoc_insertion_point(field_set:communicator.Slot_Allocation.mode)
}

// -------------------------------------------------------------------

// Slot_Removal

// uint64 mac = 1;
inline void Slot_Removal::clear_mac() {
  mac_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Slot_Removal::mac() const {
  // @@protoc_insertion_point(field_get:communicator.Slot_Removal.mac)
  return mac_;
}
inline void Slot_Removal::set_mac(::google::protobuf::uint64 value) {
  
  mac_ = value;
  // @@protoc_insertion_point(field_set:communicator.Slot_Removal.mac)
}

// .communicator.MFTDMA_Slot slot = 2;
inline bool Slot_Removal::has_slot() const {
  return this != internal_default_instance() && slot_ != NULL;
}
inline void Slot_Removal::clear_slot() {
  if (GetArenaNoVirtual() == NULL && slot_ != NULL) delete slot_;
  slot_ = NULL;
}
inline const ::communicator::MFTDMA_Slot& Slot_Removal::slot() const {
  // @@protoc_insertion_point(field_get:communicator.Slot_Removal.slot)
  return slot_ != NULL ? *slot_
                         : *::communicator::MFTDMA_Slot::internal_default_instance();
}
inline ::communicator::MFTDMA_Slot* Slot_Removal::mutable_slot() {
  
  if (slot_ == NULL) {
    slot_ = new ::communicator::MFTDMA_Slot;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Slot_Removal.slot)
  return slot_;
}
inline ::communicator::MFTDMA_Slot* Slot_Removal::release_slot() {
  // @@protoc_insertion_point(field_release:communicator.Slot_Removal.slot)
  
  ::communicator::MFTDMA_Slot* temp = slot_;
  slot_ = NULL;
  return temp;
}
inline void Slot_Removal::set_allocated_slot(::communicator::MFTDMA_Slot* slot) {
  delete slot_;
  slot_ = slot;
  if (slot) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Slot_Removal.slot)
}

// -------------------------------------------------------------------

// Slot_Move

// uint64 mac = 1;
inline void Slot_Move::clear_mac() {
  mac_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Slot_Move::mac() const {
  // @@protoc_insertion_point(field_get:communicator.Slot_Move.mac)
  return mac_;
}
inline void Slot_Move::set_mac(::google::protobuf::uint64 value) {
  
  mac_ = value;
  // @@protoc_insertion_point(field_set:communicator.Slot_Move.mac)
}

// .communicator.MFTDMA_Slot old_slot = 2;
inline bool Slot_Move::has_old_slot() const {
  return this != internal_default_instance() && old_slot_ != NULL;
}
inline void Slot_Move::clear_old_slot() {
  if (GetArenaNoVirtual() == NULL && old_slot_ != NULL) delete old_slot_;
  old_slot_ = NULL;
}
inline const ::communicator::MFTDMA_Slot& Slot_Move::old_slot() const {
  // @@protoc_insertion_point(field_get:communicator.Slot_Move.old_slot)
  return old_slot_ != NULL ? *old_slot_
                         : *::communicator::MFTDMA_Slot::internal_default_instance();
}
inline ::communicator::MFTDMA_Slot* Slot_Move::mutable_old_slot() {
  
  if (old_slot_ == NULL) {
    old_slot_ = new ::communicator::MFTDMA_Slot;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Slot_Move.old_slot)
  return old_slot_;
}
inline ::communicator::MFTDMA_Slot* Slot_Move::release_old_slot() {
  // @@protoc_insertion_point(field_release:communicator.Slot_Move.old_slot)
  
  ::communicator::MFTDMA_Slot* temp = old_slot_;
  old_slot_ = NULL;
  return temp;
}
inline void Slot_Move::set_allocated_old_slot(::communicator::MFTDMA_Slot* old_slot) {
  delete old_slot_;
  old_slot_ = old_slot;
  if (old_slot) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Slot_Move.old_slot)
}

// .communicator.MFTDMA_Slot new_slot = 3;
inline bool Slot_Move::has_new_slot() const {
  return this != internal_default_instance() && new_slot_ != NULL;
}
inline void Slot_Move::clear_new_slot() {
  if (GetArenaNoVirtual() == NULL && new_slot_ != NULL) delete new_slot_;
  new_slot_ = NULL;
}
inline const ::communicator::MFTDMA_Slot& Slot_Move::new_slot() const {
  // @@protoc_insertion_point(field_get:communicator.Slot_Move.new_slot)
  return new_slot_ != NULL ? *new_slot_
                         : *::communicator::MFTDMA_Slot::internal_default_instance();
}
inline ::communicator::MFTDMA_Slot* Slot_Move::mutable_new_slot() {
  
  if (new_slot_ == NULL) {
    new_slot_ = new ::communicator::MFTDMA_Slot;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Slot_Move.new_slot)
  return new_slot_;
}
inline ::communicator::MFTDMA_Slot* Slot_Move::release_new_slot() {
  // @@protoc_insertion_point(field_release:communicator.Slot_Move.new_slot)
  
  ::communicator::MFTDMA_Slot* temp = new_slot_;
  new_slot_ = NULL;
  return temp;
}
inline void Slot_Move::set_allocated_new_slot(::communicator::MFTDMA_Slot* new_slot) {
  delete new_slot_;
  new_slot_ = new_slot;
  if (new_slot) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Slot_Move.new_slot)
}

// .communicator.SLOT_MODE mode = 4;
inline void Slot_Move::clear_mode() {
  mode_ = 0;
}
inline ::communicator::SLOT_MODE Slot_Move::mode() const {
  // @@protoc_insertion_point(field_get:communicator.Slot_Move.mode)
  return static_cast< ::communicator::SLOT_MODE >(mode_);
}
inline void Slot_Move::set_mode(::communicator::SLOT_MODE value) {
  
  mode_ = value;
  // @@protoc_insertion_point(field_set:communicator.Slot_Move.mode)
}

// -------------------------------------------------------------------

// External_Slot_Move

// uint64 src_mac = 1;
inline void External_Slot_Move::clear_src_mac() {
  src_mac_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 External_Slot_Move::src_mac() const {
  // @@protoc_insertion_point(field_get:communicator.External_Slot_Move.src_mac)
  return src_mac_;
}
inline void External_Slot_Move::set_src_mac(::google::protobuf::uint64 value) {
  
  src_mac_ = value;
  // @@protoc_insertion_point(field_set:communicator.External_Slot_Move.src_mac)
}

// uint64 dst_mac = 2;
inline void External_Slot_Move::clear_dst_mac() {
  dst_mac_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 External_Slot_Move::dst_mac() const {
  // @@protoc_insertion_point(field_get:communicator.External_Slot_Move.dst_mac)
  return dst_mac_;
}
inline void External_Slot_Move::set_dst_mac(::google::protobuf::uint64 value) {
  
  dst_mac_ = value;
  // @@protoc_insertion_point(field_set:communicator.External_Slot_Move.dst_mac)
}

// .communicator.MFTDMA_Slot old_slot = 3;
inline bool External_Slot_Move::has_old_slot() const {
  return this != internal_default_instance() && old_slot_ != NULL;
}
inline void External_Slot_Move::clear_old_slot() {
  if (GetArenaNoVirtual() == NULL && old_slot_ != NULL) delete old_slot_;
  old_slot_ = NULL;
}
inline const ::communicator::MFTDMA_Slot& External_Slot_Move::old_slot() const {
  // @@protoc_insertion_point(field_get:communicator.External_Slot_Move.old_slot)
  return old_slot_ != NULL ? *old_slot_
                         : *::communicator::MFTDMA_Slot::internal_default_instance();
}
inline ::communicator::MFTDMA_Slot* External_Slot_Move::mutable_old_slot() {
  
  if (old_slot_ == NULL) {
    old_slot_ = new ::communicator::MFTDMA_Slot;
  }
  // @@protoc_insertion_point(field_mutable:communicator.External_Slot_Move.old_slot)
  return old_slot_;
}
inline ::communicator::MFTDMA_Slot* External_Slot_Move::release_old_slot() {
  // @@protoc_insertion_point(field_release:communicator.External_Slot_Move.old_slot)
  
  ::communicator::MFTDMA_Slot* temp = old_slot_;
  old_slot_ = NULL;
  return temp;
}
inline void External_Slot_Move::set_allocated_old_slot(::communicator::MFTDMA_Slot* old_slot) {
  delete old_slot_;
  old_slot_ = old_slot;
  if (old_slot) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.External_Slot_Move.old_slot)
}

// .communicator.MFTDMA_Slot new_slot = 4;
inline bool External_Slot_Move::has_new_slot() const {
  return this != internal_default_instance() && new_slot_ != NULL;
}
inline void External_Slot_Move::clear_new_slot() {
  if (GetArenaNoVirtual() == NULL && new_slot_ != NULL) delete new_slot_;
  new_slot_ = NULL;
}
inline const ::communicator::MFTDMA_Slot& External_Slot_Move::new_slot() const {
  // @@protoc_insertion_point(field_get:communicator.External_Slot_Move.new_slot)
  return new_slot_ != NULL ? *new_slot_
                         : *::communicator::MFTDMA_Slot::internal_default_instance();
}
inline ::communicator::MFTDMA_Slot* External_Slot_Move::mutable_new_slot() {
  
  if (new_slot_ == NULL) {
    new_slot_ = new ::communicator::MFTDMA_Slot;
  }
  // @@protoc_insertion_point(field_mutable:communicator.External_Slot_Move.new_slot)
  return new_slot_;
}
inline ::communicator::MFTDMA_Slot* External_Slot_Move::release_new_slot() {
  // @@protoc_insertion_point(field_release:communicator.External_Slot_Move.new_slot)
  
  ::communicator::MFTDMA_Slot* temp = new_slot_;
  new_slot_ = NULL;
  return temp;
}
inline void External_Slot_Move::set_allocated_new_slot(::communicator::MFTDMA_Slot* new_slot) {
  delete new_slot_;
  new_slot_ = new_slot;
  if (new_slot) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.External_Slot_Move.new_slot)
}

// -------------------------------------------------------------------

// Get

// .communicator.Get.GET_ATTRIBUTE attribute = 1;
inline void Get::clear_attribute() {
  attribute_ = 0;
}
inline ::communicator::Get_GET_ATTRIBUTE Get::attribute() const {
  // @@protoc_insertion_point(field_get:communicator.Get.attribute)
  return static_cast< ::communicator::Get_GET_ATTRIBUTE >(attribute_);
}
inline void Get::set_attribute(::communicator::Get_GET_ATTRIBUTE value) {
  
  attribute_ = value;
  // @@protoc_insertion_point(field_set:communicator.Get.attribute)
}

// .communicator.Proposed_Slots_Request slot_request = 2;
inline bool Get::has_slot_request() const {
  return payload_case() == kSlotRequest;
}
inline void Get::set_has_slot_request() {
  _oneof_case_[0] = kSlotRequest;
}
inline void Get::clear_slot_request() {
  if (has_slot_request()) {
    delete payload_.slot_request_;
    clear_has_payload();
  }
}
inline  const ::communicator::Proposed_Slots_Request& Get::slot_request() const {
  // @@protoc_insertion_point(field_get:communicator.Get.slot_request)
  return has_slot_request()
      ? *payload_.slot_request_
      : ::communicator::Proposed_Slots_Request::default_instance();
}
inline ::communicator::Proposed_Slots_Request* Get::mutable_slot_request() {
  if (!has_slot_request()) {
    clear_payload();
    set_has_slot_request();
    payload_.slot_request_ = new ::communicator::Proposed_Slots_Request;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Get.slot_request)
  return payload_.slot_request_;
}
inline ::communicator::Proposed_Slots_Request* Get::release_slot_request() {
  // @@protoc_insertion_point(field_release:communicator.Get.slot_request)
  if (has_slot_request()) {
    clear_has_payload();
    ::communicator::Proposed_Slots_Request* temp = payload_.slot_request_;
    payload_.slot_request_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Get::set_allocated_slot_request(::communicator::Proposed_Slots_Request* slot_request) {
  clear_payload();
  if (slot_request) {
    set_has_slot_request();
    payload_.slot_request_ = slot_request;
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Get.slot_request)
}

// .communicator.Proposed_Slots proposed_slots = 3;
inline bool Get::has_proposed_slots() const {
  return payload_case() == kProposedSlots;
}
inline void Get::set_has_proposed_slots() {
  _oneof_case_[0] = kProposedSlots;
}
inline void Get::clear_proposed_slots() {
  if (has_proposed_slots()) {
    delete payload_.proposed_slots_;
    clear_has_payload();
  }
}
inline  const ::communicator::Proposed_Slots& Get::proposed_slots() const {
  // @@protoc_insertion_point(field_get:communicator.Get.proposed_slots)
  return has_proposed_slots()
      ? *payload_.proposed_slots_
      : ::communicator::Proposed_Slots::default_instance();
}
inline ::communicator::Proposed_Slots* Get::mutable_proposed_slots() {
  if (!has_proposed_slots()) {
    clear_payload();
    set_has_proposed_slots();
    payload_.proposed_slots_ = new ::communicator::Proposed_Slots;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Get.proposed_slots)
  return payload_.proposed_slots_;
}
inline ::communicator::Proposed_Slots* Get::release_proposed_slots() {
  // @@protoc_insertion_point(field_release:communicator.Get.proposed_slots)
  if (has_proposed_slots()) {
    clear_has_payload();
    ::communicator::Proposed_Slots* temp = payload_.proposed_slots_;
    payload_.proposed_slots_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Get::set_allocated_proposed_slots(::communicator::Proposed_Slots* proposed_slots) {
  clear_payload();
  if (proposed_slots) {
    set_has_proposed_slots();
    payload_.proposed_slots_ = proposed_slots;
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Get.proposed_slots)
}

// .communicator.Proposed_Move_Slots proposed_move_slots = 4;
inline bool Get::has_proposed_move_slots() const {
  return payload_case() == kProposedMoveSlots;
}
inline void Get::set_has_proposed_move_slots() {
  _oneof_case_[0] = kProposedMoveSlots;
}
inline void Get::clear_proposed_move_slots() {
  if (has_proposed_move_slots()) {
    delete payload_.proposed_move_slots_;
    clear_has_payload();
  }
}
inline  const ::communicator::Proposed_Move_Slots& Get::proposed_move_slots() const {
  // @@protoc_insertion_point(field_get:communicator.Get.proposed_move_slots)
  return has_proposed_move_slots()
      ? *payload_.proposed_move_slots_
      : ::communicator::Proposed_Move_Slots::default_instance();
}
inline ::communicator::Proposed_Move_Slots* Get::mutable_proposed_move_slots() {
  if (!has_proposed_move_slots()) {
    clear_payload();
    set_has_proposed_move_slots();
    payload_.proposed_move_slots_ = new ::communicator::Proposed_Move_Slots;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Get.proposed_move_slots)
  return payload_.proposed_move_slots_;
}
inline ::communicator::Proposed_Move_Slots* Get::release_proposed_move_slots() {
  // @@protoc_insertion_point(field_release:communicator.Get.proposed_move_slots)
  if (has_proposed_move_slots()) {
    clear_has_payload();
    ::communicator::Proposed_Move_Slots* temp = payload_.proposed_move_slots_;
    payload_.proposed_move_slots_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Get::set_allocated_proposed_move_slots(::communicator::Proposed_Move_Slots* proposed_move_slots) {
  clear_payload();
  if (proposed_move_slots) {
    set_has_proposed_move_slots();
    payload_.proposed_move_slots_ = proposed_move_slots;
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Get.proposed_move_slots)
}

inline bool Get::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Get::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Get::PayloadCase Get::payload_case() const {
  return Get::PayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Get_r

// .communicator.Mac_stat mac_stat = 1;
inline bool Get_r::has_mac_stat() const {
  return payload_case() == kMacStat;
}
inline void Get_r::set_has_mac_stat() {
  _oneof_case_[0] = kMacStat;
}
inline void Get_r::clear_mac_stat() {
  if (has_mac_stat()) {
    delete payload_.mac_stat_;
    clear_has_payload();
  }
}
inline  const ::communicator::Mac_stat& Get_r::mac_stat() const {
  // @@protoc_insertion_point(field_get:communicator.Get_r.mac_stat)
  return has_mac_stat()
      ? *payload_.mac_stat_
      : ::communicator::Mac_stat::default_instance();
}
inline ::communicator::Mac_stat* Get_r::mutable_mac_stat() {
  if (!has_mac_stat()) {
    clear_payload();
    set_has_mac_stat();
    payload_.mac_stat_ = new ::communicator::Mac_stat;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Get_r.mac_stat)
  return payload_.mac_stat_;
}
inline ::communicator::Mac_stat* Get_r::release_mac_stat() {
  // @@protoc_insertion_point(field_release:communicator.Get_r.mac_stat)
  if (has_mac_stat()) {
    clear_has_payload();
    ::communicator::Mac_stat* temp = payload_.mac_stat_;
    payload_.mac_stat_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Get_r::set_allocated_mac_stat(::communicator::Mac_stat* mac_stat) {
  clear_payload();
  if (mac_stat) {
    set_has_mac_stat();
    payload_.mac_stat_ = mac_stat;
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Get_r.mac_stat)
}

// .communicator.Basic_ctrl basic_ctrl = 2;
inline bool Get_r::has_basic_ctrl() const {
  return payload_case() == kBasicCtrl;
}
inline void Get_r::set_has_basic_ctrl() {
  _oneof_case_[0] = kBasicCtrl;
}
inline void Get_r::clear_basic_ctrl() {
  if (has_basic_ctrl()) {
    delete payload_.basic_ctrl_;
    clear_has_payload();
  }
}
inline  const ::communicator::Basic_ctrl& Get_r::basic_ctrl() const {
  // @@protoc_insertion_point(field_get:communicator.Get_r.basic_ctrl)
  return has_basic_ctrl()
      ? *payload_.basic_ctrl_
      : ::communicator::Basic_ctrl::default_instance();
}
inline ::communicator::Basic_ctrl* Get_r::mutable_basic_ctrl() {
  if (!has_basic_ctrl()) {
    clear_payload();
    set_has_basic_ctrl();
    payload_.basic_ctrl_ = new ::communicator::Basic_ctrl;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Get_r.basic_ctrl)
  return payload_.basic_ctrl_;
}
inline ::communicator::Basic_ctrl* Get_r::release_basic_ctrl() {
  // @@protoc_insertion_point(field_release:communicator.Get_r.basic_ctrl)
  if (has_basic_ctrl()) {
    clear_has_payload();
    ::communicator::Basic_ctrl* temp = payload_.basic_ctrl_;
    payload_.basic_ctrl_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Get_r::set_allocated_basic_ctrl(::communicator::Basic_ctrl* basic_ctrl) {
  clear_payload();
  if (basic_ctrl) {
    set_has_basic_ctrl();
    payload_.basic_ctrl_ = basic_ctrl;
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Get_r.basic_ctrl)
}

// .communicator.Proposed_Slots proposed_slots = 3;
inline bool Get_r::has_proposed_slots() const {
  return payload_case() == kProposedSlots;
}
inline void Get_r::set_has_proposed_slots() {
  _oneof_case_[0] = kProposedSlots;
}
inline void Get_r::clear_proposed_slots() {
  if (has_proposed_slots()) {
    delete payload_.proposed_slots_;
    clear_has_payload();
  }
}
inline  const ::communicator::Proposed_Slots& Get_r::proposed_slots() const {
  // @@protoc_insertion_point(field_get:communicator.Get_r.proposed_slots)
  return has_proposed_slots()
      ? *payload_.proposed_slots_
      : ::communicator::Proposed_Slots::default_instance();
}
inline ::communicator::Proposed_Slots* Get_r::mutable_proposed_slots() {
  if (!has_proposed_slots()) {
    clear_payload();
    set_has_proposed_slots();
    payload_.proposed_slots_ = new ::communicator::Proposed_Slots;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Get_r.proposed_slots)
  return payload_.proposed_slots_;
}
inline ::communicator::Proposed_Slots* Get_r::release_proposed_slots() {
  // @@protoc_insertion_point(field_release:communicator.Get_r.proposed_slots)
  if (has_proposed_slots()) {
    clear_has_payload();
    ::communicator::Proposed_Slots* temp = payload_.proposed_slots_;
    payload_.proposed_slots_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Get_r::set_allocated_proposed_slots(::communicator::Proposed_Slots* proposed_slots) {
  clear_payload();
  if (proposed_slots) {
    set_has_proposed_slots();
    payload_.proposed_slots_ = proposed_slots;
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Get_r.proposed_slots)
}

// .communicator.Selected_Slot selected_slot = 4;
inline bool Get_r::has_selected_slot() const {
  return payload_case() == kSelectedSlot;
}
inline void Get_r::set_has_selected_slot() {
  _oneof_case_[0] = kSelectedSlot;
}
inline void Get_r::clear_selected_slot() {
  if (has_selected_slot()) {
    delete payload_.selected_slot_;
    clear_has_payload();
  }
}
inline  const ::communicator::Selected_Slot& Get_r::selected_slot() const {
  // @@protoc_insertion_point(field_get:communicator.Get_r.selected_slot)
  return has_selected_slot()
      ? *payload_.selected_slot_
      : ::communicator::Selected_Slot::default_instance();
}
inline ::communicator::Selected_Slot* Get_r::mutable_selected_slot() {
  if (!has_selected_slot()) {
    clear_payload();
    set_has_selected_slot();
    payload_.selected_slot_ = new ::communicator::Selected_Slot;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Get_r.selected_slot)
  return payload_.selected_slot_;
}
inline ::communicator::Selected_Slot* Get_r::release_selected_slot() {
  // @@protoc_insertion_point(field_release:communicator.Get_r.selected_slot)
  if (has_selected_slot()) {
    clear_has_payload();
    ::communicator::Selected_Slot* temp = payload_.selected_slot_;
    payload_.selected_slot_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Get_r::set_allocated_selected_slot(::communicator::Selected_Slot* selected_slot) {
  clear_payload();
  if (selected_slot) {
    set_has_selected_slot();
    payload_.selected_slot_ = selected_slot;
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Get_r.selected_slot)
}

// .communicator.Selected_Move_Slot selected_move_slot = 5;
inline bool Get_r::has_selected_move_slot() const {
  return payload_case() == kSelectedMoveSlot;
}
inline void Get_r::set_has_selected_move_slot() {
  _oneof_case_[0] = kSelectedMoveSlot;
}
inline void Get_r::clear_selected_move_slot() {
  if (has_selected_move_slot()) {
    delete payload_.selected_move_slot_;
    clear_has_payload();
  }
}
inline  const ::communicator::Selected_Move_Slot& Get_r::selected_move_slot() const {
  // @@protoc_insertion_point(field_get:communicator.Get_r.selected_move_slot)
  return has_selected_move_slot()
      ? *payload_.selected_move_slot_
      : ::communicator::Selected_Move_Slot::default_instance();
}
inline ::communicator::Selected_Move_Slot* Get_r::mutable_selected_move_slot() {
  if (!has_selected_move_slot()) {
    clear_payload();
    set_has_selected_move_slot();
    payload_.selected_move_slot_ = new ::communicator::Selected_Move_Slot;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Get_r.selected_move_slot)
  return payload_.selected_move_slot_;
}
inline ::communicator::Selected_Move_Slot* Get_r::release_selected_move_slot() {
  // @@protoc_insertion_point(field_release:communicator.Get_r.selected_move_slot)
  if (has_selected_move_slot()) {
    clear_has_payload();
    ::communicator::Selected_Move_Slot* temp = payload_.selected_move_slot_;
    payload_.selected_move_slot_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Get_r::set_allocated_selected_move_slot(::communicator::Selected_Move_Slot* selected_move_slot) {
  clear_payload();
  if (selected_move_slot) {
    set_has_selected_move_slot();
    payload_.selected_move_slot_ = selected_move_slot;
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Get_r.selected_move_slot)
}

inline bool Get_r::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Get_r::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Get_r::PayloadCase Get_r::payload_case() const {
  return Get_r::PayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Set

// .communicator.Link_MCS_TxGain_BW mcs_txgain_bw = 1;
inline bool Set::has_mcs_txgain_bw() const {
  return payload_case() == kMcsTxgainBw;
}
inline void Set::set_has_mcs_txgain_bw() {
  _oneof_case_[0] = kMcsTxgainBw;
}
inline void Set::clear_mcs_txgain_bw() {
  if (has_mcs_txgain_bw()) {
    delete payload_.mcs_txgain_bw_;
    clear_has_payload();
  }
}
inline  const ::communicator::Link_MCS_TxGain_BW& Set::mcs_txgain_bw() const {
  // @@protoc_insertion_point(field_get:communicator.Set.mcs_txgain_bw)
  return has_mcs_txgain_bw()
      ? *payload_.mcs_txgain_bw_
      : ::communicator::Link_MCS_TxGain_BW::default_instance();
}
inline ::communicator::Link_MCS_TxGain_BW* Set::mutable_mcs_txgain_bw() {
  if (!has_mcs_txgain_bw()) {
    clear_payload();
    set_has_mcs_txgain_bw();
    payload_.mcs_txgain_bw_ = new ::communicator::Link_MCS_TxGain_BW;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Set.mcs_txgain_bw)
  return payload_.mcs_txgain_bw_;
}
inline ::communicator::Link_MCS_TxGain_BW* Set::release_mcs_txgain_bw() {
  // @@protoc_insertion_point(field_release:communicator.Set.mcs_txgain_bw)
  if (has_mcs_txgain_bw()) {
    clear_has_payload();
    ::communicator::Link_MCS_TxGain_BW* temp = payload_.mcs_txgain_bw_;
    payload_.mcs_txgain_bw_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Set::set_allocated_mcs_txgain_bw(::communicator::Link_MCS_TxGain_BW* mcs_txgain_bw) {
  clear_payload();
  if (mcs_txgain_bw) {
    set_has_mcs_txgain_bw();
    payload_.mcs_txgain_bw_ = mcs_txgain_bw;
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Set.mcs_txgain_bw)
}

// uint32 ch = 2;
inline bool Set::has_ch() const {
  return payload_case() == kCh;
}
inline void Set::set_has_ch() {
  _oneof_case_[0] = kCh;
}
inline void Set::clear_ch() {
  if (has_ch()) {
    payload_.ch_ = 0u;
    clear_has_payload();
  }
}
inline ::google::protobuf::uint32 Set::ch() const {
  // @@protoc_insertion_point(field_get:communicator.Set.ch)
  if (has_ch()) {
    return payload_.ch_;
  }
  return 0u;
}
inline void Set::set_ch(::google::protobuf::uint32 value) {
  if (!has_ch()) {
    clear_payload();
    set_has_ch();
  }
  payload_.ch_ = value;
  // @@protoc_insertion_point(field_set:communicator.Set.ch)
}

// .communicator.External_Slot_Allocation external_slot_allocation = 3;
inline bool Set::has_external_slot_allocation() const {
  return payload_case() == kExternalSlotAllocation;
}
inline void Set::set_has_external_slot_allocation() {
  _oneof_case_[0] = kExternalSlotAllocation;
}
inline void Set::clear_external_slot_allocation() {
  if (has_external_slot_allocation()) {
    delete payload_.external_slot_allocation_;
    clear_has_payload();
  }
}
inline  const ::communicator::External_Slot_Allocation& Set::external_slot_allocation() const {
  // @@protoc_insertion_point(field_get:communicator.Set.external_slot_allocation)
  return has_external_slot_allocation()
      ? *payload_.external_slot_allocation_
      : ::communicator::External_Slot_Allocation::default_instance();
}
inline ::communicator::External_Slot_Allocation* Set::mutable_external_slot_allocation() {
  if (!has_external_slot_allocation()) {
    clear_payload();
    set_has_external_slot_allocation();
    payload_.external_slot_allocation_ = new ::communicator::External_Slot_Allocation;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Set.external_slot_allocation)
  return payload_.external_slot_allocation_;
}
inline ::communicator::External_Slot_Allocation* Set::release_external_slot_allocation() {
  // @@protoc_insertion_point(field_release:communicator.Set.external_slot_allocation)
  if (has_external_slot_allocation()) {
    clear_has_payload();
    ::communicator::External_Slot_Allocation* temp = payload_.external_slot_allocation_;
    payload_.external_slot_allocation_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Set::set_allocated_external_slot_allocation(::communicator::External_Slot_Allocation* external_slot_allocation) {
  clear_payload();
  if (external_slot_allocation) {
    set_has_external_slot_allocation();
    payload_.external_slot_allocation_ = external_slot_allocation;
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Set.external_slot_allocation)
}

// .communicator.External_Slot_Removal external_slot_removal = 4;
inline bool Set::has_external_slot_removal() const {
  return payload_case() == kExternalSlotRemoval;
}
inline void Set::set_has_external_slot_removal() {
  _oneof_case_[0] = kExternalSlotRemoval;
}
inline void Set::clear_external_slot_removal() {
  if (has_external_slot_removal()) {
    delete payload_.external_slot_removal_;
    clear_has_payload();
  }
}
inline  const ::communicator::External_Slot_Removal& Set::external_slot_removal() const {
  // @@protoc_insertion_point(field_get:communicator.Set.external_slot_removal)
  return has_external_slot_removal()
      ? *payload_.external_slot_removal_
      : ::communicator::External_Slot_Removal::default_instance();
}
inline ::communicator::External_Slot_Removal* Set::mutable_external_slot_removal() {
  if (!has_external_slot_removal()) {
    clear_payload();
    set_has_external_slot_removal();
    payload_.external_slot_removal_ = new ::communicator::External_Slot_Removal;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Set.external_slot_removal)
  return payload_.external_slot_removal_;
}
inline ::communicator::External_Slot_Removal* Set::release_external_slot_removal() {
  // @@protoc_insertion_point(field_release:communicator.Set.external_slot_removal)
  if (has_external_slot_removal()) {
    clear_has_payload();
    ::communicator::External_Slot_Removal* temp = payload_.external_slot_removal_;
    payload_.external_slot_removal_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Set::set_allocated_external_slot_removal(::communicator::External_Slot_Removal* external_slot_removal) {
  clear_payload();
  if (external_slot_removal) {
    set_has_external_slot_removal();
    payload_.external_slot_removal_ = external_slot_removal;
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Set.external_slot_removal)
}

// .communicator.Slot_Allocation slot_allocation = 5;
inline bool Set::has_slot_allocation() const {
  return payload_case() == kSlotAllocation;
}
inline void Set::set_has_slot_allocation() {
  _oneof_case_[0] = kSlotAllocation;
}
inline void Set::clear_slot_allocation() {
  if (has_slot_allocation()) {
    delete payload_.slot_allocation_;
    clear_has_payload();
  }
}
inline  const ::communicator::Slot_Allocation& Set::slot_allocation() const {
  // @@protoc_insertion_point(field_get:communicator.Set.slot_allocation)
  return has_slot_allocation()
      ? *payload_.slot_allocation_
      : ::communicator::Slot_Allocation::default_instance();
}
inline ::communicator::Slot_Allocation* Set::mutable_slot_allocation() {
  if (!has_slot_allocation()) {
    clear_payload();
    set_has_slot_allocation();
    payload_.slot_allocation_ = new ::communicator::Slot_Allocation;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Set.slot_allocation)
  return payload_.slot_allocation_;
}
inline ::communicator::Slot_Allocation* Set::release_slot_allocation() {
  // @@protoc_insertion_point(field_release:communicator.Set.slot_allocation)
  if (has_slot_allocation()) {
    clear_has_payload();
    ::communicator::Slot_Allocation* temp = payload_.slot_allocation_;
    payload_.slot_allocation_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Set::set_allocated_slot_allocation(::communicator::Slot_Allocation* slot_allocation) {
  clear_payload();
  if (slot_allocation) {
    set_has_slot_allocation();
    payload_.slot_allocation_ = slot_allocation;
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Set.slot_allocation)
}

// .communicator.Slot_Removal slot_removal = 6;
inline bool Set::has_slot_removal() const {
  return payload_case() == kSlotRemoval;
}
inline void Set::set_has_slot_removal() {
  _oneof_case_[0] = kSlotRemoval;
}
inline void Set::clear_slot_removal() {
  if (has_slot_removal()) {
    delete payload_.slot_removal_;
    clear_has_payload();
  }
}
inline  const ::communicator::Slot_Removal& Set::slot_removal() const {
  // @@protoc_insertion_point(field_get:communicator.Set.slot_removal)
  return has_slot_removal()
      ? *payload_.slot_removal_
      : ::communicator::Slot_Removal::default_instance();
}
inline ::communicator::Slot_Removal* Set::mutable_slot_removal() {
  if (!has_slot_removal()) {
    clear_payload();
    set_has_slot_removal();
    payload_.slot_removal_ = new ::communicator::Slot_Removal;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Set.slot_removal)
  return payload_.slot_removal_;
}
inline ::communicator::Slot_Removal* Set::release_slot_removal() {
  // @@protoc_insertion_point(field_release:communicator.Set.slot_removal)
  if (has_slot_removal()) {
    clear_has_payload();
    ::communicator::Slot_Removal* temp = payload_.slot_removal_;
    payload_.slot_removal_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Set::set_allocated_slot_removal(::communicator::Slot_Removal* slot_removal) {
  clear_payload();
  if (slot_removal) {
    set_has_slot_removal();
    payload_.slot_removal_ = slot_removal;
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Set.slot_removal)
}

// .communicator.BC_Slots_Announcement bc_slots_announcement = 7;
inline bool Set::has_bc_slots_announcement() const {
  return payload_case() == kBcSlotsAnnouncement;
}
inline void Set::set_has_bc_slots_announcement() {
  _oneof_case_[0] = kBcSlotsAnnouncement;
}
inline void Set::clear_bc_slots_announcement() {
  if (has_bc_slots_announcement()) {
    delete payload_.bc_slots_announcement_;
    clear_has_payload();
  }
}
inline  const ::communicator::BC_Slots_Announcement& Set::bc_slots_announcement() const {
  // @@protoc_insertion_point(field_get:communicator.Set.bc_slots_announcement)
  return has_bc_slots_announcement()
      ? *payload_.bc_slots_announcement_
      : ::communicator::BC_Slots_Announcement::default_instance();
}
inline ::communicator::BC_Slots_Announcement* Set::mutable_bc_slots_announcement() {
  if (!has_bc_slots_announcement()) {
    clear_payload();
    set_has_bc_slots_announcement();
    payload_.bc_slots_announcement_ = new ::communicator::BC_Slots_Announcement;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Set.bc_slots_announcement)
  return payload_.bc_slots_announcement_;
}
inline ::communicator::BC_Slots_Announcement* Set::release_bc_slots_announcement() {
  // @@protoc_insertion_point(field_release:communicator.Set.bc_slots_announcement)
  if (has_bc_slots_announcement()) {
    clear_has_payload();
    ::communicator::BC_Slots_Announcement* temp = payload_.bc_slots_announcement_;
    payload_.bc_slots_announcement_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Set::set_allocated_bc_slots_announcement(::communicator::BC_Slots_Announcement* bc_slots_announcement) {
  clear_payload();
  if (bc_slots_announcement) {
    set_has_bc_slots_announcement();
    payload_.bc_slots_announcement_ = bc_slots_announcement;
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Set.bc_slots_announcement)
}

// bool outcomes_updated = 8;
inline bool Set::has_outcomes_updated() const {
  return payload_case() == kOutcomesUpdated;
}
inline void Set::set_has_outcomes_updated() {
  _oneof_case_[0] = kOutcomesUpdated;
}
inline void Set::clear_outcomes_updated() {
  if (has_outcomes_updated()) {
    payload_.outcomes_updated_ = false;
    clear_has_payload();
  }
}
inline bool Set::outcomes_updated() const {
  // @@protoc_insertion_point(field_get:communicator.Set.outcomes_updated)
  if (has_outcomes_updated()) {
    return payload_.outcomes_updated_;
  }
  return false;
}
inline void Set::set_outcomes_updated(bool value) {
  if (!has_outcomes_updated()) {
    clear_payload();
    set_has_outcomes_updated();
  }
  payload_.outcomes_updated_ = value;
  // @@protoc_insertion_point(field_set:communicator.Set.outcomes_updated)
}

// .communicator.External_Slot_Move external_slot_move = 9;
inline bool Set::has_external_slot_move() const {
  return payload_case() == kExternalSlotMove;
}
inline void Set::set_has_external_slot_move() {
  _oneof_case_[0] = kExternalSlotMove;
}
inline void Set::clear_external_slot_move() {
  if (has_external_slot_move()) {
    delete payload_.external_slot_move_;
    clear_has_payload();
  }
}
inline  const ::communicator::External_Slot_Move& Set::external_slot_move() const {
  // @@protoc_insertion_point(field_get:communicator.Set.external_slot_move)
  return has_external_slot_move()
      ? *payload_.external_slot_move_
      : ::communicator::External_Slot_Move::default_instance();
}
inline ::communicator::External_Slot_Move* Set::mutable_external_slot_move() {
  if (!has_external_slot_move()) {
    clear_payload();
    set_has_external_slot_move();
    payload_.external_slot_move_ = new ::communicator::External_Slot_Move;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Set.external_slot_move)
  return payload_.external_slot_move_;
}
inline ::communicator::External_Slot_Move* Set::release_external_slot_move() {
  // @@protoc_insertion_point(field_release:communicator.Set.external_slot_move)
  if (has_external_slot_move()) {
    clear_has_payload();
    ::communicator::External_Slot_Move* temp = payload_.external_slot_move_;
    payload_.external_slot_move_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Set::set_allocated_external_slot_move(::communicator::External_Slot_Move* external_slot_move) {
  clear_payload();
  if (external_slot_move) {
    set_has_external_slot_move();
    payload_.external_slot_move_ = external_slot_move;
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Set.external_slot_move)
}

// .communicator.Proposed_Move_Slots proposed_move_slots = 10;
inline bool Set::has_proposed_move_slots() const {
  return payload_case() == kProposedMoveSlots;
}
inline void Set::set_has_proposed_move_slots() {
  _oneof_case_[0] = kProposedMoveSlots;
}
inline void Set::clear_proposed_move_slots() {
  if (has_proposed_move_slots()) {
    delete payload_.proposed_move_slots_;
    clear_has_payload();
  }
}
inline  const ::communicator::Proposed_Move_Slots& Set::proposed_move_slots() const {
  // @@protoc_insertion_point(field_get:communicator.Set.proposed_move_slots)
  return has_proposed_move_slots()
      ? *payload_.proposed_move_slots_
      : ::communicator::Proposed_Move_Slots::default_instance();
}
inline ::communicator::Proposed_Move_Slots* Set::mutable_proposed_move_slots() {
  if (!has_proposed_move_slots()) {
    clear_payload();
    set_has_proposed_move_slots();
    payload_.proposed_move_slots_ = new ::communicator::Proposed_Move_Slots;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Set.proposed_move_slots)
  return payload_.proposed_move_slots_;
}
inline ::communicator::Proposed_Move_Slots* Set::release_proposed_move_slots() {
  // @@protoc_insertion_point(field_release:communicator.Set.proposed_move_slots)
  if (has_proposed_move_slots()) {
    clear_has_payload();
    ::communicator::Proposed_Move_Slots* temp = payload_.proposed_move_slots_;
    payload_.proposed_move_slots_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Set::set_allocated_proposed_move_slots(::communicator::Proposed_Move_Slots* proposed_move_slots) {
  clear_payload();
  if (proposed_move_slots) {
    set_has_proposed_move_slots();
    payload_.proposed_move_slots_ = proposed_move_slots;
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Set.proposed_move_slots)
}

// .communicator.Slot_Move slot_move = 11;
inline bool Set::has_slot_move() const {
  return payload_case() == kSlotMove;
}
inline void Set::set_has_slot_move() {
  _oneof_case_[0] = kSlotMove;
}
inline void Set::clear_slot_move() {
  if (has_slot_move()) {
    delete payload_.slot_move_;
    clear_has_payload();
  }
}
inline  const ::communicator::Slot_Move& Set::slot_move() const {
  // @@protoc_insertion_point(field_get:communicator.Set.slot_move)
  return has_slot_move()
      ? *payload_.slot_move_
      : ::communicator::Slot_Move::default_instance();
}
inline ::communicator::Slot_Move* Set::mutable_slot_move() {
  if (!has_slot_move()) {
    clear_payload();
    set_has_slot_move();
    payload_.slot_move_ = new ::communicator::Slot_Move;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Set.slot_move)
  return payload_.slot_move_;
}
inline ::communicator::Slot_Move* Set::release_slot_move() {
  // @@protoc_insertion_point(field_release:communicator.Set.slot_move)
  if (has_slot_move()) {
    clear_has_payload();
    ::communicator::Slot_Move* temp = payload_.slot_move_;
    payload_.slot_move_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Set::set_allocated_slot_move(::communicator::Slot_Move* slot_move) {
  clear_payload();
  if (slot_move) {
    set_has_slot_move();
    payload_.slot_move_ = slot_move;
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Set.slot_move)
}

inline bool Set::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Set::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Set::PayloadCase Set::payload_case() const {
  return Set::PayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Set_r

// .communicator.TRANSACTION_RESULT result = 1;
inline void Set_r::clear_result() {
  result_ = 0;
}
inline ::communicator::TRANSACTION_RESULT Set_r::result() const {
  // @@protoc_insertion_point(field_get:communicator.Set_r.result)
  return static_cast< ::communicator::TRANSACTION_RESULT >(result_);
}
inline void Set_r::set_result(::communicator::TRANSACTION_RESULT value) {
  
  result_ = value;
  // @@protoc_insertion_point(field_set:communicator.Set_r.result)
}

// -------------------------------------------------------------------

// Send

// .communicator.Application_data app_data = 1;
inline bool Send::has_app_data() const {
  return this != internal_default_instance() && app_data_ != NULL;
}
inline void Send::clear_app_data() {
  if (GetArenaNoVirtual() == NULL && app_data_ != NULL) delete app_data_;
  app_data_ = NULL;
}
inline const ::communicator::Application_data& Send::app_data() const {
  // @@protoc_insertion_point(field_get:communicator.Send.app_data)
  return app_data_ != NULL ? *app_data_
                         : *::communicator::Application_data::internal_default_instance();
}
inline ::communicator::Application_data* Send::mutable_app_data() {
  
  if (app_data_ == NULL) {
    app_data_ = new ::communicator::Application_data;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Send.app_data)
  return app_data_;
}
inline ::communicator::Application_data* Send::release_app_data() {
  // @@protoc_insertion_point(field_release:communicator.Send.app_data)
  
  ::communicator::Application_data* temp = app_data_;
  app_data_ = NULL;
  return temp;
}
inline void Send::set_allocated_app_data(::communicator::Application_data* app_data) {
  delete app_data_;
  app_data_ = app_data;
  if (app_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Send.app_data)
}

// .communicator.Basic_ctrl basic_ctrl = 2;
inline bool Send::has_basic_ctrl() const {
  return this != internal_default_instance() && basic_ctrl_ != NULL;
}
inline void Send::clear_basic_ctrl() {
  if (GetArenaNoVirtual() == NULL && basic_ctrl_ != NULL) delete basic_ctrl_;
  basic_ctrl_ = NULL;
}
inline const ::communicator::Basic_ctrl& Send::basic_ctrl() const {
  // @@protoc_insertion_point(field_get:communicator.Send.basic_ctrl)
  return basic_ctrl_ != NULL ? *basic_ctrl_
                         : *::communicator::Basic_ctrl::internal_default_instance();
}
inline ::communicator::Basic_ctrl* Send::mutable_basic_ctrl() {
  
  if (basic_ctrl_ == NULL) {
    basic_ctrl_ = new ::communicator::Basic_ctrl;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Send.basic_ctrl)
  return basic_ctrl_;
}
inline ::communicator::Basic_ctrl* Send::release_basic_ctrl() {
  // @@protoc_insertion_point(field_release:communicator.Send.basic_ctrl)
  
  ::communicator::Basic_ctrl* temp = basic_ctrl_;
  basic_ctrl_ = NULL;
  return temp;
}
inline void Send::set_allocated_basic_ctrl(::communicator::Basic_ctrl* basic_ctrl) {
  delete basic_ctrl_;
  basic_ctrl_ = basic_ctrl;
  if (basic_ctrl) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Send.basic_ctrl)
}

// -------------------------------------------------------------------

// Send_r

// .communicator.TRANSACTION_RESULT result = 1;
inline void Send_r::clear_result() {
  result_ = 0;
}
inline ::communicator::TRANSACTION_RESULT Send_r::result() const {
  // @@protoc_insertion_point(field_get:communicator.Send_r.result)
  return static_cast< ::communicator::TRANSACTION_RESULT >(result_);
}
inline void Send_r::set_result(::communicator::TRANSACTION_RESULT value) {
  
  result_ = value;
  // @@protoc_insertion_point(field_set:communicator.Send_r.result)
}

// .communicator.Phy_stat phy_stat = 2;
inline bool Send_r::has_phy_stat() const {
  return payload_case() == kPhyStat;
}
inline void Send_r::set_has_phy_stat() {
  _oneof_case_[0] = kPhyStat;
}
inline void Send_r::clear_phy_stat() {
  if (has_phy_stat()) {
    delete payload_.phy_stat_;
    clear_has_payload();
  }
}
inline  const ::communicator::Phy_stat& Send_r::phy_stat() const {
  // @@protoc_insertion_point(field_get:communicator.Send_r.phy_stat)
  return has_phy_stat()
      ? *payload_.phy_stat_
      : ::communicator::Phy_stat::default_instance();
}
inline ::communicator::Phy_stat* Send_r::mutable_phy_stat() {
  if (!has_phy_stat()) {
    clear_payload();
    set_has_phy_stat();
    payload_.phy_stat_ = new ::communicator::Phy_stat;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Send_r.phy_stat)
  return payload_.phy_stat_;
}
inline ::communicator::Phy_stat* Send_r::release_phy_stat() {
  // @@protoc_insertion_point(field_release:communicator.Send_r.phy_stat)
  if (has_phy_stat()) {
    clear_has_payload();
    ::communicator::Phy_stat* temp = payload_.phy_stat_;
    payload_.phy_stat_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Send_r::set_allocated_phy_stat(::communicator::Phy_stat* phy_stat) {
  clear_payload();
  if (phy_stat) {
    set_has_phy_stat();
    payload_.phy_stat_ = phy_stat;
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Send_r.phy_stat)
}

// .communicator.Mac_stat mac_result = 3;
inline bool Send_r::has_mac_result() const {
  return payload_case() == kMacResult;
}
inline void Send_r::set_has_mac_result() {
  _oneof_case_[0] = kMacResult;
}
inline void Send_r::clear_mac_result() {
  if (has_mac_result()) {
    delete payload_.mac_result_;
    clear_has_payload();
  }
}
inline  const ::communicator::Mac_stat& Send_r::mac_result() const {
  // @@protoc_insertion_point(field_get:communicator.Send_r.mac_result)
  return has_mac_result()
      ? *payload_.mac_result_
      : ::communicator::Mac_stat::default_instance();
}
inline ::communicator::Mac_stat* Send_r::mutable_mac_result() {
  if (!has_mac_result()) {
    clear_payload();
    set_has_mac_result();
    payload_.mac_result_ = new ::communicator::Mac_stat;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Send_r.mac_result)
  return payload_.mac_result_;
}
inline ::communicator::Mac_stat* Send_r::release_mac_result() {
  // @@protoc_insertion_point(field_release:communicator.Send_r.mac_result)
  if (has_mac_result()) {
    clear_has_payload();
    ::communicator::Mac_stat* temp = payload_.mac_result_;
    payload_.mac_result_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Send_r::set_allocated_mac_result(::communicator::Mac_stat* mac_result) {
  clear_payload();
  if (mac_result) {
    set_has_mac_result();
    payload_.mac_result_ = mac_result;
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Send_r.mac_result)
}

inline bool Send_r::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Send_r::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Send_r::PayloadCase Send_r::payload_case() const {
  return Send_r::PayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Receive

// .communicator.Basic_ctrl basic_ctrl = 1;
inline bool Receive::has_basic_ctrl() const {
  return payload_case() == kBasicCtrl;
}
inline void Receive::set_has_basic_ctrl() {
  _oneof_case_[0] = kBasicCtrl;
}
inline void Receive::clear_basic_ctrl() {
  if (has_basic_ctrl()) {
    delete payload_.basic_ctrl_;
    clear_has_payload();
  }
}
inline  const ::communicator::Basic_ctrl& Receive::basic_ctrl() const {
  // @@protoc_insertion_point(field_get:communicator.Receive.basic_ctrl)
  return has_basic_ctrl()
      ? *payload_.basic_ctrl_
      : ::communicator::Basic_ctrl::default_instance();
}
inline ::communicator::Basic_ctrl* Receive::mutable_basic_ctrl() {
  if (!has_basic_ctrl()) {
    clear_payload();
    set_has_basic_ctrl();
    payload_.basic_ctrl_ = new ::communicator::Basic_ctrl;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Receive.basic_ctrl)
  return payload_.basic_ctrl_;
}
inline ::communicator::Basic_ctrl* Receive::release_basic_ctrl() {
  // @@protoc_insertion_point(field_release:communicator.Receive.basic_ctrl)
  if (has_basic_ctrl()) {
    clear_has_payload();
    ::communicator::Basic_ctrl* temp = payload_.basic_ctrl_;
    payload_.basic_ctrl_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Receive::set_allocated_basic_ctrl(::communicator::Basic_ctrl* basic_ctrl) {
  clear_payload();
  if (basic_ctrl) {
    set_has_basic_ctrl();
    payload_.basic_ctrl_ = basic_ctrl;
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Receive.basic_ctrl)
}

// bytes data = 2;
inline bool Receive::has_data() const {
  return payload_case() == kData;
}
inline void Receive::set_has_data() {
  _oneof_case_[0] = kData;
}
inline void Receive::clear_data() {
  if (has_data()) {
    payload_.data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_payload();
  }
}
inline const ::std::string& Receive::data() const {
  // @@protoc_insertion_point(field_get:communicator.Receive.data)
  if (has_data()) {
    return payload_.data_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Receive::set_data(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:communicator.Receive.data)
  if (!has_data()) {
    clear_payload();
    set_has_data();
    payload_.data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:communicator.Receive.data)
}
#if LANG_CXX11
inline void Receive::set_data(::std::string&& value) {
  // @@protoc_insertion_point(field_set:communicator.Receive.data)
  if (!has_data()) {
    clear_payload();
    set_has_data();
    payload_.data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:communicator.Receive.data)
}
#endif
inline void Receive::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_data()) {
    clear_payload();
    set_has_data();
    payload_.data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:communicator.Receive.data)
}
inline void Receive::set_data(const void* value, size_t size) {
  if (!has_data()) {
    clear_payload();
    set_has_data();
    payload_.data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  payload_.data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:communicator.Receive.data)
}
inline ::std::string* Receive::mutable_data() {
  if (!has_data()) {
    clear_payload();
    set_has_data();
    payload_.data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:communicator.Receive.data)
  return payload_.data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Receive::release_data() {
  // @@protoc_insertion_point(field_release:communicator.Receive.data)
  if (has_data()) {
    clear_has_payload();
    return payload_.data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void Receive::set_allocated_data(::std::string* data) {
  if (!has_data()) {
    payload_.data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_payload();
  if (data != NULL) {
    set_has_data();
    payload_.data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        data);
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Receive.data)
}

inline bool Receive::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Receive::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Receive::PayloadCase Receive::payload_case() const {
  return Receive::PayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Receive_r

// .communicator.TRANSACTION_RESULT result = 1;
inline void Receive_r::clear_result() {
  result_ = 0;
}
inline ::communicator::TRANSACTION_RESULT Receive_r::result() const {
  // @@protoc_insertion_point(field_get:communicator.Receive_r.result)
  return static_cast< ::communicator::TRANSACTION_RESULT >(result_);
}
inline void Receive_r::set_result(::communicator::TRANSACTION_RESULT value) {
  
  result_ = value;
  // @@protoc_insertion_point(field_set:communicator.Receive_r.result)
}

// bytes data = 2;
inline void Receive_r::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Receive_r::data() const {
  // @@protoc_insertion_point(field_get:communicator.Receive_r.data)
  return data_.GetNoArena();
}
inline void Receive_r::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:communicator.Receive_r.data)
}
#if LANG_CXX11
inline void Receive_r::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:communicator.Receive_r.data)
}
#endif
inline void Receive_r::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:communicator.Receive_r.data)
}
inline void Receive_r::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:communicator.Receive_r.data)
}
inline ::std::string* Receive_r::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:communicator.Receive_r.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Receive_r::release_data() {
  // @@protoc_insertion_point(field_release:communicator.Receive_r.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Receive_r::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:communicator.Receive_r.data)
}

// .communicator.Phy_stat stat = 3;
inline bool Receive_r::has_stat() const {
  return this != internal_default_instance() && stat_ != NULL;
}
inline void Receive_r::clear_stat() {
  if (GetArenaNoVirtual() == NULL && stat_ != NULL) delete stat_;
  stat_ = NULL;
}
inline const ::communicator::Phy_stat& Receive_r::stat() const {
  // @@protoc_insertion_point(field_get:communicator.Receive_r.stat)
  return stat_ != NULL ? *stat_
                         : *::communicator::Phy_stat::internal_default_instance();
}
inline ::communicator::Phy_stat* Receive_r::mutable_stat() {
  
  if (stat_ == NULL) {
    stat_ = new ::communicator::Phy_stat;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Receive_r.stat)
  return stat_;
}
inline ::communicator::Phy_stat* Receive_r::release_stat() {
  // @@protoc_insertion_point(field_release:communicator.Receive_r.stat)
  
  ::communicator::Phy_stat* temp = stat_;
  stat_ = NULL;
  return temp;
}
inline void Receive_r::set_allocated_stat(::communicator::Phy_stat* stat) {
  delete stat_;
  stat_ = stat;
  if (stat) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Receive_r.stat)
}

// -------------------------------------------------------------------

// Stats

// uint64 mac_address = 1;
inline void Stats::clear_mac_address() {
  mac_address_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Stats::mac_address() const {
  // @@protoc_insertion_point(field_get:communicator.Stats.mac_address)
  return mac_address_;
}
inline void Stats::set_mac_address(::google::protobuf::uint64 value) {
  
  mac_address_ = value;
  // @@protoc_insertion_point(field_set:communicator.Stats.mac_address)
}

// .communicator.Phy_stat phy_stat = 2;
inline bool Stats::has_phy_stat() const {
  return this != internal_default_instance() && phy_stat_ != NULL;
}
inline void Stats::clear_phy_stat() {
  if (GetArenaNoVirtual() == NULL && phy_stat_ != NULL) delete phy_stat_;
  phy_stat_ = NULL;
}
inline const ::communicator::Phy_stat& Stats::phy_stat() const {
  // @@protoc_insertion_point(field_get:communicator.Stats.phy_stat)
  return phy_stat_ != NULL ? *phy_stat_
                         : *::communicator::Phy_stat::internal_default_instance();
}
inline ::communicator::Phy_stat* Stats::mutable_phy_stat() {
  
  if (phy_stat_ == NULL) {
    phy_stat_ = new ::communicator::Phy_stat;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Stats.phy_stat)
  return phy_stat_;
}
inline ::communicator::Phy_stat* Stats::release_phy_stat() {
  // @@protoc_insertion_point(field_release:communicator.Stats.phy_stat)
  
  ::communicator::Phy_stat* temp = phy_stat_;
  phy_stat_ = NULL;
  return temp;
}
inline void Stats::set_allocated_phy_stat(::communicator::Phy_stat* phy_stat) {
  delete phy_stat_;
  phy_stat_ = phy_stat;
  if (phy_stat) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Stats.phy_stat)
}

// .communicator.Mac_stat mac_stat = 3;
inline bool Stats::has_mac_stat() const {
  return this != internal_default_instance() && mac_stat_ != NULL;
}
inline void Stats::clear_mac_stat() {
  if (GetArenaNoVirtual() == NULL && mac_stat_ != NULL) delete mac_stat_;
  mac_stat_ = NULL;
}
inline const ::communicator::Mac_stat& Stats::mac_stat() const {
  // @@protoc_insertion_point(field_get:communicator.Stats.mac_stat)
  return mac_stat_ != NULL ? *mac_stat_
                         : *::communicator::Mac_stat::internal_default_instance();
}
inline ::communicator::Mac_stat* Stats::mutable_mac_stat() {
  
  if (mac_stat_ == NULL) {
    mac_stat_ = new ::communicator::Mac_stat;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Stats.mac_stat)
  return mac_stat_;
}
inline ::communicator::Mac_stat* Stats::release_mac_stat() {
  // @@protoc_insertion_point(field_release:communicator.Stats.mac_stat)
  
  ::communicator::Mac_stat* temp = mac_stat_;
  mac_stat_ = NULL;
  return temp;
}
inline void Stats::set_allocated_mac_stat(::communicator::Mac_stat* mac_stat) {
  delete mac_stat_;
  mac_stat_ = mac_stat;
  if (mac_stat) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Stats.mac_stat)
}

// -------------------------------------------------------------------

// Internal

// uint64 transaction_index = 1;
inline void Internal::clear_transaction_index() {
  transaction_index_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Internal::transaction_index() const {
  // @@protoc_insertion_point(field_get:communicator.Internal.transaction_index)
  return transaction_index_;
}
inline void Internal::set_transaction_index(::google::protobuf::uint64 value) {
  
  transaction_index_ = value;
  // @@protoc_insertion_point(field_set:communicator.Internal.transaction_index)
}

// .communicator.MODULE owner_module = 2;
inline void Internal::clear_owner_module() {
  owner_module_ = 0;
}
inline ::communicator::MODULE Internal::owner_module() const {
  // @@protoc_insertion_point(field_get:communicator.Internal.owner_module)
  return static_cast< ::communicator::MODULE >(owner_module_);
}
inline void Internal::set_owner_module(::communicator::MODULE value) {
  
  owner_module_ = value;
  // @@protoc_insertion_point(field_set:communicator.Internal.owner_module)
}

// .communicator.Get get = 3;
inline bool Internal::has_get() const {
  return payload_case() == kGet;
}
inline void Internal::set_has_get() {
  _oneof_case_[0] = kGet;
}
inline void Internal::clear_get() {
  if (has_get()) {
    delete payload_.get_;
    clear_has_payload();
  }
}
inline  const ::communicator::Get& Internal::get() const {
  // @@protoc_insertion_point(field_get:communicator.Internal.get)
  return has_get()
      ? *payload_.get_
      : ::communicator::Get::default_instance();
}
inline ::communicator::Get* Internal::mutable_get() {
  if (!has_get()) {
    clear_payload();
    set_has_get();
    payload_.get_ = new ::communicator::Get;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Internal.get)
  return payload_.get_;
}
inline ::communicator::Get* Internal::release_get() {
  // @@protoc_insertion_point(field_release:communicator.Internal.get)
  if (has_get()) {
    clear_has_payload();
    ::communicator::Get* temp = payload_.get_;
    payload_.get_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Internal::set_allocated_get(::communicator::Get* get) {
  clear_payload();
  if (get) {
    set_has_get();
    payload_.get_ = get;
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Internal.get)
}

// .communicator.Get_r getr = 4;
inline bool Internal::has_getr() const {
  return payload_case() == kGetr;
}
inline void Internal::set_has_getr() {
  _oneof_case_[0] = kGetr;
}
inline void Internal::clear_getr() {
  if (has_getr()) {
    delete payload_.getr_;
    clear_has_payload();
  }
}
inline  const ::communicator::Get_r& Internal::getr() const {
  // @@protoc_insertion_point(field_get:communicator.Internal.getr)
  return has_getr()
      ? *payload_.getr_
      : ::communicator::Get_r::default_instance();
}
inline ::communicator::Get_r* Internal::mutable_getr() {
  if (!has_getr()) {
    clear_payload();
    set_has_getr();
    payload_.getr_ = new ::communicator::Get_r;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Internal.getr)
  return payload_.getr_;
}
inline ::communicator::Get_r* Internal::release_getr() {
  // @@protoc_insertion_point(field_release:communicator.Internal.getr)
  if (has_getr()) {
    clear_has_payload();
    ::communicator::Get_r* temp = payload_.getr_;
    payload_.getr_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Internal::set_allocated_getr(::communicator::Get_r* getr) {
  clear_payload();
  if (getr) {
    set_has_getr();
    payload_.getr_ = getr;
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Internal.getr)
}

// .communicator.Set set = 5;
inline bool Internal::has_set() const {
  return payload_case() == kSet;
}
inline void Internal::set_has_set() {
  _oneof_case_[0] = kSet;
}
inline void Internal::clear_set() {
  if (has_set()) {
    delete payload_.set_;
    clear_has_payload();
  }
}
inline  const ::communicator::Set& Internal::set() const {
  // @@protoc_insertion_point(field_get:communicator.Internal.set)
  return has_set()
      ? *payload_.set_
      : ::communicator::Set::default_instance();
}
inline ::communicator::Set* Internal::mutable_set() {
  if (!has_set()) {
    clear_payload();
    set_has_set();
    payload_.set_ = new ::communicator::Set;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Internal.set)
  return payload_.set_;
}
inline ::communicator::Set* Internal::release_set() {
  // @@protoc_insertion_point(field_release:communicator.Internal.set)
  if (has_set()) {
    clear_has_payload();
    ::communicator::Set* temp = payload_.set_;
    payload_.set_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Internal::set_allocated_set(::communicator::Set* set) {
  clear_payload();
  if (set) {
    set_has_set();
    payload_.set_ = set;
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Internal.set)
}

// .communicator.Set_r setr = 6;
inline bool Internal::has_setr() const {
  return payload_case() == kSetr;
}
inline void Internal::set_has_setr() {
  _oneof_case_[0] = kSetr;
}
inline void Internal::clear_setr() {
  if (has_setr()) {
    delete payload_.setr_;
    clear_has_payload();
  }
}
inline  const ::communicator::Set_r& Internal::setr() const {
  // @@protoc_insertion_point(field_get:communicator.Internal.setr)
  return has_setr()
      ? *payload_.setr_
      : ::communicator::Set_r::default_instance();
}
inline ::communicator::Set_r* Internal::mutable_setr() {
  if (!has_setr()) {
    clear_payload();
    set_has_setr();
    payload_.setr_ = new ::communicator::Set_r;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Internal.setr)
  return payload_.setr_;
}
inline ::communicator::Set_r* Internal::release_setr() {
  // @@protoc_insertion_point(field_release:communicator.Internal.setr)
  if (has_setr()) {
    clear_has_payload();
    ::communicator::Set_r* temp = payload_.setr_;
    payload_.setr_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Internal::set_allocated_setr(::communicator::Set_r* setr) {
  clear_payload();
  if (setr) {
    set_has_setr();
    payload_.setr_ = setr;
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Internal.setr)
}

// .communicator.Send send = 7;
inline bool Internal::has_send() const {
  return payload_case() == kSend;
}
inline void Internal::set_has_send() {
  _oneof_case_[0] = kSend;
}
inline void Internal::clear_send() {
  if (has_send()) {
    delete payload_.send_;
    clear_has_payload();
  }
}
inline  const ::communicator::Send& Internal::send() const {
  // @@protoc_insertion_point(field_get:communicator.Internal.send)
  return has_send()
      ? *payload_.send_
      : ::communicator::Send::default_instance();
}
inline ::communicator::Send* Internal::mutable_send() {
  if (!has_send()) {
    clear_payload();
    set_has_send();
    payload_.send_ = new ::communicator::Send;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Internal.send)
  return payload_.send_;
}
inline ::communicator::Send* Internal::release_send() {
  // @@protoc_insertion_point(field_release:communicator.Internal.send)
  if (has_send()) {
    clear_has_payload();
    ::communicator::Send* temp = payload_.send_;
    payload_.send_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Internal::set_allocated_send(::communicator::Send* send) {
  clear_payload();
  if (send) {
    set_has_send();
    payload_.send_ = send;
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Internal.send)
}

// .communicator.Send_r sendr = 8;
inline bool Internal::has_sendr() const {
  return payload_case() == kSendr;
}
inline void Internal::set_has_sendr() {
  _oneof_case_[0] = kSendr;
}
inline void Internal::clear_sendr() {
  if (has_sendr()) {
    delete payload_.sendr_;
    clear_has_payload();
  }
}
inline  const ::communicator::Send_r& Internal::sendr() const {
  // @@protoc_insertion_point(field_get:communicator.Internal.sendr)
  return has_sendr()
      ? *payload_.sendr_
      : ::communicator::Send_r::default_instance();
}
inline ::communicator::Send_r* Internal::mutable_sendr() {
  if (!has_sendr()) {
    clear_payload();
    set_has_sendr();
    payload_.sendr_ = new ::communicator::Send_r;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Internal.sendr)
  return payload_.sendr_;
}
inline ::communicator::Send_r* Internal::release_sendr() {
  // @@protoc_insertion_point(field_release:communicator.Internal.sendr)
  if (has_sendr()) {
    clear_has_payload();
    ::communicator::Send_r* temp = payload_.sendr_;
    payload_.sendr_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Internal::set_allocated_sendr(::communicator::Send_r* sendr) {
  clear_payload();
  if (sendr) {
    set_has_sendr();
    payload_.sendr_ = sendr;
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Internal.sendr)
}

// .communicator.Receive receive = 9;
inline bool Internal::has_receive() const {
  return payload_case() == kReceive;
}
inline void Internal::set_has_receive() {
  _oneof_case_[0] = kReceive;
}
inline void Internal::clear_receive() {
  if (has_receive()) {
    delete payload_.receive_;
    clear_has_payload();
  }
}
inline  const ::communicator::Receive& Internal::receive() const {
  // @@protoc_insertion_point(field_get:communicator.Internal.receive)
  return has_receive()
      ? *payload_.receive_
      : ::communicator::Receive::default_instance();
}
inline ::communicator::Receive* Internal::mutable_receive() {
  if (!has_receive()) {
    clear_payload();
    set_has_receive();
    payload_.receive_ = new ::communicator::Receive;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Internal.receive)
  return payload_.receive_;
}
inline ::communicator::Receive* Internal::release_receive() {
  // @@protoc_insertion_point(field_release:communicator.Internal.receive)
  if (has_receive()) {
    clear_has_payload();
    ::communicator::Receive* temp = payload_.receive_;
    payload_.receive_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Internal::set_allocated_receive(::communicator::Receive* receive) {
  clear_payload();
  if (receive) {
    set_has_receive();
    payload_.receive_ = receive;
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Internal.receive)
}

// .communicator.Receive_r receiver = 10;
inline bool Internal::has_receiver() const {
  return payload_case() == kReceiver;
}
inline void Internal::set_has_receiver() {
  _oneof_case_[0] = kReceiver;
}
inline void Internal::clear_receiver() {
  if (has_receiver()) {
    delete payload_.receiver_;
    clear_has_payload();
  }
}
inline  const ::communicator::Receive_r& Internal::receiver() const {
  // @@protoc_insertion_point(field_get:communicator.Internal.receiver)
  return has_receiver()
      ? *payload_.receiver_
      : ::communicator::Receive_r::default_instance();
}
inline ::communicator::Receive_r* Internal::mutable_receiver() {
  if (!has_receiver()) {
    clear_payload();
    set_has_receiver();
    payload_.receiver_ = new ::communicator::Receive_r;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Internal.receiver)
  return payload_.receiver_;
}
inline ::communicator::Receive_r* Internal::release_receiver() {
  // @@protoc_insertion_point(field_release:communicator.Internal.receiver)
  if (has_receiver()) {
    clear_has_payload();
    ::communicator::Receive_r* temp = payload_.receiver_;
    payload_.receiver_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Internal::set_allocated_receiver(::communicator::Receive_r* receiver) {
  clear_payload();
  if (receiver) {
    set_has_receiver();
    payload_.receiver_ = receiver;
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Internal.receiver)
}

// .communicator.Stats stats = 11;
inline bool Internal::has_stats() const {
  return payload_case() == kStats;
}
inline void Internal::set_has_stats() {
  _oneof_case_[0] = kStats;
}
inline void Internal::clear_stats() {
  if (has_stats()) {
    delete payload_.stats_;
    clear_has_payload();
  }
}
inline  const ::communicator::Stats& Internal::stats() const {
  // @@protoc_insertion_point(field_get:communicator.Internal.stats)
  return has_stats()
      ? *payload_.stats_
      : ::communicator::Stats::default_instance();
}
inline ::communicator::Stats* Internal::mutable_stats() {
  if (!has_stats()) {
    clear_payload();
    set_has_stats();
    payload_.stats_ = new ::communicator::Stats;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Internal.stats)
  return payload_.stats_;
}
inline ::communicator::Stats* Internal::release_stats() {
  // @@protoc_insertion_point(field_release:communicator.Internal.stats)
  if (has_stats()) {
    clear_has_payload();
    ::communicator::Stats* temp = payload_.stats_;
    payload_.stats_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Internal::set_allocated_stats(::communicator::Stats* stats) {
  clear_payload();
  if (stats) {
    set_has_stats();
    payload_.stats_ = stats;
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Internal.stats)
}

// .aiCommunicator.InternalAI externalAImessage = 12;
inline bool Internal::has_externalaimessage() const {
  return payload_case() == kExternalAImessage;
}
inline void Internal::set_has_externalaimessage() {
  _oneof_case_[0] = kExternalAImessage;
}
inline void Internal::clear_externalaimessage() {
  if (has_externalaimessage()) {
    delete payload_.externalaimessage_;
    clear_has_payload();
  }
}
inline  const ::aiCommunicator::InternalAI& Internal::externalaimessage() const {
  // @@protoc_insertion_point(field_get:communicator.Internal.externalAImessage)
  return has_externalaimessage()
      ? *payload_.externalaimessage_
      : ::aiCommunicator::InternalAI::default_instance();
}
inline ::aiCommunicator::InternalAI* Internal::mutable_externalaimessage() {
  if (!has_externalaimessage()) {
    clear_payload();
    set_has_externalaimessage();
    payload_.externalaimessage_ = new ::aiCommunicator::InternalAI;
  }
  // @@protoc_insertion_point(field_mutable:communicator.Internal.externalAImessage)
  return payload_.externalaimessage_;
}
inline ::aiCommunicator::InternalAI* Internal::release_externalaimessage() {
  // @@protoc_insertion_point(field_release:communicator.Internal.externalAImessage)
  if (has_externalaimessage()) {
    clear_has_payload();
    ::aiCommunicator::InternalAI* temp = payload_.externalaimessage_;
    payload_.externalaimessage_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Internal::set_allocated_externalaimessage(::aiCommunicator::InternalAI* externalaimessage) {
  clear_payload();
  if (externalaimessage) {
    set_has_externalaimessage();
    payload_.externalaimessage_ = externalaimessage;
  }
  // @@protoc_insertion_point(field_set_allocated:communicator.Internal.externalAImessage)
}

inline bool Internal::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Internal::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Internal::PayloadCase Internal::payload_case() const {
  return Internal::PayloadCase(_oneof_case_[0]);
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace communicator

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::communicator::Basic_ctrl_TRX> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::communicator::Basic_ctrl_TRX>() {
  return ::communicator::Basic_ctrl_TRX_descriptor();
}
template <> struct is_proto_enum< ::communicator::Mac_ack_stat_AckStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::communicator::Mac_ack_stat_AckStatus>() {
  return ::communicator::Mac_ack_stat_AckStatus_descriptor();
}
template <> struct is_proto_enum< ::communicator::Application_data_PACKET_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::communicator::Application_data_PACKET_TYPE>() {
  return ::communicator::Application_data_PACKET_TYPE_descriptor();
}
template <> struct is_proto_enum< ::communicator::Application_data_TRAFFIC_CLASS> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::communicator::Application_data_TRAFFIC_CLASS>() {
  return ::communicator::Application_data_TRAFFIC_CLASS_descriptor();
}
template <> struct is_proto_enum< ::communicator::Get_GET_ATTRIBUTE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::communicator::Get_GET_ATTRIBUTE>() {
  return ::communicator::Get_GET_ATTRIBUTE_descriptor();
}
template <> struct is_proto_enum< ::communicator::MODULE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::communicator::MODULE>() {
  return ::communicator::MODULE_descriptor();
}
template <> struct is_proto_enum< ::communicator::TRANSACTION_RESULT> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::communicator::TRANSACTION_RESULT>() {
  return ::communicator::TRANSACTION_RESULT_descriptor();
}
template <> struct is_proto_enum< ::communicator::BW_INDEX> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::communicator::BW_INDEX>() {
  return ::communicator::BW_INDEX_descriptor();
}
template <> struct is_proto_enum< ::communicator::SLOT_MODE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::communicator::SLOT_MODE>() {
  return ::communicator::SLOT_MODE_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_interf_2eproto__INCLUDED
