#include "phy.h"

// *********** Global variables ***********
static phy_handle_t *phy_handle = NULL;

extern int errno;

/**********************************************************************
 *  Program arguments processing
 ***********************************************************************/
void args_default(transceiver_args_t *args) {
  args->logging_frequency = 30000; // how frequent the log happens in milliseconds.
  args->single_log_duration = 1000; // duration of a single log in milliseconds.
  args->rnti = 0x1234;
  args->path_to_log_files = "./"; // location of the directory to collect log
  args->disable_cfo = false;
  args->nof_prb = 25;
  args->nof_ports = 1;
  args->rf_args = "";
  args->competition_center_frequency = 2400000000.0; // By default, if no center frequency is set, the center frequency will be 2.4 GHz.
  args->initial_rx_gain = 70.0; // AGC is disabled by default and the initial gain given to the RX chain is 70 dB. It will set the maximum gain in x310.
  args->initial_tx_gain = 70.0;
  args->path_to_start_file = "./start_iq_sample_capture.txt", // full path to the file generated by start.sh
  args->node_operation = -1; // 0 - RX, 1 - TX, -1 - Automatic configuration via basic control.
  args->node_id = 0x1234; // srn node id
  args->max_number_of_dumps = 1, // Maxium number of dump files to be created.
  args->sensing_rx_gain = 0; // RX gain that should be applied to the specific channel RX cahin. Value given in dB.
  args->radio_id = 0; // By default all radio IDs are zero, meaning the Cell-ID is 0.
  args->use_std_carrier_sep = true; // By default, we use LTE standard sampling rates according to the the FFT size.
  args->initial_agc_gain = 50.0;
  args->competition_bw = 20000000.0; // Competition bandwidth is by default set to 20 MHz.
  args->default_tx_channel = 0;
  args->default_rx_channel = 0;
  args->lbt_threshold = 1000.0; // By default we set the channel threshold to 1000 dBm. In other others, LBT is disabled when threshold is too high.
  args->lbt_timeout = 10000000000000; // This parameter is given in milliseconds.
  args->max_turbo_decoder_noi = 4; // By default the maximum number of Turbo decoding iterations is set to 4.
  args->phy_filtering = false; // By default PHY filtering is disabled.
  args->iq_dump_data_type = SRSLTE_COMPLEX_SHORT_BIN; // By default we write complex<short> into file in order to get smaller files.
  args->rf_monitor_rx_sample_rate = 23040000.0; // By default the RF Monitor module will sample at 23.04 MHz.
  args->rf_monitor_channel = RF_MONITOR_CHANNEL; // By default we set the rf_monitor channel to 1.
  args->lbt_use_fft_based_pwr = false; // By default we use time-domain based power measurements.
  args->send_tx_stats_to_mac = false; // By default we do not send TX statistics to MAC as it does not use it for now.
  args->max_backoff_period = 32; // By default the maximum backoff period is set to 15.
  args->iq_dumping = false; // By default we never create IQ dumping files.
  args->immediate_transmission = false; // By default immediate transmissions are not allowed.
  args->add_tx_timestamp = false;
  args->rf_monitor_option = 100; // By default no rf monitor modules is set as the rf monitor option.
  args->initial_subframe_index = 5; // By default subframe is 5. Set the subframe index number to be used to start from.
  args->plot_rx_info = false; // By default plotting is disabled.
  args->rf_amp = 0.8; // RF Amp.
  args->trx_filter_idx = 0; // By default TRX filtering is disabled.
}

void usage(transceiver_args_t *args, char *prog) {
  printf("Usage: %s [abcgiplomnsxqzwXBPCRdDvrfUSZTIFLMNGQWh]\n", prog);
  printf("\t-a RF args [Default %s]\n", args->rf_args);
  printf("\t-b RF amp. [Default %s]\n", args->rf_amp);
  printf("\t-B Set competition bandwidth [Default %1.2f MHz]\n", args->competition_bw/1000000.0);
  printf("\t-g Set RX gain [Default %.1f dB]\n", args->initial_rx_gain);
  printf("\t-t Set TX gain [Default %.1f dB]\n", args->initial_tx_gain);
  printf("\t-l Set LBT threshold. Values greater than or equal to 100 dB disable LBT. [Default %1.0f dB]\n", args->lbt_threshold);
  printf("\t-o Set LBT timeout [Default %d milliseconds]\n", args->lbt_timeout);
  printf("\t-q Enable IQ dumping. Options are on/off [Default %s]\n", args->iq_dumping?"on":"off");
  printf("\t-c Use FFT based power measurements [Default %s]\n", args->lbt_use_fft_based_pwr?"Enabled":"Disabled");
  printf("\t-z Use immediate transmissions [Default %s]\n", args->immediate_transmission?"Enabled":"Disabled");
  printf("\t-x Enable transmission of TX statistics to MAC layer [Default %s]\n", args->send_tx_stats_to_mac?"True":"False");
  printf("\t-X Set maximum backoff period [Default %d]\n", args->max_backoff_period);
  printf("\t-i Radio ID [Default: %d]\n",args->radio_id);
  printf("\t-n PHY Filtering [Default %d]\n", args->phy_filtering);
  printf("\t-N Add timestamp to TX packet [Default %d]\n", args->add_tx_timestamp);
  printf("\t-f Competition Central Frequency at which the PHY and the sensing modules should operate on (in Hz) [Default %.1f Hz]\n",args->competition_center_frequency);
  printf("\t-p Set number of Physical Resource Blocks (nof_prb) [Default %d]\n", args->nof_prb);
  printf("\t-P Set number of ports (nof_ports) [Default %d]\n", args->nof_ports);
  printf("\t-Q Enable TRX filtering [Default %d]\n", args->trx_filter_idx);
  printf("\t-r RNTI in Hex [Default 0x%x]\n",args->rnti);
  printf("\t-C Disable CFO correction [Default %s]\n", args->disable_cfo?"Disabled":"Enabled");
  printf("\t-s RX sampling rate for RF monitor module [Default %1.2f]\n", args->rf_monitor_rx_sample_rate);
  printf("\t-m Maximum number of turbo decoder iterations [Default %d]\n", args->max_turbo_decoder_noi);
  printf("\t-S Path to check for start dumping file [Default %s]\n", args->path_to_start_file);
  printf("\t-L Path where the IQ dump files should be stored [Default %s]\n", args->path_to_log_files);
  printf("\t-I Node ID [Default %d]\n", args->node_id);
  printf("\t-F Logging frequency in milliseconds, frequency in milliseconds with which dump files should be created [Default %d]\n", args->logging_frequency);
  printf("\t-D Single log file duration in milliseconds [Default %d]\n", args->single_log_duration);
  printf("\t-M Maximum number of dumping files to be created [Default %d]\n", args->max_number_of_dumps);
  printf("\t-G Gain given to the sensing RX chain [Default %1.2f]\n", args->sensing_rx_gain);
  printf("\t-d [set development debug level, default disabled]\n");
  printf("\t-v [set scatter_verbose_level to debug, default none]\n");
  printf("\t-Z Use non-standard sampling rates, [Default %d]\n",args->use_std_carrier_sep);
  printf("\t-T [set single operation mode of the node, i.e., it can operate only as TX or RX. 1 -> RX, 2 -> TX]\n");
  printf("\t-R Set the RF monitor module to be started. [Default %d]\n", args->rf_monitor_option);
  printf("\t-w Set the subframe index to be used to start from. [Default %d]\n", args->initial_subframe_index);
  printf("\t-W Enable RX info plot. [Default %s]\n", args->plot_rx_info?"TRUE":"FALSE");
  printf("\t-h Print this help message\n");
}

void parse_args(transceiver_args_t *args, int argc, char **argv) {
  int opt;
  args_default(args);
  while((opt = getopt(argc, argv, "abcdogiplmnsxqzwXBPQOCDvrfUSZTIFLMNGRWht0123456789")) != -1) {
    switch (opt) {
    case 'i':
      args->radio_id = atoi(argv[optind]);
      break;
    case 'p':
      args->nof_prb = helpers_get_prb_from_bw(atoi(argv[optind]));
      PHY_PRINT("Requested PHY BW: %d - Mapped PHY PRB: %d\n",atoi(argv[optind]), args->nof_prb);
      break;
    case 'n':
      args->phy_filtering = true;
      break;
    case 'N':
      args->add_tx_timestamp = true;
      PHY_PRINT("Addition of TX timestamp is enabled.\n",0);
      break;
    case 'P':
      args->nof_ports = atoi(argv[optind]);
      break;
    case 'a':
      PHY_PRINT("RF args: %s\n",argv[optind]);
      args->rf_args = argv[optind];
      break;
    case 'l':
      args->lbt_threshold = atof(argv[optind]);
      PHY_PRINT("LBT threshold: %1.2f\n",args->lbt_threshold);
      PHY_PRINT("LBT checking is %s\n",args->lbt_threshold < 100.0?"Enabled":"Disabled");
      break;
    case 'o':
      args->lbt_timeout = atoll(argv[optind]);
      PHY_PRINT("LBT timeout: %" PRIu64 "\n",args->lbt_timeout);
      break;
    case 'q':
      if(strcmp("on", argv[optind]) == 0) {
        args->iq_dumping = true;
        // If IQ dumping is on then the RF monitor option must be 0, meaning, IQ Dump module.
        args->rf_monitor_option = 4;
      } else if(strcmp("off", argv[optind]) == 0) {
        args->iq_dumping = false;
      } else {
        args->iq_dumping = false;
      }
      PHY_PRINT("IQ dumping: %s\n",args->iq_dumping?"on":"off");
      break;
    case 'R':
      if(strcmp("iq_dumping", argv[optind]) == 0) {
        args->rf_monitor_option = 0;
      } else if(strcmp("lbt", argv[optind]) == 0) {
        args->rf_monitor_option = 1;
      } else if(strcmp("rssi_monitor", argv[optind]) == 0) {
        args->rf_monitor_option = 2;
      } else if(strcmp("spectrum_sensing", argv[optind]) == 0) {
        args->rf_monitor_option = 3;
      } else if(strcmp("iq_dump_plus_sensing", argv[optind]) == 0) {
        args->rf_monitor_option = 4;
      } else {
        args->rf_monitor_option = 100;
      }
      PHY_PRINT("RF monitor option: %d\n",args->rf_monitor_option);
      break;
    case 'B':
      args->competition_bw = atof(argv[optind]);
      PHY_PRINT("Competition BW: %.2f [MHz]\n",args->competition_bw/1000000.0);
      break;
    case 'b':
      args->rf_amp = atof(argv[optind]);
      PHY_PRINT("RF amp: %f\n",args->rf_amp);
      break;
    case 'g':
      args->initial_rx_gain = atof(argv[optind]);
      break;
    case 't':
      args->initial_tx_gain = atof(argv[optind]);
      break;
    case 'c':
      args->lbt_use_fft_based_pwr = true;
      PHY_PRINT("FFT based power measurement is enabled.\n",0);
      break;
    case 'z':
      args->immediate_transmission = true;
      PHY_PRINT("Immediate transmissions are enabled.\n",0);
      break;
    case 'W':
      args->plot_rx_info = true;
      PHY_PRINT("Plot of RX info enabled.\n",0);
      break;
    case 'w':
      args->initial_subframe_index = atoi(argv[optind]);
      PHY_PRINT("Initial subframe index set to: %d\n",args->initial_subframe_index);
      break;
    case 'x':
      args->send_tx_stats_to_mac = true;
      PHY_PRINT("Transmission of PHY TX stats to MAC layer is enabled.\n",0);
      break;
    case 'X':
      args->max_backoff_period = atoi(argv[optind]);
      PHY_PRINT("Maximum backoff period set to: %d\n",args->max_backoff_period);
      break;
    case 'C':
      args->disable_cfo = true;
      break;
    case 'f':
      args->competition_center_frequency = strtod(argv[optind], NULL);
      PHY_PRINT("Center frequency received from command line: %1.3f [MHz]\n",args->competition_center_frequency/1000000.0);
      break;
    case 'r':
      args->rnti = strtol(argv[optind], NULL, 16);
      break;
    case 'd':
      development_debug_level++;
      break;
    case 'v':
      scatter_verbose_level++;
      break;
    case 'Q':
#if(ENABLE_PHY_TX_FILTERING==1)
      args->trx_filter_idx++;
      if(args->trx_filter_idx==1) {
        PHY_PRINT("TRX Filtering enabled.\n",0);
      }
#endif
      break;
    case 'm':
      args->max_turbo_decoder_noi = atoi(argv[optind]);
      PHY_PRINT("Max. turbo decoding iterations: %d\n",args->max_turbo_decoder_noi);
      break;
    case 's':
      args->rf_monitor_rx_sample_rate = atof(argv[optind]);
      PHY_PRINT("RF Monitor sampling rate: %1.2f [MHz]\n",args->rf_monitor_rx_sample_rate/1000000.0);
      break;
    case 'Z':
      args->use_std_carrier_sep = false;
      PHY_PRINT("Using Non-standard sampling rates.\n",0);
      break;
    case 'T':
      args->node_operation = atoi(argv[optind]);
      PHY_PRINT("Node Operation: %d\n",args->node_operation);
      break;
    case 'S':
      args->path_to_start_file = argv[optind];
      break;
    case 'D':
      args->single_log_duration = atoi(argv[optind]);
      break;
    case 'L':
      args->path_to_log_files = argv[optind];
      break;
    case 'I':
      args->node_id = atoi(argv[optind]);
      break;
    case 'F':
      args->logging_frequency = atoi(argv[optind]);
      break;
    case 'M':
      args->max_number_of_dumps = atoi(argv[optind]);
      break;
    case 'G':
      args->sensing_rx_gain = atof(argv[optind]);
      break;
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
      break;
    case 'h':
    default:
      usage(args, argv[0]);
      exit(-1);
    }
  }
}
/**********************************************************************/

void sig_int_handler(int signo) {
  if(signo == SIGINT) {
    phy_handle->go_exit = true;
    PHY_PRINT("SIGINT received. Exiting...\n",0);
  }
}

void initialize_signal_handler() {
  sigset_t sigset;
  sigemptyset(&sigset);
  sigaddset(&sigset, SIGINT);
  sigprocmask(SIG_UNBLOCK, &sigset, NULL);
  signal(SIGINT, sig_int_handler);
}

void open_rf_device() {
  // Open USRP.
  PHY_PRINT("Opening RF device...\n",0);
  if(srslte_rf_open(&phy_handle->rf, phy_handle->prog_args.rf_args)) {
    PHY_ERROR("Error opening rf.\n",0);
    exit(-1);
  }
}

void close_rf_device() {
  if(srslte_rf_close(&phy_handle->rf)) {
    PHY_ERROR("Error closing rf.\n",0);
    exit(-1);
  }
  PHY_PRINT("srslte_rf_close done!\n",0);
}

void change_process_priority(int inc) {
  errno = 0;
  if(nice(inc) == -1) {
    if(errno != 0) {
      PHY_ERROR("Something went wrong with nice(): %s - Perhaps you should run it as root.\n",strerror(errno));
    }
  }
}

void set_master_clock_rate() {
  // We always set the master clock rate to the maximum one, i.e., for a system with 100 PRB (20 MHz BW).
  uint32_t nof_prb = 100;
  // Calculate the master clock rate for a bandwidth of 20 MHz, i.e., 100 PRB.
  int srate = srslte_sampling_freq_hz(nof_prb);
  // Set the master clock rate.
  srslte_rf_set_master_clock_rate(&phy_handle->rf, srate);
  PHY_PRINT("Set master clock rate to: %.2f [MHz]\n", (float)srate/1000000);
}

#if(ENABLE_SENSING_THREAD==1)
void initialize_rf_monitor() {
  if(phy_handle->prog_args.rf_monitor_option <= 4 && phy_handle->rf.num_of_channels > 1) {
    int rc = rf_monitor_initialize(&phy_handle->rf, &phy_handle->prog_args);
    if(rc) {
      PHY_ERROR("ABORTING; It was not possible to start the sensing module.\n",0);
      exit(-1);
    }
  }
}

void uninitialize_rf_monitor() {
   if(phy_handle->prog_args.rf_monitor_option <= 4  && phy_handle->rf.num_of_channels > 1) {
     int rc = rf_monitor_uninitialize();
     if(rc) {
       PHY_ERROR("ABORTING; It was not possible to uninitialize the sensing module.\n",0);
       exit(-1);
     }
     PHY_PRINT("RF monitoring uninitialization done!\n",0);
   }
 }
#endif

void get_module_and_target_name(char *module_name, char *target_name) {
  // If we are testing the PHY with a single host PC we need to have two distinct names for PHY, otherwise, the test scripts will receive
  // responses from the other PHY.
  if(phy_handle->prog_args.node_operation == -1) {
    strcpy(module_name, "MODULE_PHY");
    strcpy(target_name, "MODULE_MAC");
    PHY_DEBUG("module_name: %s - target_name: %s\n",module_name, target_name);
  } else if(phy_handle->prog_args.node_operation == PHY_DEBUG_1) {
    strcpy(module_name, "MODULE_PHY_DEBUG_1");
    strcpy(target_name, "MODULE_MAC_DEBUG_1");
    PHY_DEBUG("module_name: %s - target_name: %s\n",module_name, target_name);
  } else if(phy_handle->prog_args.node_operation == PHY_DEBUG_2) {
    strcpy(module_name, "MODULE_PHY_DEBUG_2");
    strcpy(target_name, "MODULE_MAC_DEBUG_2");
    PHY_DEBUG("module_name: %s - target_name: %s\n",module_name, target_name);
  } else {
    PHY_ERROR("Node operation was not defined correctly.\n",0);
    exit(-1);
  }
}

//*************************************************************************
//                            BEGIN OF MAIN
//*************************************************************************
int main(int argc, char **argv) {

  LayerCommunicator_handle handle = NULL;
  char module_name[20];
  char target_name[20];
  basic_ctrl_t basic_ctrl;
  unsigned char *(*circular_data_buffer_ptr[]) = {NULL};

  // Allocate memory for a new trx object.
  phy_handle = (phy_handle_t*)srslte_vec_malloc(sizeof(phy_handle_t));
  // Check if memory allocation was correctly done.
  if(phy_handle == NULL) {
    PHY_ERROR("Error allocating memory for TRX context.\n",0);
    return -1;
  }
  // Set circular buffer counter to zero.
  phy_handle->tx_data_buffer_cnt = 0;
  // Initialize flag to exit phy.
  phy_handle->go_exit = false;
  // Change process priority.
  change_process_priority(-20);
  // Initialize signal handler.
  initialize_signal_handler();
  // Parse command line arguments.
  parse_args(&phy_handle->prog_args, argc, argv);
  // Open RF device (USRP).
  open_rf_device();
  // Set master clock rate.
  // We always set the master clock rate to the maximum one, i.e., for a system with 100 PRB (20 MHz BW).
  set_master_clock_rate();
  // Set FPGA time to the current host time so that we can use the host time (ntp) to synchronize among nodes.
  phy_set_fpga_time(&phy_handle->rf);
  // Rertieve target name.
  get_module_and_target_name(module_name, target_name);
  // Instantiate communicator module so that we can receive/transmit commands and data
  communicator_make(module_name, target_name, &handle);

  // Initialize PHY reception thread.
  if(phy_reception_initialize(handle, &phy_handle->rf, &phy_handle->prog_args) < 0) {
    PHY_ERROR("It was not possible to start the PHY reception thread.\n",0);
    exit(-1);
  }

  // Initialize PHY transmission thread.
  if(phy_transmission_initialize(handle, &phy_handle->rf, &phy_handle->prog_args, circular_data_buffer_ptr) < 0) {
    PHY_ERROR("It was not possible to start the PHY transmission thread.\n",0);
    exit(-1);
  }

#if(ENABLE_SENSING_THREAD==1)
  // Initialize rf monitor: After setting the Master clock rate we can start the rf monitor thread only if the number of opened channels is greater than 1.
  initialize_rf_monitor();
#endif

  PHY_PRINT("-------------------------------------------------\n\n",0);

  //**************************************** Handle incoming messages - BEGIN *****************************************
  // Loop where the FSM is implemented.
  while(!phy_handle->go_exit) {
    // Try to retrieve a message from the QUEUE. It waits for a specified amount of time before timing out.
    bool ret = communicator_get_low_queue_wait_for(handle, 1000, (void * const)&basic_ctrl, NULL, (*circular_data_buffer_ptr)[phy_handle->tx_data_buffer_cnt]);
    // If message is properly retrieved and parsed, then relay it to the correct module.
    if(!phy_handle->go_exit && ret) {
      // Call FSM function to handle the state.
      phy_fsm(&basic_ctrl, handle);
      // Print some basic information.
      HELPERS_PRINT_BASIC_CONTROL(&basic_ctrl);
    }
  }
  //**************************************** Handle incoming messages - END *****************************************
  PHY_PRINT("Start uninitialization of modules.\n",0);

  // After use, communicator handle MUST be freed.
  communicator_free(&handle);
  PHY_PRINT("Communicator handle freed.\n",0);

#if(ENABLE_SENSING_THREAD==1)
  // Free all resources used by the sensing module.
  uninitialize_rf_monitor();
#endif

  // Stop and free all resources related to the PHY transmission thread.
  if(phy_transmission_uninitialize() < 0) {
    PHY_ERROR("It was not possible to uninitialize the PHY transmission thread.\n",0);
    exit(-1);
  }
  PHY_PRINT("Transmission uninitialization done!\n",0);

  // Stop and free all resources related to the PHY reception thread.
  if(phy_reception_uninitialize(&phy_handle->prog_args) < 0) {
    PHY_ERROR("It was not possible to uninitialize the PHY reception thread.\n",0);
    exit(-1);
  }
  PHY_PRINT("Reception uninitialization done!\n",0);

  // Free memory used to store Rx object.
  if(phy_handle) {
    free(phy_handle);
    phy_handle = NULL;
  }
  PHY_PRINT("TRX handle uninitialization done!\n",0);

  PHY_PRINT("Bye...\n",0);
  exit(0);
}

void phy_fsm(basic_ctrl_t *basic_ctrl, LayerCommunicator_handle handle) {
  switch(basic_ctrl->trx_flag) {
    case PHY_TX_ST:
#if(ADJUST_FPGA_TIME==1)
      // Adjust FPGA time.
      phy_adjust_fpga_time(&phy_handle->rf);
#endif
      // Push basic control message into the container.
      phy_transmission_push_tx_basic_control_to_container(basic_ctrl);
      // Debugging the pace of pushing and popping from the QUEUE.
#if(ENABLE_TX_IPC_DEBUG==1)
      if(phy_handle->tx_data_buffer_cnt == NUMBER_OF_TX_DATA_BUFFERS-1) {
         PHY_PRINT("Tx user data buffer full, going back to beginning.\n",0);
      }
#endif
      // Increment the counter used in the circular tx data buffer.
      phy_handle->tx_data_buffer_cnt = (phy_handle->tx_data_buffer_cnt + 1)%NUMBER_OF_TX_DATA_BUFFERS;
      break;
    case PHY_RX_ST:
      // Change reception parameters according to received basic control message.
      phy_reception_change_parameters(&phy_handle->rf, basic_ctrl);
      break;
    default:
      PHY_ERROR("Invalid state...\n",0);
  }
}
